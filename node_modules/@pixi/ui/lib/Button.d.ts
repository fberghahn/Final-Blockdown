import { Container, FederatedPointerEvent } from 'pixi.js';
import { Signal } from 'typed-signals';
import { ButtonEvents } from './ButtonEvents';
/**
 * Adds button events to a given container-based view
 *
 * so you can subscribe to them and use your container-based instance as a button.
 * @example
 * const container = new Container();
 * const button = new Button(
 *      new Graphics()
 *          .rect(0, 0, 100, 50, 15)
 *          .fill(0xFFFFFF)
 * );
 *
 * button.onPress.connect(() => console.log('onPress'));
 *
 * container.addChild(button.view);
 */
export declare class Button extends ButtonEvents {
    /** Container, given as a constructor parameter that is a button view. */
    protected _view: Container;
    /**
     * Turns a given container-based view into a button by adding all button events.
     * @param {Container} view - instance of container, to be turned into button.
     */
    constructor(view?: Container);
    /** Set button view, that all the interaction events are applied to. */
    set view(view: Container);
    /** Get button view, thar all the interaction events are applied to. */
    get view(): Container;
    /**
     * Switcher, which prevents all button events from firing if off.
     * @param {boolean} enabled
     */
    set enabled(enabled: boolean);
    /** Getter that returns button state. */
    get enabled(): boolean;
}
/**
 * Button based on container. You can use it same {@link Button}
 * but without need to pre create a container and interact with it through `.view` accessor.
 * @example
 * const button = new ButtonContainer(
 *      new Graphics()
 *          .fill(0xFFFFFF)
 *          .roundRect(0, 0, 100, 50, 15)
 * );
 *
 * button.onPress.connect(() => console.log('onPress'));
 *
 * container.addChild(button);
 */
export declare class ButtonContainer extends Container {
    button: Button;
    onDown: Signal<(btn?: Button, e?: FederatedPointerEvent) => void>;
    onUp: Signal<(btn?: Button, e?: FederatedPointerEvent) => void>;
    onUpOut: Signal<(btn?: Button, e?: FederatedPointerEvent) => void>;
    onOut: Signal<(btn?: Button, e?: FederatedPointerEvent) => void>;
    onPress: Signal<(btn?: Button, e?: FederatedPointerEvent) => void>;
    onHover: Signal<(btn?: Button, e?: FederatedPointerEvent) => void>;
    constructor(view?: Container);
    set enabled(enabled: boolean);
    get enabled(): boolean;
}
//# sourceMappingURL=Button.d.ts.map