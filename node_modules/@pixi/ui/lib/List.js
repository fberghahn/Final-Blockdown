'use strict';

var pixi_js = require('pixi.js');

var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
class List extends pixi_js.Container {
  constructor(options) {
    super();
    __publicField(this, "options");
    /** Container, that holds all inner elements. */
    __publicField(this, "view");
    /** Arrange direction. */
    __publicField(this, "_type");
    /** Returns all arranged elements. */
    __publicField(this, "children", []);
    if (options) {
      this.init(options);
    }
    options?.items?.forEach((item) => this.addChild(item));
    this.on("added", () => this.arrangeChildren());
    this.on("childAdded", () => this.arrangeChildren());
  }
  /**
   * Initiates list component.
   * @param options
   */
  init(options) {
    this.options = options;
    if (options?.type) {
      this.type = options.type;
    }
    if (options?.children) {
      options.children.forEach((child) => this.addChild(child));
    }
  }
  /**
   * Set items arrange direction.
   * @param type - Arrange direction.
   */
  set type(type) {
    this._type = type;
    this.arrangeChildren();
  }
  /**
   * Get items arrange direction.
   * @returns Arrange direction.
   */
  get type() {
    return this._type;
  }
  /**
   * Set element margin.
   * @param margin - Margin between elements.
   */
  set elementsMargin(margin) {
    if (!this.options)
      throw new Error("List has not been initiated!");
    this.options.elementsMargin = margin;
    this.arrangeChildren();
  }
  /**
   * Get element margin.
   * @returns Margin between elements.
   */
  get elementsMargin() {
    return this.options?.elementsMargin ?? 0;
  }
  /**
   * Set padding, overriding all padding options.
   * @param padding - Padding surrounding list elements and its border.
   */
  set padding(padding) {
    if (!this.options)
      throw new Error("List has not been initiated!");
    this.options.padding = padding;
    this.options.vertPadding = padding;
    this.options.horPadding = padding;
    this.options.leftPadding = padding;
    this.options.rightPadding = padding;
    this.options.topPadding = padding;
    this.options.bottomPadding = padding;
    this.arrangeChildren();
  }
  /**
   * Get padding.
   * @returns Padding surrounding list elements and its border.
   */
  get padding() {
    return this.options?.padding ?? 0;
  }
  /**
   * Set vertical padding, overriding all top and bottom padding options.
   * @param padding - Vertical padding between list border and its elements.
   */
  set vertPadding(padding) {
    if (!this.options)
      throw new Error("List has not been initiated!");
    this.options.vertPadding = padding;
    this.options.topPadding = padding;
    this.options.bottomPadding = padding;
    this.arrangeChildren();
  }
  /**
   * Get vertical padding.
   * @returns Vertical padding between list border and its elements.
   */
  get vertPadding() {
    return this.options?.vertPadding ?? this.padding ?? 0;
  }
  /**
   * Set horizontal padding, overriding all left and right padding options.
   * @param padding - Horizontal padding between list border and its elements.
   */
  set horPadding(padding) {
    if (!this.options)
      throw new Error("List has not been initiated!");
    this.options.horPadding = padding;
    this.options.leftPadding = padding;
    this.options.rightPadding = padding;
    this.arrangeChildren();
  }
  /**
   * Get horizontal padding.
   * @returns Horizontal padding between list border and its elements.
   */
  get horPadding() {
    return this.options?.horPadding ?? this.padding ?? 0;
  }
  /**
   * Set left padding.
   * @param padding - Left padding between list border and its elements.
   */
  set leftPadding(padding) {
    if (!this.options)
      throw new Error("List has not been initiated!");
    this.options.leftPadding = padding;
    this.arrangeChildren();
  }
  /**
   * Get left padding.
   * @returns Left padding between list border and its elements.
   */
  get leftPadding() {
    return this.options?.leftPadding ?? this.horPadding;
  }
  /**
   * Set right padding.
   * @param padding - Right padding between list border and its elements.
   */
  set rightPadding(padding) {
    if (!this.options)
      throw new Error("List has not been initiated!");
    this.options.rightPadding = padding;
    this.arrangeChildren();
  }
  /**
   * Get right padding.
   * @returns Right padding between list border and its elements.
   */
  get rightPadding() {
    return this.options?.rightPadding ?? this.horPadding;
  }
  /**
   * Set top padding.
   * @param padding - Top padding between list border and its elements.
   */
  set topPadding(padding) {
    if (!this.options)
      throw new Error("List has not been initiated!");
    this.options.topPadding = padding;
    this.arrangeChildren();
  }
  /**
   * Get top padding.
   * @returns Top padding between list border and its elements.
   */
  get topPadding() {
    return this.options?.topPadding ?? this.vertPadding;
  }
  /**
   * Set bottom padding.
   * @param padding - Bottom padding between list border and its elements.
   */
  set bottomPadding(padding) {
    if (!this.options)
      throw new Error("List has not been initiated!");
    this.options.bottomPadding = padding;
    this.arrangeChildren();
  }
  /**
   * Get bottom padding.
   * @returns Bottom padding between list border and its elements.
   */
  get bottomPadding() {
    return this.options?.bottomPadding ?? this.vertPadding;
  }
  /**
   * Arrange all elements basing in their sizes and component options.
   * Can be arranged vertically, horizontally or bidirectional.
   */
  arrangeChildren() {
    let x = this.leftPadding;
    let y = this.topPadding;
    const elementsMargin = this.options?.elementsMargin ?? 0;
    let maxWidth = this.parent?.width;
    if (this.rightPadding) {
      maxWidth -= this.rightPadding;
    }
    this.children.forEach((child, id) => {
      switch (this.type) {
        case "vertical":
          child.y = y;
          child.x = x;
          y += elementsMargin + child.height;
          break;
        case "horizontal":
          child.x = x;
          child.y = y;
          x += elementsMargin + child.width;
          break;
        default:
          child.x = x;
          child.y = y;
          if (child.x + child.width > maxWidth && id > 0) {
            y += elementsMargin + child.height;
            x = this.leftPadding;
            child.x = x;
            child.y = y;
          }
          x += elementsMargin + child.width;
          break;
      }
    });
  }
  /**
   * Removes items from the list. (Does not destroy them)
   * @param itemID - Item to remove (starting from 0).
   */
  removeItem(itemID) {
    const child = this.children[itemID];
    if (!child) {
      return;
    }
    this.removeChild(child);
    this.arrangeChildren();
  }
}

exports.List = List;
//# sourceMappingURL=List.js.map
