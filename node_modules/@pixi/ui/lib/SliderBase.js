'use strict';

var pixi_js = require('pixi.js');
var ProgressBar = require('./ProgressBar.js');
var view = require('./utils/helpers/view.js');

var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
class SliderBase extends ProgressBar.ProgressBar {
  constructor(options) {
    super(options);
    __publicField(this, "_slider1");
    __publicField(this, "_slider2");
    __publicField(this, "value1Text");
    __publicField(this, "value2Text");
    __publicField(this, "_value1");
    __publicField(this, "_value2");
    __publicField(this, "dragging", 0);
    /** Minimal value. */
    __publicField(this, "_min", 0);
    /** Maximal value. */
    __publicField(this, "_max", 100);
    __publicField(this, "startX");
    __publicField(this, "startUpdateValue1");
    __publicField(this, "startUpdateValue2");
    __publicField(this, "settings");
    this.settings = options;
    this.slider1 = options.slider1;
    this.slider2 = options.slider2;
    this.fill.eventMode = "none";
    this.min = options.min ?? 0;
    this.max = options.max ?? 100;
  }
  /**
   * Sets Slider1 instance.
   * @param value - Container or string with texture name.
   */
  set slider1(value) {
    if (!value)
      return;
    if (this._slider1) {
      this.slider1.removeAllListeners();
      this.slider1.destroy();
    }
    this._slider1 = this.createSlider(value);
    if (this.settings.showValue && !this.value1Text) {
      const TextClass = this.settings.valueTextClass ?? pixi_js.Text;
      this.value1Text = new TextClass({ text: "", style: this.settings.valueTextStyle || { fill: 16777215 } });
      this.value1Text.anchor.set(0.5);
      this.addChild(this.value1Text);
    }
  }
  /** Get Slider1 instance. */
  get slider1() {
    return this._slider1;
  }
  /**
   * Sets Slider2 instance.
   * @param value - Container or string with texture name.
   */
  set slider2(value) {
    if (!value)
      return;
    if (this._slider2) {
      this.slider2.removeAllListeners();
      this.slider2.destroy();
    }
    this._slider2 = this.createSlider(value);
    if (this.settings.showValue && !this.value2Text) {
      const TextClass = this.settings.valueTextClass ?? pixi_js.Text;
      this.value2Text = new TextClass({ text: "", style: this.settings.valueTextStyle || { fill: 16777215 } });
      this.value2Text.anchor.set(0.5);
      this.addChild(this.value2Text);
    }
  }
  /** Get Slider2 instance. */
  get slider2() {
    return this._slider2;
  }
  /**
   * Set bg.
   * @param bg
   */
  setBackground(bg) {
    if (this.bg) {
      this.bg.removeAllListeners();
    }
    super.setBackground(bg);
    this.activateBG();
  }
  activateBG() {
    this.bg.eventMode = "static";
    this.bg.on("pointerdown", this.startUpdate, this).on("globalpointermove", this.update, this).on("pointerup", this.endUpdate, this).on("pointerupoutside", this.endUpdate, this);
  }
  createSlider(sliderData) {
    const slider = view.getView(sliderData);
    slider.eventMode = "none";
    slider.x = slider.width / 2;
    const container = new pixi_js.Container();
    container.addChild(slider);
    if (slider instanceof pixi_js.Sprite) {
      slider.anchor.set(0.5);
    }
    container.y = this.bg?.height / 2;
    this.addChild(container);
    return container;
  }
  startUpdate(event) {
    this.dragging = 1;
    const obj = event.currentTarget;
    this.startX = obj.parent.worldTransform.applyInverse(event.global).x;
    this.startUpdateValue1 = this._value1;
    this.startUpdateValue2 = this._value2;
    this.update(event);
  }
  endUpdate() {
    if (!this.dragging)
      return;
    this.dragging = 0;
    if (!!this.startX || (this.startUpdateValue1 !== this._value1 || this.startUpdateValue2 !== this._value2)) {
      this.change();
    }
    this.startUpdateValue1 = null;
    this.startUpdateValue2 = null;
  }
  onClick() {
    this.change();
  }
  /* Called when dragging started and on every move. */
  update(_event) {
    const obj = _event.currentTarget;
    const { x } = obj.parent.worldTransform.applyInverse(_event.global);
    if (x !== this.startX) {
      this.startX = null;
    }
  }
  /** Called when dragging stopped. */
  change() {
  }
  /**
   * Set max value.
   * @param value
   */
  set max(value) {
    this._max = value;
  }
  /** Get max value. */
  get max() {
    return this._max;
  }
  /**
   * Set min value.
   * @param value
   */
  set min(value) {
    this._min = value;
  }
  /** Get min value. */
  get min() {
    return this._min;
  }
}

exports.SliderBase = SliderBase;
//# sourceMappingURL=SliderBase.js.map
