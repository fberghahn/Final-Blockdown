{"version":3,"file":"ColorBurnBlend.js","sources":["../../src/advanced-blend-modes/ColorBurnBlend.ts"],"sourcesContent":["/* eslint-disable max-len */\n\nimport { ExtensionType } from '../extensions/Extensions';\nimport { BlendModeFilter } from '../filters/blend-modes/BlendModeFilter';\n\nimport type { ExtensionMetadata } from '../extensions/Extensions';\n\n/**\n * Looks at the color information in each channel and darkens the base color to\n * reflect the blend color by increasing the contrast between the two.\n *\n * Available as `container.blendMode = 'color-burn'` after importing `pixi.js/advanced-blend-modes`.\n * @example\n * import 'pixi.js/advanced-blend-modes';\n * import { Sprite } from 'pixi.js';\n *\n * const sprite = Sprite.from('something.png');\n * sprite.blendMode = 'color-burn'\n * @memberof filters\n */\nexport class ColorBurnBlend extends BlendModeFilter\n{\n    /** @ignore */\n    public static extension: ExtensionMetadata = {\n        name: 'color-burn',\n        type: ExtensionType.BlendMode\n    };\n\n    constructor()\n    {\n        super({\n            gl: {\n                functions: `\n                float colorBurn(float base, float blend)\n                {\n                    return max((1.0 - ((1.0 - base) / blend)), 0.0);\n                }\n\n                vec3 blendColorBurn(vec3 base, vec3 blend, float opacity)\n                {\n                    vec3 blended = vec3(\n                        colorBurn(base.r, blend.r),\n                        colorBurn(base.g, blend.g),\n                        colorBurn(base.b, blend.b)\n                    );\n\n                    return (blended * opacity + base * (1.0 - opacity));\n                }\n            `,\n                main: `\n                finalColor = vec4(blendColorBurn(back.rgb, front.rgb, front.a), uBlend);\n            `\n            },\n            gpu: {\n                functions: `\n                fn colorBurn(base:f32, blend:f32) -> f32\n                {\n                    return max((1.0-((1.0-base)/blend)),0.0);\n                }\n\n                fn blendColorBurn(base: vec3<f32>, blend: vec3<f32>, opacity: f32) -> vec3<f32>\n                {\n                    let blended = vec3<f32>(\n                        colorBurn(base.r, blend.r),\n                        colorBurn(base.g, blend.g),\n                        colorBurn(base.b, blend.b)\n                    );\n\n                    return (blended * opacity + base * (1.0 - opacity));\n                }\n            `,\n                main: `\n                out = vec4<f32>(blendColorBurn(back.rgb, front.rgb, front.a), blendUniforms.uBlend);\n            `\n            }\n        });\n    }\n}\n"],"names":["BlendModeFilter","ExtensionType"],"mappings":";;;;;;AAoBO,MAAM,uBAAuBA,+BACpC,CAAA;AAAA,EAOI,WACA,GAAA;AACI,IAAM,KAAA,CAAA;AAAA,MACF,EAAI,EAAA;AAAA,QACA,SAAW,EAAA,CAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,YAAA,CAAA;AAAA,QAiBX,IAAM,EAAA,CAAA;AAAA;AAAA,YAAA,CAAA;AAAA,OAGV;AAAA,MACA,GAAK,EAAA;AAAA,QACD,SAAW,EAAA,CAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,YAAA,CAAA;AAAA,QAiBX,IAAM,EAAA,CAAA;AAAA;AAAA,YAAA,CAAA;AAAA,OAGV;AAAA,KACH,CAAA,CAAA;AAAA,GACL;AACJ,CAAA;AAAA;AAzDa,cAAA,CAGK,SAA+B,GAAA;AAAA,EACzC,IAAM,EAAA,YAAA;AAAA,EACN,MAAMC,wBAAc,CAAA,SAAA;AACxB,CAAA;;;;"}