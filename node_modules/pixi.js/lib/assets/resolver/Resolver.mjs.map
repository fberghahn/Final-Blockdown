{"version":3,"file":"Resolver.mjs","sources":["../../../src/assets/resolver/Resolver.ts"],"sourcesContent":["import { warn } from '../../utils/logging/warn';\nimport { path } from '../../utils/path';\nimport { convertToList } from '../utils/convertToList';\nimport { createStringVariations } from '../utils/createStringVariations';\nimport { isSingleItem } from '../utils/isSingleItem';\n\nimport type {\n    ArrayOr,\n    AssetsBundle,\n    AssetsManifest,\n    AssetSrc,\n    ResolvedAsset,\n    ResolvedSrc,\n    UnresolvedAsset,\n} from '../types';\nimport type { PreferOrder, ResolveURLParser } from './types';\n\n/**\n * Options for how the resolver deals with generating bundle ids\n * @memberof assets\n */\nexport interface BundleIdentifierOptions\n{\n    /** The character that is used to connect the bundleId and the assetId when generating a bundle asset id key */\n    connector?: string;\n    /**\n     * A function that generates a bundle asset id key from a bundleId and an assetId\n     * @param bundleId - the bundleId\n     * @param assetId  - the assetId\n     * @returns the bundle asset id key\n     */\n    createBundleAssetId?: (bundleId: string, assetId: string) => string;\n    /**\n     * A function that generates an assetId from a bundle asset id key. This is the reverse of generateBundleAssetId\n     * @param bundleId - the bundleId\n     * @param assetBundleId - the bundle asset id key\n     * @returns the assetId\n     */\n    extractAssetIdFromBundle?: (bundleId: string, assetBundleId: string) => string;\n}\n\n/**\n * A class that is responsible for resolving mapping asset URLs to keys.\n * At its most basic it can be used for Aliases:\n *\n * ```js\n * resolver.add('foo', 'bar');\n * resolver.resolveUrl('foo') // => 'bar'\n * ```\n *\n * It can also be used to resolve the most appropriate asset for a given URL:\n *\n * ```js\n * resolver.prefer({\n *     params: {\n *         format: 'webp',\n *         resolution: 2,\n *     }\n * });\n *\n * resolver.add('foo', ['bar@2x.webp', 'bar@2x.png', 'bar.webp', 'bar.png']);\n *\n * resolver.resolveUrl('foo') // => 'bar@2x.webp'\n * ```\n * Other features include:\n * - Ability to process a manifest file to get the correct understanding of how to resolve all assets\n * - Ability to add custom parsers for specific file types\n * - Ability to add custom prefer rules\n *\n * This class only cares about the URL, not the loading of the asset itself.\n *\n * It is not intended that this class is created by developers - its part of the Asset class\n * This is the third major system of PixiJS' main Assets class\n * @memberof assets\n */\nexport class Resolver\n{\n    /**\n     * The prefix that denotes a URL is for a retina asset.\n     * @static\n     * @name RETINA_PREFIX\n     * @type {RegExp}\n     * @default /@([0-9\\.]+)x/\n     * @example `@2x`\n     */\n    public static RETINA_PREFIX = /@([0-9\\.]+)x/;\n\n    private readonly _defaultBundleIdentifierOptions: Required<BundleIdentifierOptions> = {\n        connector: '-',\n        createBundleAssetId: (bundleId, assetId) =>\n            `${bundleId}${this._bundleIdConnector}${assetId}`,\n        extractAssetIdFromBundle: (bundleId, assetBundleId) =>\n            assetBundleId.replace(`${bundleId}${this._bundleIdConnector}`, ''),\n    };\n\n    /** The character that is used to connect the bundleId and the assetId when generating a bundle asset id key */\n    private _bundleIdConnector = this._defaultBundleIdentifierOptions.connector;\n\n    /**\n     * A function that generates a bundle asset id key from a bundleId and an assetId\n     * @param bundleId - the bundleId\n     * @param assetId  - the assetId\n     * @returns the bundle asset id key\n     */\n    private _createBundleAssetId: (\n        bundleId: string,\n        assetId: string\n    ) => string = this._defaultBundleIdentifierOptions.createBundleAssetId;\n\n    /**\n     * A function that generates an assetId from a bundle asset id key. This is the reverse of generateBundleAssetId\n     * @param bundleId - the bundleId\n     * @param assetBundleId - the bundle asset id key\n     * @returns the assetId\n     */\n    private _extractAssetIdFromBundle: (\n        bundleId: string,\n        assetBundleId: string\n    ) => string = this._defaultBundleIdentifierOptions.extractAssetIdFromBundle;\n\n    private _assetMap: Record<string, ResolvedAsset[]> = {};\n    private _preferredOrder: PreferOrder[] = [];\n    private readonly _parsers: ResolveURLParser[] = [];\n\n    private _resolverHash: Record<string, ResolvedAsset> = {};\n    private _rootPath: string;\n    private _basePath: string;\n    private _manifest: AssetsManifest;\n    private _bundles: Record<string, string[]> = {};\n    private _defaultSearchParams: string;\n\n    /**\n     * Override how the resolver deals with generating bundle ids.\n     * must be called before any bundles are added\n     * @param bundleIdentifier - the bundle identifier options\n     */\n    public setBundleIdentifier(bundleIdentifier: BundleIdentifierOptions): void\n    {\n        this._bundleIdConnector = bundleIdentifier.connector ?? this._bundleIdConnector;\n        this._createBundleAssetId = bundleIdentifier.createBundleAssetId ?? this._createBundleAssetId;\n        this._extractAssetIdFromBundle = bundleIdentifier.extractAssetIdFromBundle ?? this._extractAssetIdFromBundle;\n\n        if (this._extractAssetIdFromBundle('foo', this._createBundleAssetId('foo', 'bar')) !== 'bar')\n        {\n            throw new Error('[Resolver] GenerateBundleAssetId are not working correctly');\n        }\n    }\n\n    /**\n     * Let the resolver know which assets you prefer to use when resolving assets.\n     * Multiple prefer user defined rules can be added.\n     * @example\n     * resolver.prefer({\n     *     // first look for something with the correct format, and then then correct resolution\n     *     priority: ['format', 'resolution'],\n     *     params:{\n     *         format:'webp', // prefer webp images\n     *         resolution: 2, // prefer a resolution of 2\n     *     }\n     * })\n     * resolver.add('foo', ['bar@2x.webp', 'bar@2x.png', 'bar.webp', 'bar.png']);\n     * resolver.resolveUrl('foo') // => 'bar@2x.webp'\n     * @param preferOrders - the prefer options\n     */\n    public prefer(...preferOrders: PreferOrder[]): void\n    {\n        preferOrders.forEach((prefer) =>\n        {\n            this._preferredOrder.push(prefer);\n\n            if (!prefer.priority)\n            {\n                // generate the priority based on the order of the object\n                prefer.priority = Object.keys(prefer.params);\n            }\n        });\n\n        this._resolverHash = {};\n    }\n\n    /**\n     * Set the base path to prepend to all urls when resolving\n     * @example\n     * resolver.basePath = 'https://home.com/';\n     * resolver.add('foo', 'bar.ong');\n     * resolver.resolveUrl('foo', 'bar.png'); // => 'https://home.com/bar.png'\n     * @param basePath - the base path to use\n     */\n    public set basePath(basePath: string)\n    {\n        this._basePath = basePath;\n    }\n\n    public get basePath(): string\n    {\n        return this._basePath;\n    }\n\n    /**\n     * Set the root path for root-relative URLs. By default the `basePath`'s root is used. If no `basePath` is set, then the\n     * default value for browsers is `window.location.origin`\n     * @example\n     * // Application hosted on https://home.com/some-path/index.html\n     * resolver.basePath = 'https://home.com/some-path/';\n     * resolver.rootPath = 'https://home.com/';\n     * resolver.add('foo', '/bar.png');\n     * resolver.resolveUrl('foo', '/bar.png'); // => 'https://home.com/bar.png'\n     * @param rootPath - the root path to use\n     */\n    public set rootPath(rootPath: string)\n    {\n        this._rootPath = rootPath;\n    }\n\n    public get rootPath(): string\n    {\n        return this._rootPath;\n    }\n\n    /**\n     * All the active URL parsers that help the parser to extract information and create\n     * an asset object-based on parsing the URL itself.\n     *\n     * Can be added using the extensions API\n     * @example\n     * resolver.add('foo', [\n     *     {\n     *         resolution: 2,\n     *         format: 'png',\n     *         src: 'image@2x.png',\n     *     },\n     *     {\n     *         resolution:1,\n     *         format:'png',\n     *         src: 'image.png',\n     *     },\n     * ]);\n     *\n     * // With a url parser the information such as resolution and file format could extracted from the url itself:\n     * extensions.add({\n     *     extension: ExtensionType.ResolveParser,\n     *     test: loadTextures.test, // test if url ends in an image\n     *     parse: (value: string) =>\n     *     ({\n     *         resolution: parseFloat(Resolver.RETINA_PREFIX.exec(value)?.[1] ?? '1'),\n     *         format: value.split('.').pop(),\n     *         src: value,\n     *     }),\n     * });\n     *\n     * // Now resolution and format can be extracted from the url\n     * resolver.add('foo', [\n     *     'image@2x.png',\n     *     'image.png',\n     * ]);\n     */\n    public get parsers(): ResolveURLParser[]\n    {\n        return this._parsers;\n    }\n\n    /** Used for testing, this resets the resolver to its initial state */\n    public reset(): void\n    {\n        this.setBundleIdentifier(this._defaultBundleIdentifierOptions);\n\n        this._assetMap = {};\n        this._preferredOrder = [];\n        // Do not reset this._parsers\n\n        this._resolverHash = {};\n        this._rootPath = null;\n        this._basePath = null;\n        this._manifest = null;\n        this._bundles = {};\n        this._defaultSearchParams = null;\n    }\n\n    /**\n     * Sets the default URL search parameters for the URL resolver. The urls can be specified as a string or an object.\n     * @param searchParams - the default url parameters to append when resolving urls\n     */\n    public setDefaultSearchParams(searchParams: string | Record<string, unknown>): void\n    {\n        if (typeof searchParams === 'string')\n        {\n            this._defaultSearchParams = searchParams;\n        }\n        else\n        {\n            const queryValues = searchParams as Record<string, any>;\n\n            this._defaultSearchParams = Object.keys(queryValues)\n                .map((key) => `${encodeURIComponent(key)}=${encodeURIComponent(queryValues[key])}`)\n                .join('&');\n        }\n    }\n\n    /**\n     * Returns the aliases for a given asset\n     * @param asset - the asset to get the aliases for\n     */\n    public getAlias(asset: UnresolvedAsset): string[]\n    {\n        const { alias, src } = asset;\n        const aliasesToUse = convertToList<ArrayOr<string | AssetSrc>>(\n            alias || src, (value: string | AssetSrc) =>\n            {\n                if (typeof value === 'string') return value;\n\n                if (Array.isArray(value)) return value.map((v) => (v as ResolvedSrc)?.src ?? v);\n\n                if (value?.src) return value.src;\n\n                return value;\n            }, true) as string[];\n\n        return aliasesToUse;\n    }\n\n    /**\n     * Add a manifest to the asset resolver. This is a nice way to add all the asset information in one go.\n     * generally a manifest would be built using a tool.\n     * @param manifest - the manifest to add to the resolver\n     */\n    public addManifest(manifest: AssetsManifest): void\n    {\n        if (this._manifest)\n        {\n            // #if _DEBUG\n            warn('[Resolver] Manifest already exists, this will be overwritten');\n            // #endif\n        }\n\n        this._manifest = manifest;\n\n        manifest.bundles.forEach((bundle) =>\n        {\n            this.addBundle(bundle.name, bundle.assets);\n        });\n    }\n\n    /**\n     * This adds a bundle of assets in one go so that you can resolve them as a group.\n     * For example you could add a bundle for each screen in you pixi app\n     * @example\n     * resolver.addBundle('animals', [\n     *  { alias: 'bunny', src: 'bunny.png' },\n     *  { alias: 'chicken', src: 'chicken.png' },\n     *  { alias: 'thumper', src: 'thumper.png' },\n     * ]);\n     * // or\n     * resolver.addBundle('animals', {\n     *     bunny: 'bunny.png',\n     *     chicken: 'chicken.png',\n     *     thumper: 'thumper.png',\n     * });\n     *\n     * const resolvedAssets = await resolver.resolveBundle('animals');\n     * @param bundleId - The id of the bundle to add\n     * @param assets - A record of the asset or assets that will be chosen from when loading via the specified key\n     */\n    public addBundle(bundleId: string, assets: AssetsBundle['assets']): void\n    {\n        const assetNames: string[] = [];\n        let convertedAssets: UnresolvedAsset[] = assets as UnresolvedAsset[];\n\n        if (!Array.isArray(assets))\n        {\n            // convert to array...\n            convertedAssets = Object.entries(assets).map(([alias, src]) =>\n            {\n                if (typeof src === 'string' || Array.isArray(src))\n                {\n                    return { alias, src };\n                }\n\n                return { alias, ...src };\n            });\n        }\n\n        // when storing keys against a bundle we prepend the bundleId to each asset key\n        // and pass it through as an additional alias for the asset\n        // this keeps clashing ids separate on a per-bundle basis\n        // you can also resolve a file using the bundleId-assetId syntax\n\n        convertedAssets.forEach((asset) =>\n        {\n            const srcs = asset.src;\n            const aliases = asset.alias;\n            let ids: string[];\n\n            if (typeof aliases === 'string')\n            {\n                const bundleAssetId = this._createBundleAssetId(bundleId, aliases);\n\n                assetNames.push(bundleAssetId);\n                ids = [aliases, bundleAssetId];\n            }\n            else\n            {\n                const bundleIds = aliases.map((name) => this._createBundleAssetId(bundleId, name));\n\n                assetNames.push(...bundleIds);\n                ids = [...aliases, ...bundleIds];\n            }\n\n            this.add({\n                ...asset,\n                ...{\n                    alias: ids,\n                    src: srcs,\n                }\n            });\n        });\n\n        this._bundles[bundleId] = assetNames;\n    }\n\n    /**\n     * Tells the resolver what keys are associated with witch asset.\n     * The most important thing the resolver does\n     * @example\n     * // Single key, single asset:\n     * resolver.add({alias: 'foo', src: 'bar.png');\n     * resolver.resolveUrl('foo') // => 'bar.png'\n     *\n     * // Multiple keys, single asset:\n     * resolver.add({alias: ['foo', 'boo'], src: 'bar.png'});\n     * resolver.resolveUrl('foo') // => 'bar.png'\n     * resolver.resolveUrl('boo') // => 'bar.png'\n     *\n     * // Multiple keys, multiple assets:\n     * resolver.add({alias: ['foo', 'boo'], src: ['bar.png', 'bar.webp']});\n     * resolver.resolveUrl('foo') // => 'bar.png'\n     *\n     * // Add custom data attached to the resolver\n     * Resolver.add({\n     *     alias: 'bunnyBooBooSmooth',\n     *     src: 'bunny{png,webp}',\n     *     data: { scaleMode:SCALE_MODES.NEAREST }, // Base texture options\n     * });\n     *\n     * resolver.resolve('bunnyBooBooSmooth') // => { src: 'bunny.png', data: { scaleMode: SCALE_MODES.NEAREST } }\n     * @param aliases - the UnresolvedAsset or array of UnresolvedAssets to add to the resolver\n     */\n    public add(\n        aliases: ArrayOr<UnresolvedAsset>,\n    ): void\n    {\n        const assets: UnresolvedAsset[] = [];\n\n        if (Array.isArray(aliases))\n        {\n            assets.push(...(aliases as UnresolvedAsset[]));\n        }\n        else\n        {\n            assets.push(aliases as UnresolvedAsset);\n        }\n\n        let keyCheck: (key: string) => void;\n\n        // #if _DEBUG\n        // eslint-disable-next-line prefer-const\n        keyCheck = (key: string) =>\n        {\n            if (this.hasKey(key))\n            {\n                // #if _DEBUG\n                warn(`[Resolver] already has key: ${key} overwriting`);\n                // #endif\n            }\n        };\n        // #endif\n\n        const assetArray = convertToList(assets);\n\n        // loop through all the assets and generate a resolve asset for each src\n        assetArray.forEach((asset) =>\n        {\n            const { src } = asset;\n            let { data, format, loadParser } = asset;\n\n            // src can contain an unresolved asset itself\n            // so we need to merge that data with the current asset\n            // we dont need to create string variations for the src if it is a ResolvedAsset\n            const srcsToUse: (string | ResolvedSrc)[][] = convertToList<AssetSrc>(src).map((src) =>\n            {\n                if (typeof src === 'string')\n                { return createStringVariations(src); }\n\n                return Array.isArray(src) ? src : [src];\n            });\n\n            const aliasesToUse = this.getAlias(asset);\n\n            // #if _DEBUG\n            Array.isArray(aliasesToUse) ? aliasesToUse.forEach(keyCheck) : keyCheck(aliasesToUse);\n            // #endif\n\n            // loop through all the srcs and generate a resolve asset for each src\n            const resolvedAssets: ResolvedAsset[] = [];\n\n            srcsToUse.forEach((srcs) =>\n            {\n                srcs.forEach((src) =>\n                {\n                    let formattedAsset = {} as ResolvedAsset;\n\n                    if (typeof src !== 'object')\n                    {\n                        formattedAsset.src = src;\n                        // first see if it contains any {} tags...\n                        for (let i = 0; i < this._parsers.length; i++)\n                        {\n                            const parser = this._parsers[i];\n\n                            if (parser.test(src))\n                            {\n                                formattedAsset = parser.parse(src);\n                                break;\n                            }\n                        }\n                    }\n                    else\n                    {\n                        data = src.data ?? data;\n                        format = src.format ?? format;\n                        loadParser = src.loadParser ?? loadParser;\n                        formattedAsset = {\n                            ...formattedAsset,\n                            ...src,\n                        };\n                    }\n\n                    // check if aliases is undefined\n                    if (!aliasesToUse)\n                    {\n                        throw new Error(`[Resolver] alias is undefined for this asset: ${formattedAsset.src}`);\n                    }\n\n                    formattedAsset = this._buildResolvedAsset(formattedAsset, {\n                        aliases: aliasesToUse,\n                        data,\n                        format,\n                        loadParser,\n                    });\n\n                    resolvedAssets.push(formattedAsset);\n                });\n            });\n\n            aliasesToUse.forEach((alias) =>\n            {\n                this._assetMap[alias] = resolvedAssets;\n            });\n        });\n    }\n\n    // TODO: this needs an overload like load did in Assets\n    /**\n     * If the resolver has had a manifest set via setManifest, this will return the assets urls for\n     * a given bundleId or bundleIds.\n     * @example\n     * // Manifest Example\n     * const manifest = {\n     *     bundles: [\n     *         {\n     *             name: 'load-screen',\n     *             assets: [\n     *                 {\n     *                     alias: 'background',\n     *                     src: 'sunset.png',\n     *                 },\n     *                 {\n     *                     alias: 'bar',\n     *                     src: 'load-bar.{png,webp}',\n     *                 },\n     *             ],\n     *         },\n     *         {\n     *             name: 'game-screen',\n     *             assets: [\n     *                 {\n     *                     alias: 'character',\n     *                     src: 'robot.png',\n     *                 },\n     *                 {\n     *                     alias: 'enemy',\n     *                     src: 'bad-guy.png',\n     *                 },\n     *             ],\n     *         },\n     *     ]\n     * };\n     *\n     * resolver.setManifest(manifest);\n     * const resolved = resolver.resolveBundle('load-screen');\n     * @param bundleIds - The bundle ids to resolve\n     * @returns All the bundles assets or a hash of assets for each bundle specified\n     */\n    public resolveBundle(bundleIds: ArrayOr<string>):\n    Record<string, ResolvedAsset> | Record<string, Record<string, ResolvedAsset>>\n    {\n        const singleAsset = isSingleItem(bundleIds);\n\n        bundleIds = convertToList<string>(bundleIds);\n\n        const out: Record<string, Record<string, ResolvedAsset>> = {};\n\n        bundleIds.forEach((bundleId) =>\n        {\n            const assetNames = this._bundles[bundleId];\n\n            if (assetNames)\n            {\n                const results = this.resolve(assetNames) as Record<string, ResolvedAsset>;\n\n                const assets: Record<string, ResolvedAsset> = {};\n\n                for (const key in results)\n                {\n                    const asset = results[key];\n\n                    assets[this._extractAssetIdFromBundle(bundleId, key)] = asset;\n                }\n\n                out[bundleId] = assets;\n            }\n        });\n\n        return singleAsset ? out[bundleIds[0]] : out;\n    }\n\n    /**\n     * Does exactly what resolve does, but returns just the URL rather than the whole asset object\n     * @param key - The key or keys to resolve\n     * @returns - The URLs associated with the key(s)\n     */\n    public resolveUrl(key: ArrayOr<string>): string | Record<string, string>\n    {\n        const result = this.resolve(key as string) as ResolvedAsset | Record<string, ResolvedAsset>;\n\n        if (typeof key !== 'string')\n        {\n            const out: Record<string, string> = {};\n\n            for (const i in result)\n            {\n                out[i] = (result as Record<string, ResolvedAsset>)[i].src;\n            }\n\n            return out;\n        }\n\n        return (result as ResolvedAsset).src;\n    }\n\n    /**\n     * Resolves each key in the list to an asset object.\n     * Another key function of the resolver! After adding all the various key/asset pairs. this will run the logic\n     * of finding which asset to return based on any preferences set using the `prefer` function\n     * by default the same key passed in will be returned if nothing is matched by the resolver.\n     * @example\n     * resolver.add('boo', 'bunny.png');\n     *\n     * resolver.resolve('boo') // => { src: 'bunny.png' }\n     *\n     * // Will return the same string as no key was added for this value..\n     * resolver.resolve('another-thing.png') // => { src: 'another-thing.png' }\n     * @param keys - key or keys to resolve\n     * @returns - the resolve asset or a hash of resolve assets for each key specified\n     */\n    public resolve(keys: string): ResolvedAsset;\n    public resolve(keys: string[]): Record<string, ResolvedAsset>;\n    public resolve(keys: ArrayOr<string>): ResolvedAsset | Record<string, ResolvedAsset>\n    {\n        const singleAsset = isSingleItem(keys);\n\n        keys = convertToList<string>(keys);\n\n        const result: Record<string, ResolvedAsset> = {};\n\n        keys.forEach((key) =>\n        {\n            if (!this._resolverHash[key])\n            {\n                if (this._assetMap[key])\n                {\n                    let assets = this._assetMap[key];\n                    const preferredOrder = this._getPreferredOrder(assets);\n\n                    preferredOrder?.priority.forEach((priorityKey) =>\n                    {\n                        preferredOrder.params[priorityKey].forEach((value: unknown) =>\n                        {\n                            const filteredAssets = assets.filter((asset) =>\n                            {\n                                if (asset[priorityKey as keyof ResolvedAsset])\n                                {\n                                    return asset[priorityKey as keyof ResolvedAsset] === value;\n                                }\n\n                                return false;\n                            });\n\n                            if (filteredAssets.length)\n                            {\n                                assets = filteredAssets;\n                            }\n                        });\n                    });\n\n                    this._resolverHash[key] = assets[0];\n                }\n                else\n                {\n                    this._resolverHash[key] = this._buildResolvedAsset({\n                        alias: [key],\n                        src: key,\n                    }, {});\n                }\n            }\n\n            result[key] = this._resolverHash[key];\n        });\n\n        return singleAsset ? result[keys[0]] : result;\n    }\n\n    /**\n     * Checks if an asset with a given key exists in the resolver\n     * @param key - The key of the asset\n     */\n    public hasKey(key: string): boolean\n    {\n        return !!this._assetMap[key];\n    }\n\n    /**\n     * Checks if a bundle with the given key exists in the resolver\n     * @param key - The key of the bundle\n     */\n    public hasBundle(key: string): boolean\n    {\n        return !!this._bundles[key];\n    }\n\n    /**\n     * Internal function for figuring out what prefer criteria an asset should use.\n     * @param assets\n     */\n    private _getPreferredOrder(assets: ResolvedAsset[]): PreferOrder\n    {\n        for (let i = 0; i < assets.length; i++)\n        {\n            const asset = assets[0];\n\n            const preferred = this._preferredOrder.find((preference: PreferOrder) =>\n                preference.params.format.includes(asset.format));\n\n            if (preferred)\n            {\n                return preferred;\n            }\n        }\n\n        return this._preferredOrder[0];\n    }\n\n    /**\n     * Appends the default url parameters to the url\n     * @param url - The url to append the default parameters to\n     * @returns - The url with the default parameters appended\n     */\n    private _appendDefaultSearchParams(url: string): string\n    {\n        if (!this._defaultSearchParams) return url;\n\n        const paramConnector = (/\\?/).test(url) ? '&' : '?';\n\n        return `${url}${paramConnector}${this._defaultSearchParams}`;\n    }\n\n    private _buildResolvedAsset(formattedAsset: ResolvedAsset, data?: {\n        aliases?: string[],\n        data?: Record<string, unknown>\n        loadParser?: string,\n        format?: string,\n    }): ResolvedAsset\n    {\n        const { aliases, data: assetData, loadParser, format } = data;\n\n        if (this._basePath || this._rootPath)\n        {\n            formattedAsset.src = path.toAbsolute(formattedAsset.src, this._basePath, this._rootPath);\n        }\n\n        formattedAsset.alias = aliases ?? formattedAsset.alias ?? [formattedAsset.src];\n        formattedAsset.src = this._appendDefaultSearchParams(formattedAsset.src);\n        formattedAsset.data = { ...assetData || {}, ...formattedAsset.data };\n        formattedAsset.loadParser = loadParser ?? formattedAsset.loadParser;\n        formattedAsset.format = format ?? formattedAsset.format ?? getUrlExtension(formattedAsset.src);\n\n        return formattedAsset;\n    }\n}\n\nexport function getUrlExtension(url: string)\n{\n    return url.split('.').pop().split('?').shift()\n        .split('#')\n        .shift();\n}\n"],"names":["src"],"mappings":"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"}