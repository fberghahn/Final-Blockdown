{"version":3,"file":"parseDDS.mjs","sources":["../../../src/compressed-textures/dds/parseDDS.ts"],"sourcesContent":["import { DDS, DXGI_TO_TEXTURE_FORMAT, FOURCC_TO_TEXTURE_FORMAT, TEXTURE_FORMAT_BLOCK_SIZE } from './const';\n\nimport type { TEXTURE_FORMATS } from '../../rendering/renderers/shared/texture/const';\nimport type { TextureSourceOptions } from '../../rendering/renderers/shared/texture/sources/TextureSource';\n\nexport function parseDDS(arrayBuffer: ArrayBuffer, supportedFormats: TEXTURE_FORMATS[]): TextureSourceOptions<Uint8Array[]>\n{\n    const {\n        format,\n        fourCC,\n        width,\n        height,\n        dataOffset,\n        mipmapCount,\n    } = parseDDSHeader(arrayBuffer);\n\n    if (!supportedFormats.includes(format))\n    {\n        throw new Error(`Unsupported texture format: ${fourCC} ${format}, supported: ${supportedFormats}`);\n    }\n\n    if (mipmapCount <= 1)\n    { // No need bothering with the imageSize calculation!\n        return {\n            format,\n            width,\n            height,\n            resource: [new Uint8Array(arrayBuffer, dataOffset)],\n            alphaMode: 'no-premultiply-alpha',\n        } as TextureSourceOptions;\n    }\n\n    const levelBuffers = getMipmapLevelBuffers(format, width, height, dataOffset, mipmapCount, arrayBuffer);\n\n    const textureOptions: TextureSourceOptions = {\n        format,\n        width,\n        height,\n        resource: levelBuffers,\n        alphaMode: 'no-premultiply-alpha'\n    };\n\n    return textureOptions;\n}\n\nfunction getMipmapLevelBuffers(format: TEXTURE_FORMATS, width: number, height: number,\n    dataOffset: any, mipmapCount: number, arrayBuffer: ArrayBuffer)\n{\n    const levelBuffers = [];\n    const blockBytes = TEXTURE_FORMAT_BLOCK_SIZE[format];\n\n    let mipWidth = width;\n    let mipHeight = height;\n    let offset = dataOffset;\n\n    for (let level = 0; level < mipmapCount; ++level)\n    {\n        const byteLength = blockBytes\n            ? Math.max(4, mipWidth) / 4 * Math.max(4, mipHeight) / 4 * blockBytes\n            : mipWidth * mipHeight * 4;\n\n        const levelBuffer = new Uint8Array(arrayBuffer, offset, byteLength);\n\n        levelBuffers.push(levelBuffer);\n\n        offset += byteLength;\n\n        mipWidth = Math.max(mipWidth >> 1, 1);\n        mipHeight = Math.max(mipHeight >> 1, 1);\n    }\n\n    return levelBuffers;\n}\n\nfunction parseDDSHeader(buffer: ArrayBuffer)\n{\n    const header = new Uint32Array(buffer, 0, DDS.HEADER_SIZE / Uint32Array.BYTES_PER_ELEMENT);\n\n    if (header[DDS.HEADER_FIELDS.MAGIC] !== DDS.MAGIC_VALUE)\n    {\n        throw new Error('Invalid magic number in DDS header');\n    }\n\n    // DDS header fields\n    const height = header[DDS.HEADER_FIELDS.HEIGHT];\n    const width = header[DDS.HEADER_FIELDS.WIDTH];\n    const mipmapCount = Math.max(1, header[DDS.HEADER_FIELDS.MIPMAP_COUNT]);\n    const flags = header[DDS.HEADER_FIELDS.PF_FLAGS];\n    const fourCC = header[DDS.HEADER_FIELDS.FOURCC];\n    const format = getTextureFormat(header, flags, fourCC, buffer);\n\n    const dataOffset = DDS.MAGIC_SIZE + DDS.HEADER_SIZE\n        + ((fourCC === DDS.D3DFMT.DX10) ? DDS.HEADER_DX10_SIZE : 0);\n\n    return {\n        format,\n        fourCC,\n        width,\n        height,\n        dataOffset,\n        mipmapCount\n    };\n}\n\nfunction getTextureFormat(header: Uint32Array, flags: number, fourCC: number, buffer: ArrayBuffer)\n{\n    if (flags & DDS.PIXEL_FORMAT_FLAGS.FOURCC)\n    {\n        if (fourCC === DDS.D3DFMT.DX10)\n        {\n            const dx10Header = new Uint32Array(\n                buffer,\n                DDS.MAGIC_SIZE + DDS.HEADER_SIZE, // there is a 20-byte DDS_HEADER_DX10 after DDS_HEADER\n                DDS.HEADER_DX10_SIZE / Uint32Array.BYTES_PER_ELEMENT);\n\n            const miscFlag = dx10Header[DDS.HEADER_DX10_FIELDS.MISC_FLAG];\n\n            if (miscFlag === DDS.RESOURCE_MISC_TEXTURECUBE)\n            {\n                throw new Error('DDSParser does not support cubemap textures');\n            }\n\n            const resourceDimension = dx10Header[DDS.HEADER_DX10_FIELDS.RESOURCE_DIMENSION];\n\n            if (resourceDimension === DDS.D3D10_RESOURCE_DIMENSION.DDS_DIMENSION_TEXTURE3D)\n            {\n                throw new Error('DDSParser does not supported 3D texture data');\n            }\n\n            const dxgiFormat = dx10Header[DDS.HEADER_DX10_FIELDS.DXGI_FORMAT];\n\n            if (dxgiFormat in DXGI_TO_TEXTURE_FORMAT)\n            {\n                return DXGI_TO_TEXTURE_FORMAT[dxgiFormat];\n            }\n\n            throw new Error(`DDSParser cannot parse texture data with DXGI format ${dxgiFormat}`);\n        }\n\n        if (fourCC in FOURCC_TO_TEXTURE_FORMAT)\n        {\n            return FOURCC_TO_TEXTURE_FORMAT[fourCC];\n        }\n\n        throw new Error(`DDSParser cannot parse texture data with fourCC format ${fourCC}`);\n    }\n\n    if (flags & DDS.PIXEL_FORMAT_FLAGS.RGB || flags & DDS.PIXEL_FORMAT_FLAGS.RGBA)\n    {\n        return getUncompressedTextureFormat(header);\n    }\n\n    if (flags & DDS.PIXEL_FORMAT_FLAGS.YUV)\n    {\n        throw new Error('DDSParser does not supported YUV uncompressed texture data.');\n    }\n    if (flags & DDS.PIXEL_FORMAT_FLAGS.LUMINANCE || flags & DDS.PIXEL_FORMAT_FLAGS.LUMINANCEA)\n    {\n        throw new Error('DDSParser does not support single-channel (lumninance) texture data!');\n    }\n    if (flags & DDS.PIXEL_FORMAT_FLAGS.ALPHA || flags & DDS.PIXEL_FORMAT_FLAGS.ALPHAPIXELS)\n    {\n        throw new Error('DDSParser does not support single-channel (alpha) texture data!');\n    }\n\n    throw new Error('DDSParser failed to load a texture file due to an unknown reason!');\n}\n\nfunction getUncompressedTextureFormat(header: Uint32Array)\n{\n    const bitCount = header[DDS.HEADER_FIELDS.RGB_BITCOUNT];\n    const rBitMask = header[DDS.HEADER_FIELDS.R_BIT_MASK];\n    const gBitMask = header[DDS.HEADER_FIELDS.G_BIT_MASK];\n    const bBitMask = header[DDS.HEADER_FIELDS.B_BIT_MASK];\n    const aBitMask = header[DDS.HEADER_FIELDS.A_BIT_MASK];\n\n    // https://learn.microsoft.com/en-us/windows/win32/direct3ddds/dx-graphics-dds-pguide\n    // https://github.com/microsoft/DirectXTex/blob/main/DDSTextureLoader/DDSTextureLoader11.cpp#L892\n    switch (bitCount)\n    {\n        case 32:\n            if (rBitMask === 0x000000ff && gBitMask === 0x0000ff00 && bBitMask === 0x00ff0000 && aBitMask === 0xff000000)\n            {\n                return DXGI_TO_TEXTURE_FORMAT[DDS.DXGI_FORMAT.DXGI_FORMAT_R8G8B8A8_UNORM];\n            }\n            if (rBitMask === 0x00ff0000 && gBitMask === 0x0000ff00 && bBitMask === 0x000000ff && aBitMask === 0xff000000)\n            {\n                return DXGI_TO_TEXTURE_FORMAT[DDS.DXGI_FORMAT.DXGI_FORMAT_B8G8R8A8_UNORM];\n            }\n            if (rBitMask === 0x3ff00000 && gBitMask === 0x000ffc00 && bBitMask === 0x000003ff && aBitMask === 0xc0000000)\n            {\n                return DXGI_TO_TEXTURE_FORMAT[DDS.DXGI_FORMAT.DXGI_FORMAT_R10G10B10A2_UNORM];\n            }\n            if (rBitMask === 0x0000ffff && gBitMask === 0xffff0000 && bBitMask === 0 && aBitMask === 0)\n            {\n                return DXGI_TO_TEXTURE_FORMAT[DDS.DXGI_FORMAT.DXGI_FORMAT_R16G16_UNORM];\n            }\n            if (rBitMask === 0xffffffff && gBitMask === 0 && bBitMask === 0 && aBitMask === 0)\n            {\n                return DXGI_TO_TEXTURE_FORMAT[DDS.DXGI_FORMAT.DXGI_FORMAT_R32_FLOAT];\n            }\n            break;\n        case 24:\n            if (rBitMask === 0xff0000 && gBitMask === 0xff00 && bBitMask === 0xff && aBitMask === 0x8000)\n            {\n                // rgb8unorm not supported?\n                // return DXGI_TO_TEXTURE_FORMAT[DDS.DXGI_FORMAT.DXGI_FORMAT_B5G5R5A1_UNORM];\n            }\n            break;\n        case 16:\n            if (rBitMask === 0x7c00 && gBitMask === 0x03e0 && bBitMask === 0x001f && aBitMask === 0x8000)\n            {\n                return DXGI_TO_TEXTURE_FORMAT[DDS.DXGI_FORMAT.DXGI_FORMAT_B5G5R5A1_UNORM];\n            }\n            if (rBitMask === 0xf800 && gBitMask === 0x07e0 && bBitMask === 0x001f && aBitMask === 0)\n            {\n                return DXGI_TO_TEXTURE_FORMAT[DDS.DXGI_FORMAT.DXGI_FORMAT_B5G6R5_UNORM];\n            }\n            if (rBitMask === 0x0f00 && gBitMask === 0x00f0 && bBitMask === 0x000f && aBitMask === 0xf000)\n            {\n                return DXGI_TO_TEXTURE_FORMAT[DDS.DXGI_FORMAT.DXGI_FORMAT_B4G4R4A4_UNORM];\n            }\n            if (rBitMask === 0x00ff && gBitMask === 0 && bBitMask === 0 && aBitMask === 0xff00)\n            {\n                return DXGI_TO_TEXTURE_FORMAT[DDS.DXGI_FORMAT.DXGI_FORMAT_R8G8_UNORM];\n            }\n            if (rBitMask === 0xffff && gBitMask === 0 && bBitMask === 0 && aBitMask === 0)\n            {\n                return DXGI_TO_TEXTURE_FORMAT[DDS.DXGI_FORMAT.DXGI_FORMAT_R16_UNORM];\n            }\n            break;\n\n        case 8:\n            if (rBitMask === 0xff && gBitMask === 0 && bBitMask === 0 && aBitMask === 0)\n            {\n                return DXGI_TO_TEXTURE_FORMAT[DDS.DXGI_FORMAT.DXGI_FORMAT_R8_UNORM];\n            }\n            break;\n    }\n\n    throw new Error(`DDSParser does not support uncompressed texture with configuration:\n                bitCount = ${bitCount}, rBitMask = ${rBitMask}, gBitMask = ${gBitMask}, aBitMask = ${aBitMask}`);\n}\n"],"names":[],"mappings":"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"}