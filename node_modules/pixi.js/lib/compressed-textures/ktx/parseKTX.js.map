{"version":3,"file":"parseKTX.js","sources":["../../../src/compressed-textures/ktx/parseKTX.ts"],"sourcesContent":["import { KTX } from '../ktx2/const';\n\nimport type { TEXTURE_FORMATS } from '../../rendering/renderers/shared/texture/const';\nimport type { TextureSourceOptions } from '../../rendering/renderers/shared/texture/sources/TextureSource';\n\nexport function parseKTX(arrayBuffer: ArrayBuffer, supportedFormats: TEXTURE_FORMATS[]): TextureSourceOptions<Uint8Array[]>\n{\n    const dataView = new DataView(arrayBuffer);\n\n    if (!validate(dataView))\n    {\n        throw new Error('Invalid KTX identifier in header');\n    }\n\n    const {\n        littleEndian,\n        glType,\n        glFormat,\n        glInternalFormat,\n        pixelWidth,\n        pixelHeight,\n        numberOfMipmapLevels,\n        offset,\n    } = parseKTXHeader(dataView);\n\n    const textureFormat = KTX.INTERNAL_FORMAT_TO_TEXTURE_FORMATS[glInternalFormat];\n\n    if (!textureFormat)\n    {\n        throw new Error(`Unknown texture format ${glInternalFormat}`);\n    }\n    if (!supportedFormats.includes(textureFormat))\n    {\n        throw new Error(`Unsupported texture format: ${textureFormat}, supportedFormats: ${supportedFormats}`);\n    }\n\n    const imagePixelByteSize = getImagePixelByteSize(glType, glFormat, glInternalFormat);\n\n    const imageBuffers = getImageBuffers(dataView, glType, imagePixelByteSize, pixelWidth, pixelHeight, offset,\n        numberOfMipmapLevels, littleEndian);\n\n    return {\n        format: textureFormat,\n        width: pixelWidth,\n        height: pixelHeight,\n        resource: imageBuffers,\n        alphaMode: 'no-premultiply-alpha'\n    };\n}\n\nfunction getImageBuffers(dataView: DataView, glType: number, imagePixelByteSize: number, pixelWidth: number,\n    pixelHeight: number, offset: number, numberOfMipmapLevels: number, littleEndian: boolean)\n{\n    const alignedWidth = (pixelWidth + 3) & ~3;\n    const alignedHeight = (pixelHeight + 3) & ~3;\n    let imagePixels = pixelWidth * pixelHeight;\n\n    if (glType === 0)\n    {\n        // Align to 16 pixels (4x4 blocks)\n        imagePixels = alignedWidth * alignedHeight;\n    }\n\n    let mipByteSize = imagePixels * imagePixelByteSize;\n    let mipWidth = pixelWidth;\n    let mipHeight = pixelHeight;\n    let alignedMipWidth = alignedWidth;\n    let alignedMipHeight = alignedHeight;\n    let imageOffset = offset;\n\n    const imageBuffers = new Array<Uint8Array>(numberOfMipmapLevels);\n\n    for (let mipmapLevel = 0; mipmapLevel < numberOfMipmapLevels; mipmapLevel++)\n    {\n        const imageSize = dataView.getUint32(imageOffset, littleEndian);\n        let elementOffset = imageOffset + 4;\n\n        imageBuffers[mipmapLevel] = new Uint8Array(dataView.buffer, elementOffset, mipByteSize);\n\n        elementOffset += mipByteSize;\n\n        // HINT: Aligns to 4-byte boundary after jumping imageSize (in lieu of mipPadding)\n        imageOffset += imageSize + 4;// (+4 to jump the imageSize field itself)\n        imageOffset = imageOffset % 4 !== 0 ? imageOffset + 4 - (imageOffset % 4) : imageOffset;\n\n        // Calculate mipWidth, mipHeight for _next_ iteration\n        mipWidth = (mipWidth >> 1) || 1;\n        mipHeight = (mipHeight >> 1) || 1;\n        alignedMipWidth = (mipWidth + 4 - 1) & ~(4 - 1);\n        alignedMipHeight = (mipHeight + 4 - 1) & ~(4 - 1);\n\n        // Each mipmap level is 4-times smaller?\n        mipByteSize = alignedMipWidth * alignedMipHeight * imagePixelByteSize;\n    }\n\n    return imageBuffers;\n}\n\nfunction getImagePixelByteSize(glType: number, glFormat: number, glInternalFormat: number)\n{\n    let imagePixelByteSize = KTX.INTERNAL_FORMAT_TO_BYTES_PER_PIXEL[glInternalFormat];\n\n    if (glType !== 0)\n    {\n        // Uncompressed texture format\n        if (KTX.TYPES_TO_BYTES_PER_COMPONENT[glType])\n        {\n            imagePixelByteSize = KTX.TYPES_TO_BYTES_PER_COMPONENT[glType] * KTX.FORMATS_TO_COMPONENTS[glFormat];\n        }\n        else\n        {\n            imagePixelByteSize = KTX.TYPES_TO_BYTES_PER_PIXEL[glType];\n        }\n    }\n\n    if (imagePixelByteSize === undefined)\n    {\n        throw new Error('Unable to resolve the pixel format stored in the *.ktx file!');\n    }\n\n    return imagePixelByteSize;\n}\n\nfunction parseKTXHeader(dataView: DataView)\n{\n    const littleEndian = dataView.getUint32(KTX.FIELDS.ENDIANNESS, true) === KTX.ENDIANNESS;\n    const glType = dataView.getUint32(KTX.FIELDS.GL_TYPE, littleEndian);\n    const glFormat = dataView.getUint32(KTX.FIELDS.GL_FORMAT, littleEndian);\n    const glInternalFormat = dataView.getUint32(KTX.FIELDS.GL_INTERNAL_FORMAT, littleEndian);\n    const pixelWidth = dataView.getUint32(KTX.FIELDS.PIXEL_WIDTH, littleEndian);\n    const pixelHeight = dataView.getUint32(KTX.FIELDS.PIXEL_HEIGHT, littleEndian) || 1;// \"pixelHeight = 0\" -> \"1\"\n    const pixelDepth = dataView.getUint32(KTX.FIELDS.PIXEL_DEPTH, littleEndian) || 1;// ^^\n    const numberOfArrayElements = dataView.getUint32(KTX.FIELDS.NUMBER_OF_ARRAY_ELEMENTS, littleEndian) || 1;// ^^\n    const numberOfFaces = dataView.getUint32(KTX.FIELDS.NUMBER_OF_FACES, littleEndian);\n    const numberOfMipmapLevels = dataView.getUint32(KTX.FIELDS.NUMBER_OF_MIPMAP_LEVELS, littleEndian);\n    const bytesOfKeyValueData = dataView.getUint32(KTX.FIELDS.BYTES_OF_KEY_VALUE_DATA, littleEndian);\n\n    if (pixelHeight === 0 || pixelDepth !== 1)\n    {\n        throw new Error('Only 2D textures are supported');\n    }\n    if (numberOfFaces !== 1)\n    {\n        throw new Error('CubeTextures are not supported by KTXLoader yet!');\n    }\n    if (numberOfArrayElements !== 1)\n    {\n        throw new Error('WebGL does not support array textures');\n    }\n\n    return {\n        littleEndian,\n        glType,\n        glFormat,\n        glInternalFormat,\n        pixelWidth,\n        pixelHeight,\n        numberOfMipmapLevels,\n        offset: KTX.FILE_HEADER_SIZE + bytesOfKeyValueData\n    };\n}\n\n/**\n * Checks whether the arrayBuffer contains a valid *.ktx file.\n * @param dataView\n */\nfunction validate(dataView: DataView): boolean\n{\n    // NOTE: Do not optimize this into 3 32-bit integer comparison because the endianness\n    // of the data is not specified.\n    for (let i = 0; i < KTX.FILE_IDENTIFIER.length; i++)\n    {\n        if (dataView.getUint8(i) !== KTX.FILE_IDENTIFIER[i])\n        {\n            return false;\n        }\n    }\n\n    return true;\n}\n"],"names":["KTX"],"mappings":"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"}