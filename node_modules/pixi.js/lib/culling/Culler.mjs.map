{"version":3,"file":"Culler.mjs","sources":["../../src/culling/Culler.ts"],"sourcesContent":["import { Bounds } from '../scene/container/bounds/Bounds';\nimport { getGlobalBounds } from '../scene/container/bounds/getGlobalBounds';\n\nimport type { Container } from '../scene/container/Container';\n\nconst tempBounds = new Bounds();\n\ntype RectangleLike = {x: number, y: number, width: number, height: number};\n\n/**\n * The Culler class is responsible for managing and culling containers.\n *\n *\n * Culled containers will not be rendered, and their children will not be processed. This can be useful for\n * performance optimization when dealing with large scenes.\n * @example\n * import { Culler, Container } from 'pixi.js';\n *\n * const culler = new Culler();\n * const stage = new Container();\n *\n * ... set up stage ...\n *\n * culler.cull(stage, { x: 0, y: 0, width: 800, height: 600 });\n * renderer.render(stage);\n * @memberof scene\n */\nexport class Culler\n{\n    /**\n     * Culls the children of a specific container based on the given view. This will also cull items that are not\n     * being explicitly managed by the culler.\n     * @param container - The container to cull.\n     * @param view - The view rectangle.\n     * @param skipUpdateTransform - Whether to skip updating the transform.\n     */\n    public cull(container: Container, view: RectangleLike, skipUpdateTransform = true)\n    {\n        this._cullRecursive(container, view, skipUpdateTransform);\n    }\n\n    private _cullRecursive(container: Container, view: RectangleLike, skipUpdateTransform = true)\n    {\n        if (container.cullable && container.measurable && container.includeInBuild)\n        {\n            const bounds = container.cullArea ?? getGlobalBounds(container, skipUpdateTransform, tempBounds);\n\n            // check view intersection..\n            container.culled = !(bounds.x >= view.x + view.width\n                || bounds.y >= view.y + view.height\n                || bounds.x + bounds.width <= view.x\n                || bounds.y + bounds.height <= view.y);\n        }\n\n        // dont process children if not needed\n        if (\n            !container.cullableChildren\n            || container.culled\n            || !container.renderable\n            || !container.measurable\n            || !container.includeInBuild\n        ) return;\n\n        for (let i = 0; i < container.children.length; i++)\n        {\n            this._cullRecursive(container.children[i], view, skipUpdateTransform);\n        }\n    }\n\n    /** A shared instance of the Culler class. */\n    public static shared = new Culler();\n}\n"],"names":[],"mappings":";;;;AAKA,MAAM,UAAA,GAAa,IAAI,MAAO,EAAA,CAAA;AAsBvB,MAAM,OAAA,GAAN,MAAM,OACb,CAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQW,IAAK,CAAA,SAAA,EAAsB,IAAqB,EAAA,mBAAA,GAAsB,IAC7E,EAAA;AACI,IAAK,IAAA,CAAA,cAAA,CAAe,SAAW,EAAA,IAAA,EAAM,mBAAmB,CAAA,CAAA;AAAA,GAC5D;AAAA,EAEQ,cAAe,CAAA,SAAA,EAAsB,IAAqB,EAAA,mBAAA,GAAsB,IACxF,EAAA;AACI,IAAA,IAAI,SAAU,CAAA,QAAA,IAAY,SAAU,CAAA,UAAA,IAAc,UAAU,cAC5D,EAAA;AACI,MAAA,MAAM,SAAS,SAAU,CAAA,QAAA,IAAY,eAAgB,CAAA,SAAA,EAAW,qBAAqB,UAAU,CAAA,CAAA;AAG/F,MAAU,SAAA,CAAA,MAAA,GAAS,EAAE,MAAA,CAAO,CAAK,IAAA,IAAA,CAAK,IAAI,IAAK,CAAA,KAAA,IACxC,MAAO,CAAA,CAAA,IAAK,IAAK,CAAA,CAAA,GAAI,KAAK,MAC1B,IAAA,MAAA,CAAO,CAAI,GAAA,MAAA,CAAO,KAAS,IAAA,IAAA,CAAK,KAChC,MAAO,CAAA,CAAA,GAAI,MAAO,CAAA,MAAA,IAAU,IAAK,CAAA,CAAA,CAAA,CAAA;AAAA,KAC5C;AAGA,IAAA,IACI,CAAC,SAAA,CAAU,gBACR,IAAA,SAAA,CAAU,MACV,IAAA,CAAC,SAAU,CAAA,UAAA,IACX,CAAC,SAAA,CAAU,UACX,IAAA,CAAC,SAAU,CAAA,cAAA;AAChB,MAAA,OAAA;AAEF,IAAA,KAAA,IAAS,IAAI,CAAG,EAAA,CAAA,GAAI,SAAU,CAAA,QAAA,CAAS,QAAQ,CAC/C,EAAA,EAAA;AACI,MAAA,IAAA,CAAK,eAAe,SAAU,CAAA,QAAA,CAAS,CAAC,CAAA,EAAG,MAAM,mBAAmB,CAAA,CAAA;AAAA,KACxE;AAAA,GACJ;AAIJ,CAAA,CAAA;AAAA;AA5Ca,OA2CK,CAAA,MAAA,GAAS,IAAI,OAAO,EAAA,CAAA;AA3C/B,IAAM,MAAN,GAAA;;;;"}