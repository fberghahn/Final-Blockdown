{"version":3,"file":"EventBoundary.js","sources":["../../src/events/EventBoundary.ts"],"sourcesContent":["import EventEmitter from 'eventemitter3';\nimport { Point } from '../maths/point/Point';\nimport { warn } from '../utils/logging/warn';\nimport { EventsTicker } from './EventTicker';\nimport { FederatedMouseEvent } from './FederatedMouseEvent';\nimport { FederatedPointerEvent } from './FederatedPointerEvent';\nimport { FederatedWheelEvent } from './FederatedWheelEvent';\n\nimport type { Renderable } from '../rendering/renderers/shared/Renderable';\nimport type { Container } from '../scene/container/Container';\nimport type { EmitterListeners, TrackingData } from './EventBoundaryTypes';\nimport type { FederatedEvent } from './FederatedEvent';\nimport type {\n    Cursor, EventMode, FederatedEventHandler,\n    FederatedEventTarget,\n    IFederatedContainer\n} from './FederatedEventTarget';\n\n// The maximum iterations used in propagation. This prevent infinite loops.\nconst PROPAGATION_LIMIT = 2048;\n\nconst tempHitLocation = new Point();\nconst tempLocalMapping = new Point();\n\n/**\n * Event boundaries are \"barriers\" where events coming from an upstream scene are modified before downstream propagation.\n *\n * ## Root event boundary\n *\n * The {@link EventSystem#rootBoundary rootBoundary} handles events coming from the &lt;canvas /&gt;.\n * {@link EventSystem} handles the normalization from native {@link https://dom.spec.whatwg.org/#event Events}\n * into {@link FederatedEvent FederatedEvents}. The rootBoundary then does the hit-testing and event dispatch\n * for the upstream normalized event.\n *\n * ## Additional event boundaries\n *\n * An additional event boundary may be desired within an application's scene graph. For example, if a portion of the scene is\n * is flat with many children at one level - a spatial hash maybe needed to accelerate hit testing. In this scenario, the\n * container can be detached from the scene and glued using a custom event boundary.\n *\n * ```ts\n * import { Container } from 'pixi.js';\n * import { EventBoundary } from 'pixi.js';\n * import { SpatialHash } from 'pixi-spatial-hash';\n *\n * class HashedHitTestingEventBoundary\n * {\n *     private spatialHash: SpatialHash;\n *\n *     constructor(scene: Container, spatialHash: SpatialHash)\n *     {\n *         super(scene);\n *         this.spatialHash = spatialHash;\n *     }\n *\n *     hitTestRecursive(...)\n *     {\n *         // TODO: If target === this.rootTarget, then use spatial hash to get a\n *         // list of possible children that match the given (x,y) coordinates.\n *     }\n * }\n *\n * class VastScene extends Container\n * {\n *     protected eventBoundary: EventBoundary;\n *     protected scene: Container;\n *     protected spatialHash: SpatialHash;\n *\n *     constructor()\n *     {\n *         this.scene = new Container();\n *         this.spatialHash = new SpatialHash();\n *         this.eventBoundary = new HashedHitTestingEventBoundary(this.scene, this.spatialHash);\n *\n *         // Populate this.scene with a ton of children, while updating this.spatialHash\n *     }\n * }\n * ```\n * @memberof events\n */\nexport class EventBoundary\n{\n    /**\n     * The root event-target residing below the event boundary.\n     * All events are dispatched trickling down and bubbling up to this `rootTarget`.\n     */\n    public rootTarget: Container;\n\n    /**\n     * Emits events after they were dispatched into the scene graph.\n     *\n     * This can be used for global events listening, regardless of the scene graph being used. It should\n     * not be used by interactive libraries for normal use.\n     *\n     * Special events that do not bubble all the way to the root target are not emitted from here,\n     * e.g. pointerenter, pointerleave, click.\n     */\n    public dispatch: EventEmitter = new EventEmitter();\n\n    /** The cursor preferred by the event targets underneath this boundary. */\n    public cursor: Cursor | string;\n\n    /**\n     * This flag would emit `pointermove`, `touchmove`, and `mousemove` events on all Containers.\n     *\n     * The `moveOnAll` semantics mirror those of earlier versions of PixiJS. This was disabled in favor of\n     * the Pointer Event API's approach.\n     */\n    public moveOnAll = false;\n\n    /** Enables the global move events. `globalpointermove`, `globaltouchmove`, and `globalmousemove` */\n    public enableGlobalMoveEvents = true;\n\n    /**\n     * Maps event types to forwarding handles for them.\n     *\n     * {@link EventBoundary EventBoundary} provides mapping for \"pointerdown\", \"pointermove\",\n     * \"pointerout\", \"pointerleave\", \"pointerover\", \"pointerup\", and \"pointerupoutside\" by default.\n     * @see EventBoundary#addEventMapping\n     */\n    protected mappingTable: Record<string, Array<{\n        fn: (e: FederatedEvent) => void,\n        priority: number\n    }>>;\n\n    /**\n     * State object for mapping methods.\n     * @see EventBoundary#trackingData\n     */\n    protected mappingState: Record<string, any> = {\n        trackingData: {}\n    };\n\n    /**\n     * The event pool maps event constructors to an free pool of instances of those specific events.\n     * @see EventBoundary#allocateEvent\n     * @see EventBoundary#freeEvent\n     */\n    protected eventPool: Map<typeof FederatedEvent, FederatedEvent[]> = new Map();\n\n    /** Every interactive element gathered from the scene. Only used in `pointermove` */\n    private readonly _allInteractiveElements: FederatedEventTarget[] = [];\n    /** Every element that passed the hit test. Only used in `pointermove` */\n    private _hitElements: FederatedEventTarget[] = [];\n    /** Whether or not to collect all the interactive elements from the scene. Enabled in `pointermove` */\n    private _isPointerMoveEvent = false;\n\n    /**\n     * @param rootTarget - The holder of the event boundary.\n     */\n    constructor(rootTarget?: Container)\n    {\n        this.rootTarget = rootTarget;\n\n        this.hitPruneFn = this.hitPruneFn.bind(this);\n        this.hitTestFn = this.hitTestFn.bind(this);\n        this.mapPointerDown = this.mapPointerDown.bind(this);\n        this.mapPointerMove = this.mapPointerMove.bind(this);\n        this.mapPointerOut = this.mapPointerOut.bind(this);\n        this.mapPointerOver = this.mapPointerOver.bind(this);\n        this.mapPointerUp = this.mapPointerUp.bind(this);\n        this.mapPointerUpOutside = this.mapPointerUpOutside.bind(this);\n        this.mapWheel = this.mapWheel.bind(this);\n\n        this.mappingTable = {};\n        this.addEventMapping('pointerdown', this.mapPointerDown);\n        this.addEventMapping('pointermove', this.mapPointerMove);\n        this.addEventMapping('pointerout', this.mapPointerOut);\n        this.addEventMapping('pointerleave', this.mapPointerOut);\n        this.addEventMapping('pointerover', this.mapPointerOver);\n        this.addEventMapping('pointerup', this.mapPointerUp);\n        this.addEventMapping('pointerupoutside', this.mapPointerUpOutside);\n        this.addEventMapping('wheel', this.mapWheel);\n    }\n\n    /**\n     * Adds an event mapping for the event `type` handled by `fn`.\n     *\n     * Event mappings can be used to implement additional or custom events. They take an event\n     * coming from the upstream scene (or directly from the {@link EventSystem}) and dispatch new downstream events\n     * generally trickling down and bubbling up to {@link EventBoundary.rootTarget this.rootTarget}.\n     *\n     * To modify the semantics of existing events, the built-in mapping methods of EventBoundary should be overridden\n     * instead.\n     * @param type - The type of upstream event to map.\n     * @param fn - The mapping method. The context of this function must be bound manually, if desired.\n     */\n    public addEventMapping(type: string, fn: (e: FederatedEvent) => void): void\n    {\n        if (!this.mappingTable[type])\n        {\n            this.mappingTable[type] = [];\n        }\n\n        this.mappingTable[type].push({\n            fn,\n            priority: 0,\n        });\n        this.mappingTable[type].sort((a, b) => a.priority - b.priority);\n    }\n\n    /**\n     * Dispatches the given event\n     * @param e - The event to dispatch.\n     * @param type - The type of event to dispatch. Defaults to `e.type`.\n     */\n    public dispatchEvent(e: FederatedEvent, type?: string): void\n    {\n        e.propagationStopped = false;\n        e.propagationImmediatelyStopped = false;\n\n        this.propagate(e, type);\n        this.dispatch.emit(type || e.type, e);\n    }\n\n    /**\n     * Maps the given upstream event through the event boundary and propagates it downstream.\n     * @param e - The event to map.\n     */\n    public mapEvent(e: FederatedEvent): void\n    {\n        if (!this.rootTarget)\n        {\n            return;\n        }\n\n        const mappers = this.mappingTable[e.type];\n\n        if (mappers)\n        {\n            for (let i = 0, j = mappers.length; i < j; i++)\n            {\n                mappers[i].fn(e);\n            }\n        }\n        else\n        {\n            // #if _DEBUG\n            warn(`[EventBoundary]: Event mapping not defined for ${e.type}`);\n            // #endif\n        }\n    }\n\n    /**\n     * Finds the Container that is the target of a event at the given coordinates.\n     *\n     * The passed (x,y) coordinates are in the world space above this event boundary.\n     * @param x - The x coordinate of the event.\n     * @param y - The y coordinate of the event.\n     */\n    public hitTest(\n        x: number,\n        y: number,\n    ): Container\n    {\n        EventsTicker.pauseUpdate = true;\n        // if we are using global move events, we need to hit test the whole scene graph\n        const useMove = this._isPointerMoveEvent && this.enableGlobalMoveEvents;\n        const fn = useMove ? 'hitTestMoveRecursive' : 'hitTestRecursive';\n        const invertedPath = this[fn](\n            this.rootTarget,\n            this.rootTarget.eventMode,\n            tempHitLocation.set(x, y),\n            this.hitTestFn,\n            this.hitPruneFn,\n        );\n\n        return invertedPath && invertedPath[0];\n    }\n\n    /**\n     * Propagate the passed event from from {@link EventBoundary.rootTarget this.rootTarget} to its\n     * target {@code e.target}.\n     * @param e - The event to propagate.\n     * @param type - The type of event to propagate. Defaults to `e.type`.\n     */\n    public propagate(e: FederatedEvent, type?: string): void\n    {\n        if (!e.target)\n        {\n            // This usually occurs when the scene graph is not interactive.\n            return;\n        }\n\n        const composedPath = e.composedPath();\n\n        // Capturing phase\n        e.eventPhase = e.CAPTURING_PHASE;\n\n        for (let i = 0, j = composedPath.length - 1; i < j; i++)\n        {\n            e.currentTarget = composedPath[i];\n\n            this.notifyTarget(e, type);\n\n            if (e.propagationStopped || e.propagationImmediatelyStopped) return;\n        }\n\n        // At target phase\n        e.eventPhase = e.AT_TARGET;\n        e.currentTarget = e.target;\n\n        this.notifyTarget(e, type);\n\n        if (e.propagationStopped || e.propagationImmediatelyStopped) return;\n\n        // Bubbling phase\n        e.eventPhase = e.BUBBLING_PHASE;\n\n        for (let i = composedPath.length - 2; i >= 0; i--)\n        {\n            e.currentTarget = composedPath[i];\n\n            this.notifyTarget(e, type);\n\n            if (e.propagationStopped || e.propagationImmediatelyStopped) return;\n        }\n    }\n\n    /**\n     * Emits the event {@code e} to all interactive containers. The event is propagated in the bubbling phase always.\n     *\n     * This is used in the `globalpointermove` event.\n     * @param e - The emitted event.\n     * @param type - The listeners to notify.\n     * @param targets - The targets to notify.\n     */\n    public all(e: FederatedEvent, type?: string | string[], targets = this._allInteractiveElements): void\n    {\n        if (targets.length === 0) return;\n\n        e.eventPhase = e.BUBBLING_PHASE;\n\n        const events = Array.isArray(type) ? type : [type];\n\n        // loop through all interactive elements and notify them of the event\n        // loop through targets backwards\n        for (let i = targets.length - 1; i >= 0; i--)\n        {\n            events.forEach((event) =>\n            {\n                e.currentTarget = targets[i];\n                this.notifyTarget(e, event);\n            });\n        }\n    }\n\n    /**\n     * Finds the propagation path from {@link EventBoundary.rootTarget rootTarget} to the passed\n     * {@code target}. The last element in the path is {@code target}.\n     * @param target - The target to find the propagation path to.\n     */\n    public propagationPath(target: FederatedEventTarget): FederatedEventTarget[]\n    {\n        const propagationPath = [target];\n\n        for (let i = 0; i < PROPAGATION_LIMIT && (target !== this.rootTarget && target.parent); i++)\n        {\n            if (!target.parent)\n            {\n                throw new Error('Cannot find propagation path to disconnected target');\n            }\n\n            propagationPath.push(target.parent);\n\n            target = target.parent;\n        }\n\n        propagationPath.reverse();\n\n        return propagationPath;\n    }\n\n    protected hitTestMoveRecursive(\n        currentTarget: Container,\n        eventMode: EventMode,\n        location: Point,\n        testFn: (object: Container, pt: Point) => boolean,\n        pruneFn: (object: Container, pt: Point) => boolean,\n        ignore = false\n    ): Container[]\n    {\n        let shouldReturn = false;\n\n        // only bail out early if it is not interactive\n        if (this._interactivePrune(currentTarget)) return null;\n\n        if (currentTarget.eventMode === 'dynamic' || eventMode === 'dynamic')\n        {\n            EventsTicker.pauseUpdate = false;\n        }\n\n        if (currentTarget.interactiveChildren && currentTarget.children)\n        {\n            const children = currentTarget.children;\n\n            for (let i = children.length - 1; i >= 0; i--)\n            {\n                const child = children[i] as Container;\n\n                const nestedHit = this.hitTestMoveRecursive(\n                    child,\n                    this._isInteractive(eventMode) ? eventMode : child.eventMode,\n                    location,\n                    testFn,\n                    pruneFn,\n                    ignore || pruneFn(currentTarget, location)\n                );\n\n                if (nestedHit)\n                {\n                    // Its a good idea to check if a child has lost its parent.\n                    // this means it has been removed whilst looping so its best\n                    if (nestedHit.length > 0 && !nestedHit[nestedHit.length - 1].parent)\n                    {\n                        continue;\n                    }\n\n                    // Only add the current hit-test target to the hit-test chain if the chain\n                    // has already started (i.e. the event target has been found) or if the current\n                    // target is interactive (i.e. it becomes the event target).\n                    const isInteractive = currentTarget.isInteractive();\n\n                    if (nestedHit.length > 0 || isInteractive)\n                    {\n                        if (isInteractive) this._allInteractiveElements.push(currentTarget);\n                        nestedHit.push(currentTarget);\n                    }\n\n                    // store all hit elements to be returned once we have traversed the whole tree\n                    if (this._hitElements.length === 0) this._hitElements = nestedHit;\n\n                    shouldReturn = true;\n                }\n            }\n        }\n\n        const isInteractiveMode = this._isInteractive(eventMode);\n        const isInteractiveTarget = currentTarget.isInteractive();\n\n        if (isInteractiveTarget && isInteractiveTarget) this._allInteractiveElements.push(currentTarget);\n\n        // we don't carry on hit testing something once we have found a hit,\n        // now only care about gathering the interactive elements\n        if (ignore || this._hitElements.length > 0) return null;\n\n        if (shouldReturn) return this._hitElements as Container[];\n\n        // Finally, hit test this Container itself.\n        if (isInteractiveMode && (!pruneFn(currentTarget, location) && testFn(currentTarget, location)))\n        {\n            // The current hit-test target is the event's target only if it is interactive. Otherwise,\n            // the first interactive ancestor will be the event's target.\n            return isInteractiveTarget ? [currentTarget] : [];\n        }\n\n        return null;\n    }\n\n    /**\n     * Recursive implementation for {@link EventBoundary.hitTest hitTest}.\n     * @param currentTarget - The Container that is to be hit tested.\n     * @param eventMode - The event mode for the `currentTarget` or one of its parents.\n     * @param location - The location that is being tested for overlap.\n     * @param testFn - Callback that determines whether the target passes hit testing. This callback\n     *  can assume that `pruneFn` failed to prune the container.\n     * @param pruneFn - Callback that determiness whether the target and all of its children\n     *  cannot pass the hit test. It is used as a preliminary optimization to prune entire subtrees\n     *  of the scene graph.\n     * @returns An array holding the hit testing target and all its ancestors in order. The first element\n     *  is the target itself and the last is {@link EventBoundary.rootTarget rootTarget}. This is the opposite\n     *  order w.r.t. the propagation path. If no hit testing target is found, null is returned.\n     */\n    protected hitTestRecursive(\n        currentTarget: Container,\n        eventMode: EventMode,\n        location: Point,\n        testFn: (object: Container, pt: Point) => boolean,\n        pruneFn: (object: Container, pt: Point) => boolean\n    ): Container[]\n    {\n        // Attempt to prune this Container and its subtree as an optimization.\n        if (this._interactivePrune(currentTarget) || pruneFn(currentTarget, location))\n        {\n            return null;\n        }\n        if (currentTarget.eventMode === 'dynamic' || eventMode === 'dynamic')\n        {\n            EventsTicker.pauseUpdate = false;\n        }\n\n        // Find a child that passes the hit testing and return one, if any.\n        if (currentTarget.interactiveChildren && currentTarget.children)\n        {\n            const children = currentTarget.children;\n            const relativeLocation = location;\n\n            for (let i = children.length - 1; i >= 0; i--)\n            {\n                const child = children[i] as Container;\n\n                const nestedHit = this.hitTestRecursive(\n                    child,\n                    this._isInteractive(eventMode) ? eventMode : child.eventMode,\n                    relativeLocation,\n                    testFn,\n                    pruneFn\n                );\n\n                if (nestedHit)\n                {\n                    // Its a good idea to check if a child has lost its parent.\n                    // this means it has been removed whilst looping so its best\n                    if (nestedHit.length > 0 && !nestedHit[nestedHit.length - 1].parent)\n                    {\n                        continue;\n                    }\n\n                    // Only add the current hit-test target to the hit-test chain if the chain\n                    // has already started (i.e. the event target has been found) or if the current\n                    // target is interactive (i.e. it becomes the event target).\n                    const isInteractive = currentTarget.isInteractive();\n\n                    if (nestedHit.length > 0 || isInteractive) nestedHit.push(currentTarget);\n\n                    return nestedHit;\n                }\n            }\n        }\n\n        const isInteractiveMode = this._isInteractive(eventMode);\n        const isInteractiveTarget = currentTarget.isInteractive();\n\n        // Finally, hit test this Container itself.\n        if (isInteractiveMode && testFn(currentTarget, location))\n        {\n            // The current hit-test target is the event's target only if it is interactive. Otherwise,\n            // the first interactive ancestor will be the event's target.\n            return isInteractiveTarget ? [currentTarget] : [];\n        }\n\n        return null;\n    }\n\n    private _isInteractive(int: EventMode): int is 'static' | 'dynamic'\n    {\n        return int === 'static' || int === 'dynamic';\n    }\n\n    private _interactivePrune(container: Container): boolean\n    {\n        // If container is a mask, invisible, or not renderable then it cannot be hit directly.\n        if (!container || !container.visible || !container.renderable)\n        {\n            return true;\n        }\n\n        // If this Container is none then it cannot be hit by anything.\n        if (container.eventMode === 'none')\n        {\n            return true;\n        }\n\n        // If this Container is passive and it has no interactive children then it cannot be hit\n        if (container.eventMode === 'passive' && !container.interactiveChildren)\n        {\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Checks whether the container or any of its children cannot pass the hit test at all.\n     *\n     * {@link EventBoundary}'s implementation uses the {@link Container.hitArea hitArea}\n     * and {@link Container._mask} for pruning.\n     * @param container - The container to prune.\n     * @param location - The location to test for overlap.\n     */\n    protected hitPruneFn(container: Container, location: Point): boolean\n    {\n        if (container.hitArea)\n        {\n            container.worldTransform.applyInverse(location, tempLocalMapping);\n\n            if (!container.hitArea.contains(tempLocalMapping.x, tempLocalMapping.y))\n            {\n                return true;\n            }\n        }\n\n        if (container.effects && container.effects.length)\n        {\n            for (let i = 0; i < container.effects.length; i++)\n            {\n                const effect = container.effects[i];\n\n                if (effect.containsPoint)\n                {\n                    const effectContainsPoint = effect.containsPoint(location, this.hitTestFn);\n\n                    if (!effectContainsPoint)\n                    {\n                        return true;\n                    }\n                }\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Checks whether the container passes hit testing for the given location.\n     * @param container - The container to test.\n     * @param location - The location to test for overlap.\n     * @returns - Whether `container` passes hit testing for `location`.\n     */\n    protected hitTestFn(container: Container, location: Point): boolean\n    {\n        // If the container failed pruning with a hitArea, then it must pass it.\n        if (container.hitArea)\n        {\n            return true;\n        }\n\n        if ((container as Renderable)?.containsPoint)\n        {\n            container.worldTransform.applyInverse(location, tempLocalMapping);\n\n            return (container as Renderable).containsPoint(tempLocalMapping) as boolean;\n        }\n\n        // TODO: Should we hit test based on bounds?\n\n        return false;\n    }\n\n    /**\n     * Notify all the listeners to the event's `currentTarget`.\n     *\n     * If the `currentTarget` contains the property `on<type>`, then it is called here,\n     * simulating the behavior from version 6.x and prior.\n     * @param e - The event passed to the target.\n     * @param type - The type of event to notify. Defaults to `e.type`.\n     */\n    protected notifyTarget(e: FederatedEvent, type?: string): void\n    {\n        type = type ?? e.type;\n\n        // call the `on${type}` for the current target if it exists\n        const handlerKey = `on${type}` as keyof IFederatedContainer;\n\n        (e.currentTarget[handlerKey] as FederatedEventHandler<FederatedEvent>)?.(e);\n\n        const key = e.eventPhase === e.CAPTURING_PHASE || e.eventPhase === e.AT_TARGET ? `${type}capture` : type;\n\n        this._notifyListeners(e, key);\n\n        if (e.eventPhase === e.AT_TARGET)\n        {\n            this._notifyListeners(e, type);\n        }\n    }\n\n    /**\n     * Maps the upstream `pointerdown` events to a downstream `pointerdown` event.\n     *\n     * `touchstart`, `rightdown`, `mousedown` events are also dispatched for specific pointer types.\n     * @param from - The upstream `pointerdown` event.\n     */\n    protected mapPointerDown(from: FederatedEvent): void\n    {\n        if (!(from instanceof FederatedPointerEvent))\n        {\n            // #if _DEBUG\n            warn('EventBoundary cannot map a non-pointer event as a pointer event');\n            // #endif\n\n            return;\n        }\n\n        const e = this.createPointerEvent(from);\n\n        this.dispatchEvent(e, 'pointerdown');\n\n        if (e.pointerType === 'touch')\n        {\n            this.dispatchEvent(e, 'touchstart');\n        }\n        else if (e.pointerType === 'mouse' || e.pointerType === 'pen')\n        {\n            const isRightButton = e.button === 2;\n\n            this.dispatchEvent(e, isRightButton ? 'rightdown' : 'mousedown');\n        }\n\n        const trackingData = this.trackingData(from.pointerId);\n\n        trackingData.pressTargetsByButton[from.button] = e.composedPath();\n\n        this.freeEvent(e);\n    }\n\n    /**\n     * Maps the upstream `pointermove` to downstream `pointerout`, `pointerover`, and `pointermove` events, in that order.\n     *\n     * The tracking data for the specific pointer has an updated `overTarget`. `mouseout`, `mouseover`,\n     * `mousemove`, and `touchmove` events are fired as well for specific pointer types.\n     * @param from - The upstream `pointermove` event.\n     */\n    protected mapPointerMove(from: FederatedEvent): void\n    {\n        if (!(from instanceof FederatedPointerEvent))\n        {\n            // #if _DEBUG\n            warn('EventBoundary cannot map a non-pointer event as a pointer event');\n            // #endif\n\n            return;\n        }\n\n        this._allInteractiveElements.length = 0;\n        this._hitElements.length = 0;\n        this._isPointerMoveEvent = true;\n        const e = this.createPointerEvent(from);\n\n        this._isPointerMoveEvent = false;\n        const isMouse = e.pointerType === 'mouse' || e.pointerType === 'pen';\n        const trackingData = this.trackingData(from.pointerId);\n        const outTarget = this.findMountedTarget(trackingData.overTargets);\n\n        // First pointerout/pointerleave\n        if (trackingData.overTargets?.length > 0 && outTarget !== e.target)\n        {\n            // pointerout always occurs on the overTarget when the pointer hovers over another element.\n            const outType = from.type === 'mousemove' ? 'mouseout' : 'pointerout';\n            const outEvent = this.createPointerEvent(from, outType, outTarget);\n\n            this.dispatchEvent(outEvent, 'pointerout');\n            if (isMouse) this.dispatchEvent(outEvent, 'mouseout');\n\n            // If the pointer exits overTarget and its descendants, then a pointerleave event is also fired. This event\n            // is dispatched to all ancestors that no longer capture the pointer.\n            if (!e.composedPath().includes(outTarget))\n            {\n                const leaveEvent = this.createPointerEvent(from, 'pointerleave', outTarget);\n\n                leaveEvent.eventPhase = leaveEvent.AT_TARGET;\n\n                while (leaveEvent.target && !e.composedPath().includes(leaveEvent.target))\n                {\n                    leaveEvent.currentTarget = leaveEvent.target;\n\n                    this.notifyTarget(leaveEvent);\n                    if (isMouse) this.notifyTarget(leaveEvent, 'mouseleave');\n\n                    leaveEvent.target = leaveEvent.target.parent;\n                }\n\n                this.freeEvent(leaveEvent);\n            }\n\n            this.freeEvent(outEvent);\n        }\n\n        // Then pointerover\n        if (outTarget !== e.target)\n        {\n            // pointerover always occurs on the new overTarget\n            const overType = from.type === 'mousemove' ? 'mouseover' : 'pointerover';\n            const overEvent = this.clonePointerEvent(e, overType);// clone faster\n\n            this.dispatchEvent(overEvent, 'pointerover');\n            if (isMouse) this.dispatchEvent(overEvent, 'mouseover');\n\n            // Probe whether the newly hovered Container is an ancestor of the original overTarget.\n            let overTargetAncestor = outTarget?.parent;\n\n            while (overTargetAncestor && overTargetAncestor !== this.rootTarget.parent)\n            {\n                if (overTargetAncestor === e.target) break;\n\n                overTargetAncestor = overTargetAncestor.parent;\n            }\n\n            // The pointer has entered a non-ancestor of the original overTarget. This means we need a pointerentered\n            // event.\n            const didPointerEnter = !overTargetAncestor || overTargetAncestor === this.rootTarget.parent;\n\n            if (didPointerEnter)\n            {\n                const enterEvent = this.clonePointerEvent(e, 'pointerenter');\n\n                enterEvent.eventPhase = enterEvent.AT_TARGET;\n\n                while (enterEvent.target\n                        && enterEvent.target !== outTarget\n                        && enterEvent.target !== this.rootTarget.parent)\n                {\n                    enterEvent.currentTarget = enterEvent.target;\n\n                    this.notifyTarget(enterEvent);\n                    if (isMouse) this.notifyTarget(enterEvent, 'mouseenter');\n\n                    enterEvent.target = enterEvent.target.parent;\n                }\n\n                this.freeEvent(enterEvent);\n            }\n\n            this.freeEvent(overEvent);\n        }\n\n        const allMethods: string[] = [];\n        const allowGlobalPointerEvents = this.enableGlobalMoveEvents ?? true;\n\n        this.moveOnAll ? allMethods.push('pointermove') : this.dispatchEvent(e, 'pointermove');\n        allowGlobalPointerEvents && allMethods.push('globalpointermove');\n\n        // Then pointermove\n        if (e.pointerType === 'touch')\n        {\n            this.moveOnAll ? allMethods.splice(1, 0, 'touchmove') : this.dispatchEvent(e, 'touchmove');\n            allowGlobalPointerEvents && allMethods.push('globaltouchmove');\n        }\n\n        if (isMouse)\n        {\n            this.moveOnAll ? allMethods.splice(1, 0, 'mousemove') : this.dispatchEvent(e, 'mousemove');\n            allowGlobalPointerEvents && allMethods.push('globalmousemove');\n            this.cursor = e.target?.cursor;\n        }\n\n        if (allMethods.length > 0)\n        {\n            this.all(e, allMethods);\n        }\n        this._allInteractiveElements.length = 0;\n        this._hitElements.length = 0;\n\n        trackingData.overTargets = e.composedPath();\n\n        this.freeEvent(e);\n    }\n\n    /**\n     * Maps the upstream `pointerover` to downstream `pointerover` and `pointerenter` events, in that order.\n     *\n     * The tracking data for the specific pointer gets a new `overTarget`.\n     * @param from - The upstream `pointerover` event.\n     */\n    protected mapPointerOver(from: FederatedEvent): void\n    {\n        if (!(from instanceof FederatedPointerEvent))\n        {\n            // #if _DEBUG\n            warn('EventBoundary cannot map a non-pointer event as a pointer event');\n            // #endif\n\n            return;\n        }\n\n        const trackingData = this.trackingData(from.pointerId);\n        const e = this.createPointerEvent(from);\n        const isMouse = e.pointerType === 'mouse' || e.pointerType === 'pen';\n\n        this.dispatchEvent(e, 'pointerover');\n        if (isMouse) this.dispatchEvent(e, 'mouseover');\n        if (e.pointerType === 'mouse') this.cursor = e.target?.cursor;\n\n        // pointerenter events must be fired since the pointer entered from upstream.\n        const enterEvent = this.clonePointerEvent(e, 'pointerenter');\n\n        enterEvent.eventPhase = enterEvent.AT_TARGET;\n\n        while (enterEvent.target && enterEvent.target !== this.rootTarget.parent)\n        {\n            enterEvent.currentTarget = enterEvent.target;\n\n            this.notifyTarget(enterEvent);\n            if (isMouse) this.notifyTarget(enterEvent, 'mouseenter');\n\n            enterEvent.target = enterEvent.target.parent;\n        }\n\n        trackingData.overTargets = e.composedPath();\n\n        this.freeEvent(e);\n        this.freeEvent(enterEvent);\n    }\n\n    /**\n     * Maps the upstream `pointerout` to downstream `pointerout`, `pointerleave` events, in that order.\n     *\n     * The tracking data for the specific pointer is cleared of a `overTarget`.\n     * @param from - The upstream `pointerout` event.\n     */\n    protected mapPointerOut(from: FederatedEvent): void\n    {\n        if (!(from instanceof FederatedPointerEvent))\n        {\n            // #if _DEBUG\n            warn('EventBoundary cannot map a non-pointer event as a pointer event');\n            // #endif\n\n            return;\n        }\n\n        const trackingData = this.trackingData(from.pointerId);\n\n        if (trackingData.overTargets)\n        {\n            const isMouse = from.pointerType === 'mouse' || from.pointerType === 'pen';\n            const outTarget = this.findMountedTarget(trackingData.overTargets);\n\n            // pointerout first\n            const outEvent = this.createPointerEvent(from, 'pointerout', outTarget);\n\n            this.dispatchEvent(outEvent);\n            if (isMouse) this.dispatchEvent(outEvent, 'mouseout');\n\n            // pointerleave(s) are also dispatched b/c the pointer must've left rootTarget and its descendants to\n            // get an upstream pointerout event (upstream events do not know rootTarget has descendants).\n            const leaveEvent = this.createPointerEvent(from, 'pointerleave', outTarget);\n\n            leaveEvent.eventPhase = leaveEvent.AT_TARGET;\n\n            while (leaveEvent.target && leaveEvent.target !== this.rootTarget.parent)\n            {\n                leaveEvent.currentTarget = leaveEvent.target;\n\n                this.notifyTarget(leaveEvent);\n                if (isMouse) this.notifyTarget(leaveEvent, 'mouseleave');\n\n                leaveEvent.target = leaveEvent.target.parent;\n            }\n\n            trackingData.overTargets = null;\n\n            this.freeEvent(outEvent);\n            this.freeEvent(leaveEvent);\n        }\n\n        this.cursor = null;\n    }\n\n    /**\n     * Maps the upstream `pointerup` event to downstream `pointerup`, `pointerupoutside`,\n     * and `click`/`rightclick`/`pointertap` events, in that order.\n     *\n     * The `pointerupoutside` event bubbles from the original `pointerdown` target to the most specific\n     * ancestor of the `pointerdown` and `pointerup` targets, which is also the `click` event's target. `touchend`,\n     * `rightup`, `mouseup`, `touchendoutside`, `rightupoutside`, `mouseupoutside`, and `tap` are fired as well for\n     * specific pointer types.\n     * @param from - The upstream `pointerup` event.\n     */\n    protected mapPointerUp(from: FederatedEvent): void\n    {\n        if (!(from instanceof FederatedPointerEvent))\n        {\n            // #if _DEBUG\n            warn('EventBoundary cannot map a non-pointer event as a pointer event');\n            // #endif\n\n            return;\n        }\n\n        const now = performance.now();\n        const e = this.createPointerEvent(from);\n\n        this.dispatchEvent(e, 'pointerup');\n\n        if (e.pointerType === 'touch')\n        {\n            this.dispatchEvent(e, 'touchend');\n        }\n        else if (e.pointerType === 'mouse' || e.pointerType === 'pen')\n        {\n            const isRightButton = e.button === 2;\n\n            this.dispatchEvent(e, isRightButton ? 'rightup' : 'mouseup');\n        }\n\n        const trackingData = this.trackingData(from.pointerId);\n        const pressTarget = this.findMountedTarget(trackingData.pressTargetsByButton[from.button]);\n\n        let clickTarget = pressTarget;\n\n        // pointerupoutside only bubbles. It only bubbles upto the parent that doesn't contain\n        // the pointerup location.\n        if (pressTarget && !e.composedPath().includes(pressTarget))\n        {\n            let currentTarget = pressTarget;\n\n            while (currentTarget && !e.composedPath().includes(currentTarget))\n            {\n                e.currentTarget = currentTarget;\n\n                this.notifyTarget(e, 'pointerupoutside');\n\n                if (e.pointerType === 'touch')\n                {\n                    this.notifyTarget(e, 'touchendoutside');\n                }\n                else if (e.pointerType === 'mouse' || e.pointerType === 'pen')\n                {\n                    const isRightButton = e.button === 2;\n\n                    this.notifyTarget(e, isRightButton ? 'rightupoutside' : 'mouseupoutside');\n                }\n\n                currentTarget = currentTarget.parent;\n            }\n\n            delete trackingData.pressTargetsByButton[from.button];\n\n            // currentTarget is the most specific ancestor holding both the pointerdown and pointerup\n            // targets. That is - it's our click target!\n            clickTarget = currentTarget;\n        }\n\n        // click!\n        if (clickTarget)\n        {\n            const clickEvent = this.clonePointerEvent(e, 'click');\n\n            clickEvent.target = clickTarget;\n            clickEvent.path = null;\n\n            if (!trackingData.clicksByButton[from.button])\n            {\n                trackingData.clicksByButton[from.button] = {\n                    clickCount: 0,\n                    target: clickEvent.target,\n                    timeStamp: now,\n                };\n            }\n\n            const clickHistory = trackingData.clicksByButton[from.button];\n\n            if (clickHistory.target === clickEvent.target\n                && now - clickHistory.timeStamp < 200)\n            {\n                ++clickHistory.clickCount;\n            }\n            else\n            {\n                clickHistory.clickCount = 1;\n            }\n\n            clickHistory.target = clickEvent.target;\n            clickHistory.timeStamp = now;\n\n            clickEvent.detail = clickHistory.clickCount;\n\n            if (clickEvent.pointerType === 'mouse')\n            {\n                const isRightButton = clickEvent.button === 2;\n\n                this.dispatchEvent(clickEvent, isRightButton ? 'rightclick' : 'click');\n            }\n            else if (clickEvent.pointerType === 'touch')\n            {\n                this.dispatchEvent(clickEvent, 'tap');\n            }\n\n            this.dispatchEvent(clickEvent, 'pointertap');\n\n            this.freeEvent(clickEvent);\n        }\n\n        this.freeEvent(e);\n    }\n\n    /**\n     * Maps the upstream `pointerupoutside` event to a downstream `pointerupoutside` event, bubbling from the original\n     * `pointerdown` target to `rootTarget`.\n     *\n     * (The most specific ancestor of the `pointerdown` event and the `pointerup` event must the\n     * `{@link EventBoundary}'s root because the `pointerup` event occurred outside of the boundary.)\n     *\n     * `touchendoutside`, `mouseupoutside`, and `rightupoutside` events are fired as well for specific pointer\n     * types. The tracking data for the specific pointer is cleared of a `pressTarget`.\n     * @param from - The upstream `pointerupoutside` event.\n     */\n    protected mapPointerUpOutside(from: FederatedEvent): void\n    {\n        if (!(from instanceof FederatedPointerEvent))\n        {\n            // #if _DEBUG\n            warn('EventBoundary cannot map a non-pointer event as a pointer event');\n            // #endif\n\n            return;\n        }\n\n        const trackingData = this.trackingData(from.pointerId);\n        const pressTarget = this.findMountedTarget(trackingData.pressTargetsByButton[from.button]);\n        const e = this.createPointerEvent(from);\n\n        if (pressTarget)\n        {\n            let currentTarget = pressTarget;\n\n            while (currentTarget)\n            {\n                e.currentTarget = currentTarget;\n\n                this.notifyTarget(e, 'pointerupoutside');\n\n                if (e.pointerType === 'touch')\n                {\n                    this.notifyTarget(e, 'touchendoutside');\n                }\n                else if (e.pointerType === 'mouse' || e.pointerType === 'pen')\n                {\n                    this.notifyTarget(e, e.button === 2 ? 'rightupoutside' : 'mouseupoutside');\n                }\n\n                currentTarget = currentTarget.parent;\n            }\n\n            delete trackingData.pressTargetsByButton[from.button];\n        }\n\n        this.freeEvent(e);\n    }\n\n    /**\n     * Maps the upstream `wheel` event to a downstream `wheel` event.\n     * @param from - The upstream `wheel` event.\n     */\n    protected mapWheel(from: FederatedEvent): void\n    {\n        if (!(from instanceof FederatedWheelEvent))\n        {\n            // #if _DEBUG\n            warn('EventBoundary cannot map a non-wheel event as a wheel event');\n            // #endif\n\n            return;\n        }\n\n        const wheelEvent = this.createWheelEvent(from);\n\n        this.dispatchEvent(wheelEvent);\n        this.freeEvent(wheelEvent);\n    }\n\n    /**\n     * Finds the most specific event-target in the given propagation path that is still mounted in the scene graph.\n     *\n     * This is used to find the correct `pointerup` and `pointerout` target in the case that the original `pointerdown`\n     * or `pointerover` target was unmounted from the scene graph.\n     * @param propagationPath - The propagation path was valid in the past.\n     * @returns - The most specific event-target still mounted at the same location in the scene graph.\n     */\n    protected findMountedTarget(propagationPath: FederatedEventTarget[]): FederatedEventTarget\n    {\n        if (!propagationPath)\n        {\n            return null;\n        }\n\n        let currentTarget = propagationPath[0];\n\n        for (let i = 1; i < propagationPath.length; i++)\n        {\n            // Set currentTarget to the next target in the path only if it is still attached to the\n            // scene graph (i.e. parent still points to the expected ancestor).\n            if (propagationPath[i].parent === currentTarget)\n            {\n                currentTarget = propagationPath[i];\n            }\n            else\n            {\n                break;\n            }\n        }\n\n        return currentTarget;\n    }\n\n    /**\n     * Creates an event whose {@code originalEvent} is {@code from}, with an optional `type` and `target` override.\n     *\n     * The event is allocated using {@link EventBoundary#allocateEvent this.allocateEvent}.\n     * @param from - The {@code originalEvent} for the returned event.\n     * @param [type=from.type] - The type of the returned event.\n     * @param target - The target of the returned event.\n     */\n    protected createPointerEvent(\n        from: FederatedPointerEvent,\n        type?: string,\n        target?: FederatedEventTarget\n    ): FederatedPointerEvent\n    {\n        const event = this.allocateEvent(FederatedPointerEvent);\n\n        this.copyPointerData(from, event);\n        this.copyMouseData(from, event);\n        this.copyData(from, event);\n\n        event.nativeEvent = from.nativeEvent;\n        event.originalEvent = from;\n        event.target = target\n            ?? this.hitTest(event.global.x, event.global.y) as FederatedEventTarget\n            ?? this._hitElements[0];\n\n        if (typeof type === 'string')\n        {\n            event.type = type;\n        }\n\n        return event;\n    }\n\n    /**\n     * Creates a wheel event whose {@code originalEvent} is {@code from}.\n     *\n     * The event is allocated using {@link EventBoundary#allocateEvent this.allocateEvent}.\n     * @param from - The upstream wheel event.\n     */\n    protected createWheelEvent(from: FederatedWheelEvent): FederatedWheelEvent\n    {\n        const event = this.allocateEvent(FederatedWheelEvent);\n\n        this.copyWheelData(from, event);\n        this.copyMouseData(from, event);\n        this.copyData(from, event);\n\n        event.nativeEvent = from.nativeEvent;\n        event.originalEvent = from;\n        event.target = this.hitTest(event.global.x, event.global.y);\n\n        return event;\n    }\n\n    /**\n     * Clones the event {@code from}, with an optional {@code type} override.\n     *\n     * The event is allocated using {@link EventBoundary#allocateEvent this.allocateEvent}.\n     * @param from - The event to clone.\n     * @param [type=from.type] - The type of the returned event.\n     */\n    protected clonePointerEvent(from: FederatedPointerEvent, type?: string): FederatedPointerEvent\n    {\n        const event = this.allocateEvent(FederatedPointerEvent);\n\n        event.nativeEvent = from.nativeEvent;\n        event.originalEvent = from.originalEvent;\n\n        this.copyPointerData(from, event);\n        this.copyMouseData(from, event);\n        this.copyData(from, event);\n\n        // copy propagation path for perf\n        event.target = from.target;\n        event.path = from.composedPath().slice();\n        event.type = type ?? event.type;\n\n        return event;\n    }\n\n    /**\n     * Copies wheel {@link FederatedWheelEvent} data from {@code from} into {@code to}.\n     *\n     * The following properties are copied:\n     * + deltaMode\n     * + deltaX\n     * + deltaY\n     * + deltaZ\n     * @param from - The event to copy data from.\n     * @param to - The event to copy data into.\n     */\n    protected copyWheelData(from: FederatedWheelEvent, to: FederatedWheelEvent): void\n    {\n        to.deltaMode = from.deltaMode;\n        to.deltaX = from.deltaX;\n        to.deltaY = from.deltaY;\n        to.deltaZ = from.deltaZ;\n    }\n\n    /**\n     * Copies pointer {@link FederatedPointerEvent} data from {@code from} into {@code to}.\n     *\n     * The following properties are copied:\n     * + pointerId\n     * + width\n     * + height\n     * + isPrimary\n     * + pointerType\n     * + pressure\n     * + tangentialPressure\n     * + tiltX\n     * + tiltY\n     * @param from - The event to copy data from.\n     * @param to - The event to copy data into.\n     */\n    protected copyPointerData(from: FederatedEvent, to: FederatedEvent): void\n    {\n        if (!(from instanceof FederatedPointerEvent && to instanceof FederatedPointerEvent)) return;\n\n        to.pointerId = from.pointerId;\n        to.width = from.width;\n        to.height = from.height;\n        to.isPrimary = from.isPrimary;\n        to.pointerType = from.pointerType;\n        to.pressure = from.pressure;\n        to.tangentialPressure = from.tangentialPressure;\n        to.tiltX = from.tiltX;\n        to.tiltY = from.tiltY;\n        to.twist = from.twist;\n    }\n\n    /**\n     * Copies mouse {@link FederatedMouseEvent} data from {@code from} to {@code to}.\n     *\n     * The following properties are copied:\n     * + altKey\n     * + button\n     * + buttons\n     * + clientX\n     * + clientY\n     * + metaKey\n     * + movementX\n     * + movementY\n     * + pageX\n     * + pageY\n     * + x\n     * + y\n     * + screen\n     * + shiftKey\n     * + global\n     * @param from - The event to copy data from.\n     * @param to - The event to copy data into.\n     */\n    protected copyMouseData(from: FederatedEvent, to: FederatedEvent): void\n    {\n        if (!(from instanceof FederatedMouseEvent && to instanceof FederatedMouseEvent)) return;\n\n        to.altKey = from.altKey;\n        to.button = from.button;\n        to.buttons = from.buttons;\n        to.client.copyFrom(from.client);\n        to.ctrlKey = from.ctrlKey;\n        to.metaKey = from.metaKey;\n        to.movement.copyFrom(from.movement);\n        to.screen.copyFrom(from.screen);\n        to.shiftKey = from.shiftKey;\n        to.global.copyFrom(from.global);\n    }\n\n    /**\n     * Copies base {@link FederatedEvent} data from {@code from} into {@code to}.\n     *\n     * The following properties are copied:\n     * + isTrusted\n     * + srcElement\n     * + timeStamp\n     * + type\n     * @param from - The event to copy data from.\n     * @param to - The event to copy data into.\n     */\n    protected copyData(from: FederatedEvent, to: FederatedEvent): void\n    {\n        to.isTrusted = from.isTrusted;\n        to.srcElement = from.srcElement;\n        to.timeStamp = performance.now();\n        to.type = from.type;\n        to.detail = from.detail;\n        to.view = from.view;\n        to.which = from.which;\n        to.layer.copyFrom(from.layer);\n        to.page.copyFrom(from.page);\n    }\n\n    /**\n     * @param id - The pointer ID.\n     * @returns The tracking data stored for the given pointer. If no data exists, a blank\n     *  state will be created.\n     */\n    protected trackingData(id: number): TrackingData\n    {\n        if (!this.mappingState.trackingData[id])\n        {\n            this.mappingState.trackingData[id] = {\n                pressTargetsByButton: {},\n                clicksByButton: {},\n                overTarget: null\n            };\n        }\n\n        return this.mappingState.trackingData[id];\n    }\n\n    /**\n     * Allocate a specific type of event from {@link EventBoundary#eventPool this.eventPool}.\n     *\n     * This allocation is constructor-agnostic, as long as it only takes one argument - this event\n     * boundary.\n     * @param constructor - The event's constructor.\n     */\n    protected allocateEvent<T extends FederatedEvent>(\n        constructor: { new(boundary: EventBoundary): T }\n    ): T\n    {\n        if (!this.eventPool.has(constructor as any))\n        {\n            this.eventPool.set(constructor as any, []);\n        }\n\n        const event = this.eventPool.get(constructor as any).pop() as T\n            || new constructor(this);\n\n        event.eventPhase = event.NONE;\n        event.currentTarget = null;\n        event.path = null;\n        event.target = null;\n\n        return event;\n    }\n\n    /**\n     * Frees the event and puts it back into the event pool.\n     *\n     * It is illegal to reuse the event until it is allocated again, using `this.allocateEvent`.\n     *\n     * It is also advised that events not allocated from {@link EventBoundary#allocateEvent this.allocateEvent}\n     * not be freed. This is because of the possibility that the same event is freed twice, which can cause\n     * it to be allocated twice & result in overwriting.\n     * @param event - The event to be freed.\n     * @throws Error if the event is managed by another event boundary.\n     */\n    protected freeEvent<T extends FederatedEvent>(event: T): void\n    {\n        if (event.manager !== this) throw new Error('It is illegal to free an event not managed by this EventBoundary!');\n\n        const constructor = event.constructor;\n\n        if (!this.eventPool.has(constructor as any))\n        {\n            this.eventPool.set(constructor as any, []);\n        }\n\n        this.eventPool.get(constructor as any).push(event);\n    }\n\n    /**\n     * Similar to {@link EventEmitter.emit}, except it stops if the `propagationImmediatelyStopped` flag\n     * is set on the event.\n     * @param e - The event to call each listener with.\n     * @param type - The event key.\n     */\n    private _notifyListeners(e: FederatedEvent, type: string): void\n    {\n        const listeners = ((e.currentTarget as any)._events as EmitterListeners)[type];\n\n        if (!listeners) return;\n        if (!e.currentTarget.isInteractive()) return;\n\n        if ('fn' in listeners)\n        {\n            if (listeners.once) e.currentTarget.removeListener(type, listeners.fn, undefined, true);\n            listeners.fn.call(listeners.context, e);\n        }\n        else\n        {\n            for (\n                let i = 0, j = listeners.length;\n                i < j && !e.propagationImmediatelyStopped;\n                i++)\n            {\n                if (listeners[i].once) e.currentTarget.removeListener(type, listeners[i].fn, undefined, true);\n                listeners[i].fn.call(listeners[i].context, e);\n            }\n        }\n    }\n}\n"],"names":["Point","warn","EventsTicker","FederatedPointerEvent","FederatedWheelEvent","FederatedMouseEvent"],"mappings":"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"}