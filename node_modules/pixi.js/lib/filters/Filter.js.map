{"version":3,"file":"Filter.js","sources":["../../src/filters/Filter.ts"],"sourcesContent":["import { GlProgram } from '../rendering/renderers/gl/shader/GlProgram';\nimport { GpuProgram } from '../rendering/renderers/gpu/shader/GpuProgram';\nimport { Shader } from '../rendering/renderers/shared/shader/Shader';\nimport { State } from '../rendering/renderers/shared/state/State';\n\nimport type { RenderSurface } from '../rendering/renderers/shared/renderTarget/RenderTargetSystem';\nimport type {\n    IShaderWithResources,\n    ShaderFromResources,\n    ShaderWithResources\n} from '../rendering/renderers/shared/shader/Shader';\nimport type { BLEND_MODES } from '../rendering/renderers/shared/state/const';\nimport type { Texture } from '../rendering/renderers/shared/texture/Texture';\nimport type { FilterSystem } from './FilterSystem';\n\n/**\n * Filters provide additional shading and post-processing effects to any display object and its children\n * they are attached to.\n *\n * You attached filters to a display object using its `filters` array property.\n *\n * ```js\n * import { Sprite, BlurFilter, HardMixBlend } from 'pixi.js';\n *\n * const sprite = Sprite.from('myTexture.png');\n *\n * // single filter\n * sprite.filters = new BlurFilter({ strength: 8 });\n *\n * // or multiple filters\n * sprite.filters = [new BlurFilter({ strength: 8 }), new HardMixBlend()];\n * ```\n *\n * Pixi has a number of built-in filters which can be used in your game or application:\n *\n * - {@link filters.AlphaFilter} - Applies alpha to the display object and any of its children.\n * - {@link filters.BlurFilter} - Applies a Gaussian blur to the display object.\n * - {@link filters.BlurFilterPass} - Applies a blur pass to an object.\n * - {@link filters.ColorBurnBlend} - Blend mode to add color burn to display objects.\n * - {@link filters.ColorDodgeBlend} - Blend mode to add color dodge to display objects.\n * - {@link filters.ColorMatrixFilter} - Transform the color channels by matrix multiplication.\n * - {@link filters.DarkenBlend} - Blend mode to darken display objects.\n * - {@link filters.DisplacementFilter} - Applies a displacement map to distort an object.\n * - {@link filters.DivideBlend} - Blend mode to divide display objects.\n * - {@link filters.HardMixBlend} - Blend mode to hard mix display objects.\n * - {@link filters.LinearBurnBlend} - Blend mode to add linear burn to display objects.\n * - {@link filters.LinearDodgeBlend} - Blend mode to add linear dodge to display objects.\n * - {@link filters.LinearLightBlend} - Blend mode to add linear light to display objects.\n * - {@link filters.NoiseFilter} - Applies random noise to an object.\n * - {@link filters.PinLightBlend} - Blend mode to add pin light to display objects.\n * - {@link filters.SubtractBlend} - Blend mode to subtract display objects.\n *\n * <br/>\n * For more available filters, check out the\n *  {@link https://pixijs.io/filters/docs/ pixi-filters} repository.\n *\n * You can also check out the awesome {@link https://pixijs.io/filters/examples/ Filter demo} to see\n * filters in action and combine them!\n * @namespace filters\n */\n\n/**\n * The options to use when creating a new filter.\n * @memberof filters\n */\nexport interface FilterOptions\n{\n    /** optional blend mode used by the filter when rendering (defaults to 'normal') */\n    blendMode?: BLEND_MODES;\n    /**\n     * the resolution the filter should be rendered at. The lower the resolution, the more performant\n     * the filter will be, but the lower the quality of the output. (defaults to the renderers resolution)\n     * Consider lowering this for things like blurs filters\n     */\n    resolution?: number;\n    /**\n     * the amount of pixels to pad the container with when applying the filter. For example a blur extends the\n     * container out as it blurs, so padding is applied to ensure that extra detail is rendered as well\n     * without clipping occurring. (default 0)\n     */\n    padding?: number;\n    /**\n     * If true the filter will make use of antialiasing. Although it looks better this can have a performance impact.\n     * By default, the filter will detect the antialiasing of the renderer and change this automatically.\n     * Definitely don't set this to true if the renderer has antialiasing set to false. As it will antialias,\n     * but you won't see the difference.\n     *\n     * This can be a boolean or [FilterAntialias]{@link filters.FilterAntialias} string.\n     */\n    antialias?: FilterAntialias | boolean;\n    /**\n     * If this is set to true, the filter system will grab a snap shot oif the are being rendered\n     * to and pass this into the shader. This is useful for blend modes that need to be aware of the pixels\n     * they are rendering to. Only use if you need that data, otherwise its an extra gpu copy you don't need!\n     * (default false)\n     */\n    blendRequired?: boolean;\n}\n\n/** Filter options mixed with shader resources. A filter needs a shader and some resources to work. */\nexport type FilterWithShader = FilterOptions & IShaderWithResources;\n\n/**\n * The antialiasing mode of the filter. This can be either:\n * - `on` - the filter is always antialiased regardless of the renderer settings\n * - `off` - the filter is never antialiased regardless of the renderer settings\n * - `inherit` - (default) the filter uses the antialias settings of the renderer\n * @memberof filters\n */\nexport type FilterAntialias = 'on' | 'off' | 'inherit';\n\n/**\n * The Filter class is the base for all filter effects used in Pixi.js\n * As it extends a shader, it requires that a glProgram is parsed in to work with WebGL and a gpuProgram for WebGPU.\n * If you don't proved one, then the filter is skipped and just rendered as if it wasn't there for that renderer.\n *\n * A filter can be applied to anything that extends Container in Pixi.js which also includes Sprites, Graphics etc.\n *\n * Its worth noting Performance-wise filters can be pretty expensive if used too much in a single scene.\n * The following happens under the hood when a filter is applied:\n *\n * .1. Break the current batch\n * <br>\n * .2. The target is measured using getGlobalBounds\n * (recursively go through all children and figure out how big the object is)\n * <br>\n * .3. Get the closest Po2 Textures from the texture pool\n * <br>\n * .4. Render the target to that texture\n * <br>\n * .5. Render that texture back to the main frame buffer as a quad using the filters program.\n * <br>\n * <br>\n * Some filters (such as blur) require multiple passes too which can result in an even bigger performance hit. So be careful!\n * Its not generally the complexity of the shader that is the bottle neck,\n * but all the framebuffer / shader switching that has to take place.\n * One filter applied to a container with many objects is MUCH faster than many filter applied to many objects.\n * @class\n * @memberof filters\n */\nexport class Filter extends Shader\n{\n    /**\n     * The default filter settings\n     * @static\n     */\n    public static readonly defaultOptions: FilterOptions = {\n        blendMode: 'normal',\n        resolution: 1,\n        padding: 0,\n        antialias: 'off',\n        blendRequired: false,\n    };\n\n    /**\n     * The padding of the filter. Some filters require extra space to breath such as a blur.\n     * Increasing this will add extra width and height to the bounds of the object that the\n     * filter is applied to.\n     * @default 0\n     */\n    public padding: number;\n\n    /**\n     * should the filter use antialiasing?\n     * @default inherit\n     */\n    public antialias: FilterAntialias;\n\n    /** If enabled is true the filter is applied, if false it will not. */\n    public enabled = true;\n\n    /**\n     * The gpu state the filter requires to render.\n     * @internal\n     * @ignore\n     */\n    public _state = State.for2d();\n\n    /**\n     * The resolution of the filter. Setting this to be lower will lower the quality but\n     * increase the performance of the filter.\n     * @default 1\n     */\n    public resolution: number;\n\n    /**\n     * Whether or not this filter requires the previous render texture for blending.\n     * @default false\n     */\n    public blendRequired: boolean;\n\n    /**\n     * @param options - The optional parameters of this filter.\n     */\n    constructor(options: FilterWithShader)\n    {\n        options = { ...Filter.defaultOptions, ...options };\n\n        super(options as ShaderWithResources);\n\n        this.padding = options.padding;\n\n        // check if is boolean\n        if (typeof options.antialias === 'boolean')\n        {\n            this.antialias = options.antialias ? 'on' : 'off';\n        }\n        else\n        {\n            this.antialias = options.antialias;\n        }\n\n        this.resolution = options.resolution;\n        this.blendRequired = options.blendRequired;\n\n        this.addResource('uTexture', 0, 1);\n    }\n\n    /**\n     * Applies the filter\n     * @param filterManager - The renderer to retrieve the filter from\n     * @param input - The input render target.\n     * @param output - The target to output to.\n     * @param clearMode - Should the output be cleared before rendering to it\n     */\n    public apply(\n        filterManager: FilterSystem,\n        input: Texture,\n        output: RenderSurface,\n        clearMode: boolean\n    ): void\n    {\n        filterManager.applyFilter(this, input, output, clearMode);\n    }\n\n    /**\n     * Get the blend mode of the filter.\n     * @default \"normal\"\n     */\n    get blendMode(): BLEND_MODES\n    {\n        return this._state.blendMode;\n    }\n\n    /** Sets the blend mode of the filter. */\n    set blendMode(value: BLEND_MODES)\n    {\n        this._state.blendMode = value;\n    }\n\n    /**\n     * A short hand function to create a filter based of a vertex and fragment shader src.\n     * @param options\n     * @returns A shiny new PixiJS filter!\n     */\n    public static from(options: FilterOptions & ShaderFromResources): Filter\n    {\n        const { gpu, gl, ...rest } = options;\n\n        let gpuProgram: GpuProgram;\n        let glProgram: GlProgram;\n\n        if (gpu)\n        {\n            gpuProgram = GpuProgram.from(gpu);\n        }\n\n        if (gl)\n        {\n            glProgram = GlProgram.from(gl);\n        }\n\n        return new Filter({\n            gpuProgram,\n            glProgram,\n            ...rest\n        });\n    }\n}\n"],"names":["Shader","State","GpuProgram","GlProgram"],"mappings":";;;;;;;;AA4IO,MAAM,OAAA,GAAN,MAAM,OAAA,SAAeA,aAC5B,CAAA;AAAA;AAAA;AAAA;AAAA,EAqDI,YAAY,OACZ,EAAA;AACI,IAAA,OAAA,GAAU,EAAE,GAAG,OAAO,CAAA,cAAA,EAAgB,GAAG,OAAQ,EAAA,CAAA;AAEjD,IAAA,KAAA,CAAM,OAA8B,CAAA,CAAA;AA7BxC;AAAA,IAAA,IAAA,CAAO,OAAU,GAAA,IAAA,CAAA;AAOjB;AAAA;AAAA;AAAA;AAAA;AAAA,IAAO,IAAA,CAAA,MAAA,GAASC,YAAM,KAAM,EAAA,CAAA;AAwBxB,IAAA,IAAA,CAAK,UAAU,OAAQ,CAAA,OAAA,CAAA;AAGvB,IAAI,IAAA,OAAO,OAAQ,CAAA,SAAA,KAAc,SACjC,EAAA;AACI,MAAK,IAAA,CAAA,SAAA,GAAY,OAAQ,CAAA,SAAA,GAAY,IAAO,GAAA,KAAA,CAAA;AAAA,KAGhD,MAAA;AACI,MAAA,IAAA,CAAK,YAAY,OAAQ,CAAA,SAAA,CAAA;AAAA,KAC7B;AAEA,IAAA,IAAA,CAAK,aAAa,OAAQ,CAAA,UAAA,CAAA;AAC1B,IAAA,IAAA,CAAK,gBAAgB,OAAQ,CAAA,aAAA,CAAA;AAE7B,IAAK,IAAA,CAAA,WAAA,CAAY,UAAY,EAAA,CAAA,EAAG,CAAC,CAAA,CAAA;AAAA,GACrC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASO,KACH,CAAA,aAAA,EACA,KACA,EAAA,MAAA,EACA,SAEJ,EAAA;AACI,IAAA,aAAA,CAAc,WAAY,CAAA,IAAA,EAAM,KAAO,EAAA,MAAA,EAAQ,SAAS,CAAA,CAAA;AAAA,GAC5D;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,IAAI,SACJ,GAAA;AACI,IAAA,OAAO,KAAK,MAAO,CAAA,SAAA,CAAA;AAAA,GACvB;AAAA;AAAA,EAGA,IAAI,UAAU,KACd,EAAA;AACI,IAAA,IAAA,CAAK,OAAO,SAAY,GAAA,KAAA,CAAA;AAAA,GAC5B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,OAAc,KAAK,OACnB,EAAA;AACI,IAAA,MAAM,EAAE,GAAA,EAAK,EAAI,EAAA,GAAG,MAAS,GAAA,OAAA,CAAA;AAE7B,IAAI,IAAA,UAAA,CAAA;AACJ,IAAI,IAAA,SAAA,CAAA;AAEJ,IAAA,IAAI,GACJ,EAAA;AACI,MAAa,UAAA,GAAAC,qBAAA,CAAW,KAAK,GAAG,CAAA,CAAA;AAAA,KACpC;AAEA,IAAA,IAAI,EACJ,EAAA;AACI,MAAY,SAAA,GAAAC,mBAAA,CAAU,KAAK,EAAE,CAAA,CAAA;AAAA,KACjC;AAEA,IAAA,OAAO,IAAI,OAAO,CAAA;AAAA,MACd,UAAA;AAAA,MACA,SAAA;AAAA,MACA,GAAG,IAAA;AAAA,KACN,CAAA,CAAA;AAAA,GACL;AACJ,CAAA,CAAA;AAAA;AAAA;AAAA;AAAA;AA1Ia,OAAA,CAMc,cAAgC,GAAA;AAAA,EACnD,SAAW,EAAA,QAAA;AAAA,EACX,UAAY,EAAA,CAAA;AAAA,EACZ,OAAS,EAAA,CAAA;AAAA,EACT,SAAW,EAAA,KAAA;AAAA,EACX,aAAe,EAAA,KAAA;AACnB,CAAA,CAAA;AAZG,IAAM,MAAN,GAAA;;;;"}