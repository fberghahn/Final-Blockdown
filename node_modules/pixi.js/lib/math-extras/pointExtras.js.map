{"version":3,"file":"pointExtras.js","sources":["../../src/math-extras/pointExtras.ts"],"sourcesContent":["import { Point } from '../maths/point/Point';\n\nimport type { PointData } from '../maths/point/PointData';\n\nexport const pointExtraMixins: any = {\n    /**\n     * Adds `other` to `this` point and outputs into `outPoint` or a new Point.\n     *\n     * _Note: Only available with **pixi.js/math-extras**._\n     * @method add\n     * @memberof maths.Point#\n     * @param {maths.PointData} other - The point to add to `this`.\n     * @param {maths.PointData} [outPoint] - A Point-like object in which to store the value,\n     * optional (otherwise will create a new Point).\n     * @returns {PointData} The `outPoint` reference or a new Point, with the result of the addition.\n     */\n    /**\n     * Adds `other` to `this` point and outputs into `outPoint` or a new Point.\n     *\n     * _Note: Only available with **pixi.js/math-extras**._\n     * @method add\n     * @memberof maths.ObservablePoint#\n     * @param {maths.PointData} other - The point to add to `this`.\n     * @param {maths.PointData} [outPoint] - A Point-like object in which to store the value,\n     * optional (otherwise will create a new Point).\n     * @returns {PointData} The `outPoint` reference or a new Point, with the result of the addition.\n     */\n    add<T extends PointData>(other: PointData, outPoint?: T): T\n    {\n        if (!outPoint)\n        {\n            outPoint = new Point() as PointData as T;\n        }\n        outPoint.x = this.x + other.x;\n        outPoint.y = this.y + other.y;\n\n        return outPoint;\n    },\n\n    /**\n     * Subtracts `other` from `this` point and outputs into `outPoint` or a new Point.\n     *\n     * _Note: Only available with **pixi.js/math-extras**._\n     * @method subtract\n     * @memberof maths.Point#\n     * @param {maths.PointData} other - The point to subtract to `this`.\n     * @param {maths.PointData} [outPoint] - A Point-like object in which to store the value,\n     * optional (otherwise will create a new Point).\n     * @returns {PointData} The `outPoint` reference or a new Point, with the result of the subtraction.\n     */\n    /**\n     * Subtracts `other` from `this` point and outputs into `outPoint` or a new Point.\n     *\n     * _Note: Only available with **pixi.js/math-extras**._\n     * @method subtract\n     * @memberof maths.ObservablePoint#\n     * @param {maths.PointData} other - The point to subtract to `this`.\n     * @param {maths.PointData} [outPoint] - A Point-like object in which to store the value,\n     * optional (otherwise will create a new Point).\n     * @returns {PointData} The `outPoint` reference or a new Point, with the result of the subtraction.\n     */\n    subtract<T extends PointData>(other: PointData, outPoint?: T): T\n    {\n        if (!outPoint)\n        {\n            outPoint = new Point() as PointData as T;\n        }\n        outPoint.x = this.x - other.x;\n        outPoint.y = this.y - other.y;\n\n        return outPoint;\n    },\n\n    /**\n     * Multiplies component-wise `other` and `this` points and outputs into `outPoint` or a new Point.\n     *\n     * _Note: Only available with **pixi.js/math-extras**._\n     * @method multiply\n     * @memberof maths.Point#\n     * @param {maths.PointData} other - The point to multiply with `this`.\n     * @param {maths.PointData} [outPoint] - A Point-like object in which to store the value,\n     * optional (otherwise will create a new Point).\n     * @returns {PointData} The `outPoint` reference or a new Point, with the component-wise multiplication.\n     */\n    /**\n     * Multiplies component-wise `other` and `this` points and outputs into `outPoint` or a new Point.\n     *\n     * _Note: Only available with **pixi.js/math-extras**._\n     * @method multiply\n     * @memberof maths.ObservablePoint#\n     * @param {maths.PointData} other - The point to multiply with `this`.\n     * @param {maths.PointData} [outPoint] - A Point-like object in which to store the value,\n     * optional (otherwise will create a new Point).\n     * @returns {PointData} The `outPoint` reference or a new Point, with the component-wise multiplication.\n     */\n    multiply<T extends PointData>(other: PointData, outPoint?: T): T\n    {\n        if (!outPoint)\n        {\n            outPoint = new Point() as PointData as T;\n        }\n        outPoint.x = this.x * other.x;\n        outPoint.y = this.y * other.y;\n\n        return outPoint;\n    },\n\n    /**\n     * Multiplies each component of `this` point with the number `scalar` and outputs into `outPoint` or a new Point.\n     *\n     * _Note: Only available with **pixi.js/math-extras**._\n     * @method multiplyScalar\n     * @memberof maths.Point#\n     * @param {number} scalar - The number to multiply both components of `this`.\n     * @param {maths.PointData} [outPoint] - A Point-like object in which to store the value,\n     * optional (otherwise will create a new Point).\n     * @returns {PointData} The `outPoint` reference or a new Point, with the multiplication.\n     */\n    /**\n     * Multiplies each component of `this` point with the number `scalar` and outputs into `outPoint` or a new Point.\n     *\n     * _Note: Only available with **pixi.js/math-extras**._\n     * @method multiplyScalar\n     * @memberof maths.ObservablePoint#\n     * @param {number} scalar - The number to multiply both components of `this`.\n     * @param {maths.PointData} [outPoint] - A Point-like object in which to store the value,\n     * optional (otherwise will create a new Point).\n     * @returns {PointData} The `outPoint` reference or a new Point, with the multiplication.\n     */\n    multiplyScalar<T extends PointData>(scalar: number, outPoint?: T): T\n    {\n        if (!outPoint)\n        {\n            outPoint = new Point() as PointData as T;\n        }\n        outPoint.x = this.x * scalar;\n        outPoint.y = this.y * scalar;\n\n        return outPoint;\n    },\n\n    /**\n     * Computes the dot product of `other` with `this` point.\n     * The dot product is the sum of the products of the corresponding components of two vectors.\n     *\n     * _Note: Only available with **pixi.js/math-extras**._\n     * @method dot\n     * @memberof maths.Point#\n     * @param {maths.PointData} other - The other point to calculate the dot product with `this`.\n     * @returns {number} The result of the dot product. This is an scalar value.\n     */\n    /**\n     * Computes the dot product of `other` with `this` point.\n     * The dot product is the sum of the products of the corresponding components of two vectors.\n     *\n     * _Note: Only available with **pixi.js/math-extras**._\n     * @method dot\n     * @memberof maths.ObservablePoint#\n     * @param {maths.PointData} other - The other point to calculate the dot product with `this`.\n     * @returns {number} The result of the dot product. This is an scalar value.\n     */\n    dot(other: PointData): number\n    {\n        return (this.x * other.x) + (this.y * other.y);\n    },\n\n    /**\n     * Computes the cross product of `other` with `this` point.\n     * Given two linearly independent R3 vectors a and b, the cross product, a × b (read \"a cross b\"),\n     * is a vector that is perpendicular to both a and b, and thus normal to the plane containing them.\n     * While cross product only exists on 3D space, we can assume the z component of 2D to be zero and\n     * the result becomes a vector that will only have magnitude on the z axis.\n     *\n     * This function returns the z component of the cross product of the two points.\n     *\n     * _Note: Only available with **pixi.js/math-extras**._\n     * @method cross\n     * @memberof maths.Point#\n     * @param {maths.PointData} other - The other point to calculate the cross product with `this`.\n     * @returns {number} The z component of the result of the cross product.\n     */\n    /**\n     * Computes the cross product of `other` with `this` point.\n     * Given two linearly independent R3 vectors a and b, the cross product, a × b (read \"a cross b\"),\n     * is a vector that is perpendicular to both a and b, and thus normal to the plane containing them.\n     * While cross product only exists on 3D space, we can assume the z component of 2D to be zero and\n     * the result becomes a vector that will only have magnitude on the z axis.\n     *\n     * This function returns the z component of the cross product of the two points.\n     *\n     * _Note: Only available with **pixi.js/math-extras**._\n     * @method cross\n     * @memberof maths.ObservablePoint#\n     * @param {maths.PointData} other - The other point to calculate the cross product with `this`.\n     * @returns {number} The z component of the result of the cross product.\n     */\n    cross(other: PointData): number\n    {\n        /*\n         * Returns the magnitude of the vector that would result\n         * from a regular 3D cross product of the input vectors,\n         * taking their Z values implicitly as 0\n         * (i.e. treating the 2D space as a plane in the 3D space).\n         * The 3D cross product will be perpendicular to that plane,\n         * and thus have 0 X & Y components\n         * (thus the scalar returned is the Z value of the 3D cross product vector).\n         */\n        return (this.x * other.y) - (this.y * other.x);\n    },\n\n    /**\n     * Computes a normalized version of `this` point.\n     *\n     * A normalized vector is a vector of magnitude (length) 1\n     *\n     * _Note: Only available with **pixi.js/math-extras**._\n     * @method normalize\n     * @memberof maths.Point#\n     * @param {maths.PointData} [outPoint] - A Point-like object in which to store the value,\n     * optional (otherwise will create a new Point).\n     * @returns {PointData} The normalized point.\n     */\n    /**\n     * Computes a normalized version of `this` point.\n     *\n     * A normalized vector is a vector of magnitude (length) 1\n     *\n     * _Note: Only available with **pixi.js/math-extras**._\n     * @method normalize\n     * @memberof maths.ObservablePoint#\n     * @param {maths.PointData} [outPoint] - A Point-like object in which to store the value,\n     * optional (otherwise will create a new Point).\n     * @returns {PointData} The normalized point.\n     */\n    normalize<T extends PointData>(outPoint?: T): T\n    {\n        if (!outPoint)\n        {\n            outPoint = new Point() as PointData as T;\n        }\n        const magnitude = Math.sqrt((this.x * this.x) + (this.y * this.y));\n\n        outPoint.x = this.x / magnitude;\n        outPoint.y = this.y / magnitude;\n\n        return outPoint;\n    },\n\n    /**\n     * Computes the magnitude of this point (Euclidean distance from 0, 0).\n     *\n     * Defined as the square root of the sum of the squares of each component.\n     *\n     * _Note: Only available with **pixi.js/math-extras**._\n     * @method magnitude\n     * @memberof maths.Point#\n     * @returns {number} The magnitude (length) of the vector.\n     */\n    /**\n     * Computes the magnitude of this point (Euclidean distance from 0, 0).\n     *\n     * Defined as the square root of the sum of the squares of each component.\n     *\n     * _Note: Only available with **pixi.js/math-extras**._\n     * @method magnitude\n     * @memberof maths.ObservablePoint#\n     * @returns {number} The magnitude (length) of the vector.\n     */\n    magnitude(): number\n    {\n        return Math.sqrt((this.x * this.x) + (this.y * this.y));\n    },\n\n    /**\n     * Computes the square magnitude of this point.\n     * If you are comparing the lengths of vectors, you should compare the length squared instead\n     * as it is slightly more efficient to calculate.\n     *\n     * Defined as the sum of the squares of each component.\n     *\n     * _Note: Only available with **pixi.js/math-extras**._\n     * @method magnitudeSquared\n     * @memberof maths.Point#\n     * @returns {number} The magnitude squared (length squared) of the vector.\n     */\n    /**\n     * Computes the square magnitude of this point.\n     * If you are comparing the lengths of vectors, you should compare the length squared instead\n     * as it is slightly more efficient to calculate.\n     *\n     * Defined as the sum of the squares of each component.\n     *\n     * _Note: Only available with **pixi.js/math-extras**._\n     * @method magnitudeSquared\n     * @memberof maths.ObservablePoint#\n     * @returns {number} The magnitude squared (length squared) of the vector.\n     */\n    magnitudeSquared(): number\n    {\n        return (this.x * this.x) + (this.y * this.y);\n    },\n\n    /**\n     * Computes vector projection of `this` on `onto`.\n     *\n     * Imagine a light source, parallel to `onto`, above `this`.\n     * The light would cast rays perpendicular to `onto`.\n     * `this.project(onto)` is the shadow cast by `this` on the line defined by `onto` .\n     *\n     * _Note: Only available with **pixi.js/math-extras**._\n     * @method project\n     * @memberof maths.Point#\n     * @param {maths.PointData} onto - A non zero vector describing a line on which to project `this`.\n     * @param {maths.PointData} [outPoint] - A Point-like object in which to store the value,\n     * optional (otherwise will create a new Point).\n     * @returns {PointData} The `this` on `onto` projection.\n     */\n    /**\n     * Computes vector projection of `this` on `onto`.\n     *\n     * Imagine a light source, parallel to `onto`, above `this`.\n     * The light would cast rays perpendicular to `onto`.\n     * `this.project(onto)` is the shadow cast by `this` on the line defined by `onto` .\n     *\n     * _Note: Only available with **pixi.js/math-extras**._\n     * @method project\n     * @memberof maths.ObservablePoint#\n     * @param {maths.PointData} onto - A non zero vector describing a line on which to project `this`.\n     * @param {maths.PointData} [outPoint] - A Point-like object in which to store the value,\n     * optional (otherwise will create a new Point).\n     * @returns {PointData} The `this` on `onto` projection.\n     */\n    project<T extends PointData>(onto: PointData, outPoint?: T): T\n    {\n        if (!outPoint)\n        {\n            outPoint = new Point() as PointData as T;\n        }\n        // Math says: a Projected over b = [(a·b) / (b·b)] * b;\n        const normalizedScalarProjection = ((this.x * onto.x) + (this.y * onto.y)) / ((onto.x * onto.x) + (onto.y * onto.y));\n\n        outPoint.x = onto.x * normalizedScalarProjection;\n        outPoint.y = onto.y * normalizedScalarProjection;\n\n        return outPoint;\n    },\n\n    /**\n     * Reflects `this` vector off of a plane orthogonal to `normal`.\n     * `normal` is not normalized during this process. Consider normalizing your `normal` before use.\n     *\n     * Imagine a light source bouncing onto a mirror.\n     * `this` vector is the light and `normal` is a vector perpendicular to the mirror.\n     * `this.reflect(normal)` is the reflection of `this` on that mirror.\n     *\n     * _Note: Only available with **pixi.js/math-extras**._\n     * @method reflect\n     * @memberof maths.Point#\n     * @param {maths.PointData} normal - The normal vector of your reflecting plane.\n     * @param {maths.PointData} [outPoint] - A Point-like object in which to store the value,\n     * optional (otherwise will create a new Point).\n     * @returns {PointData} The reflection of `this` on your reflecting plane.\n     */\n    /**\n     * Reflects `this` vector off of a plane orthogonal to `normal`.\n     * `normal` is not normalized during this process. Consider normalizing your `normal` before use.\n     *\n     * Imagine a light source bouncing onto a mirror.\n     * `this` vector is the light and `normal` is a vector perpendicular to the mirror.\n     * `this.reflect(normal)` is the reflection of `this` on that mirror.\n     *\n     * _Note: Only available with **pixi.js/math-extras**._\n     * @method reflect\n     * @memberof maths.ObservablePoint#\n     * @param {maths.PointData} normal - The normal vector of your reflecting plane.\n     * @param {maths.PointData} [outPoint] - A Point-like object in which to store the value,\n     * optional (otherwise will create a new Point).\n     * @returns {PointData} The reflection of `this` on your reflecting plane.\n     */\n    reflect<T extends PointData>(normal: PointData, outPoint?: T): T\n    {\n        if (!outPoint)\n        {\n            outPoint = new Point() as PointData as T;\n        }\n\n        // Given an incident vector i and a normal vector n, returns the reflection vector r = i - 2 * dot(i, n) * n\n\n        const dotProduct = (this.x * normal.x) + (this.y * normal.y);\n\n        outPoint.x = this.x - (2 * dotProduct * normal.x);\n        outPoint.y = this.y - (2 * dotProduct * normal.y);\n\n        return outPoint;\n    }\n};\n"],"names":["Point"],"mappings":"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"}