{"version":3,"file":"Batcher.mjs","sources":["../../../../src/rendering/batcher/shared/Batcher.ts"],"sourcesContent":["import { uid } from '../../../utils/data/uid';\nimport { ViewableBuffer } from '../../../utils/data/ViewableBuffer';\nimport { fastCopy } from '../../renderers/shared/buffer/utils/fastCopy';\nimport { type BLEND_MODES } from '../../renderers/shared/state/const';\nimport { getAdjustedBlendModeBlend } from '../../renderers/shared/state/getAdjustedBlendModeBlend';\nimport { BatchTextureArray } from './BatchTextureArray';\nimport { MAX_TEXTURES } from './const';\n\nimport type { BindGroup } from '../../renderers/gpu/shader/BindGroup';\nimport type { IndexBufferArray } from '../../renderers/shared/geometry/Geometry';\nimport type { Instruction } from '../../renderers/shared/instructions/Instruction';\nimport type { InstructionSet } from '../../renderers/shared/instructions/InstructionSet';\nimport type { Texture } from '../../renderers/shared/texture/Texture';\n\nexport type BatchAction = 'startBatch' | 'renderBatch';\n\n/**\n * A batch pool is used to store batches when they are not currently in use.\n * @memberof rendering\n */\nexport class Batch implements Instruction\n{\n    public renderPipeId = 'batch';\n    public action: BatchAction = 'startBatch';\n\n    // TODO - eventually this could be useful for flagging batches as dirty and then only rebuilding those ones\n    // public elementStart = 0;\n    // public elementSize = 0;\n\n    // for drawing..\n    public start = 0;\n    public size = 0;\n    public textures: BatchTextureArray;\n\n    public blendMode: BLEND_MODES = 'normal';\n\n    public canBundle = true;\n\n    /**\n     * breaking rules slightly here in the name of performance..\n     * storing references to these bindgroups here is just faster for access!\n     * keeps a reference to the GPU bind group to set when rendering this batch for WebGPU. Will be null is using WebGL.\n     */\n    public gpuBindGroup: GPUBindGroup;\n    /**\n     * breaking rules slightly here in the name of performance..\n     * storing references to these bindgroups here is just faster for access!\n     * keeps a reference to the bind group to set when rendering this batch for WebGPU. Will be null if using WebGl.\n     */\n    public bindGroup: BindGroup;\n\n    public batcher: Batcher;\n\n    public destroy()\n    {\n        this.textures = null;\n        this.gpuBindGroup = null;\n        this.bindGroup = null;\n        this.batcher = null;\n    }\n}\n\nexport interface BatchableObject\n{\n    indexStart: number;\n\n    packAttributes: (\n        float32View: Float32Array,\n        uint32View: Uint32Array,\n        index: number,\n        textureId: number,\n    ) => void;\n    packIndex: (indexBuffer: IndexBufferArray, index: number, indicesOffset: number) => void;\n\n    texture: Texture;\n    blendMode: BLEND_MODES;\n    vertexSize: number;\n    indexSize: number;\n\n    // stored for efficient updating..\n    textureId: number;\n    location: number; // location in the buffer\n    batcher: Batcher;\n    batch: Batch;\n\n    roundPixels: 0 | 1;\n}\n\nlet BATCH_TICK = 0;\n\n/**\n * The options for the batcher.\n * @ignore\n */\nexport interface BatcherOptions\n{\n    /** The size of the vertex buffer. */\n    vertexSize?: number;\n    /** The size of the index buffer. */\n    indexSize?: number;\n}\n\n/**\n * A batcher is used to batch together objects with the same texture.\n * @ignore\n */\nexport class Batcher\n{\n    public static defaultOptions: BatcherOptions = {\n        vertexSize: 4,\n        indexSize: 6,\n    };\n\n    public uid = uid('batcher');\n    public attributeBuffer: ViewableBuffer;\n    public indexBuffer: IndexBufferArray;\n\n    public attributeSize: number;\n    public indexSize: number;\n    public elementSize: number;\n    public elementStart: number;\n\n    public dirty = true;\n\n    public batchIndex = 0;\n    public batches: Batch[] = [];\n\n    // specifics.\n    private readonly _vertexSize: number = 6;\n\n    private _elements: BatchableObject[] = [];\n\n    private readonly _batchPool: Batch[] = [];\n    private _batchPoolIndex = 0;\n    private readonly _textureBatchPool: BatchTextureArray[] = [];\n    private _textureBatchPoolIndex = 0;\n    private _batchIndexStart: number;\n    private _batchIndexSize: number;\n\n    constructor(options: BatcherOptions = {})\n    {\n        options = { ...Batcher.defaultOptions, ...options };\n\n        const { vertexSize, indexSize } = options;\n\n        this.attributeBuffer = new ViewableBuffer(vertexSize * this._vertexSize * 4);\n\n        this.indexBuffer = new Uint16Array(indexSize);\n    }\n\n    public begin()\n    {\n        this.batchIndex = 0;\n        this.elementSize = 0;\n        this.elementStart = 0;\n        this.indexSize = 0;\n        this.attributeSize = 0;\n        this._batchPoolIndex = 0;\n        this._textureBatchPoolIndex = 0;\n        this._batchIndexStart = 0;\n        this._batchIndexSize = 0;\n\n        this.dirty = true;\n    }\n\n    public add(batchableObject: BatchableObject)\n    {\n        this._elements[this.elementSize++] = batchableObject;\n\n        batchableObject.indexStart = this.indexSize;\n        batchableObject.location = this.attributeSize;\n        batchableObject.batcher = this;\n\n        this.indexSize += batchableObject.indexSize;\n        this.attributeSize += ((batchableObject.vertexSize) * this._vertexSize);\n    }\n\n    public checkAndUpdateTexture(batchableObject: BatchableObject, texture: Texture): boolean\n    {\n        const textureId = batchableObject.batch.textures.ids[texture._source.uid];\n\n        // TODO could try to be a bit smarter if there are spare textures..\n        // but need to figure out how to alter the bind groups too..\n        if (!textureId && textureId !== 0) return false;\n\n        batchableObject.textureId = textureId;\n        batchableObject.texture = texture;\n\n        return true;\n    }\n\n    public updateElement(batchableObject: BatchableObject)\n    {\n        this.dirty = true;\n\n        batchableObject.packAttributes(\n            this.attributeBuffer.float32View,\n            this.attributeBuffer.uint32View,\n            batchableObject.location, batchableObject.textureId);\n    }\n\n    /**\n     * breaks the batcher. This happens when a batch gets too big,\n     * or we need to switch to a different type of rendering (a filter for example)\n     * @param instructionSet\n     */\n    public break(instructionSet: InstructionSet)\n    {\n        // ++BATCH_TICK;\n        const elements = this._elements;\n\n        let textureBatch = this._textureBatchPool[this._textureBatchPoolIndex++] || new BatchTextureArray();\n\n        textureBatch.clear();\n\n        // length 0??!! (we broke without ading anything)\n        if (!elements[this.elementStart]) return;\n\n        const firstElement = elements[this.elementStart];\n        let blendMode = getAdjustedBlendModeBlend(firstElement.blendMode, firstElement.texture._source);\n\n        if (this.attributeSize * 4 > this.attributeBuffer.size)\n        {\n            this._resizeAttributeBuffer(this.attributeSize * 4);\n        }\n\n        if (this.indexSize > this.indexBuffer.length)\n        {\n            this._resizeIndexBuffer(this.indexSize);\n        }\n\n        const f32 = this.attributeBuffer.float32View;\n        const u32 = this.attributeBuffer.uint32View;\n        const iBuffer = this.indexBuffer;\n\n        let size = this._batchIndexSize;\n        let start = this._batchIndexStart;\n\n        let action: BatchAction = 'startBatch';\n        let batch = this._batchPool[this._batchPoolIndex++] || new Batch();\n\n        for (let i = this.elementStart; i < this.elementSize; ++i)\n        {\n            const element = elements[i];\n\n            elements[i] = null;\n\n            const texture = element.texture;\n            const source = texture._source;\n\n            const adjustedBlendMode = getAdjustedBlendModeBlend(element.blendMode, source);\n\n            const blendModeChange = blendMode !== adjustedBlendMode;\n\n            if (source._batchTick === BATCH_TICK && !blendModeChange)\n            {\n                element.textureId = source._textureBindLocation;\n\n                size += element.indexSize;\n                element.packAttributes(f32, u32, element.location, element.textureId);\n                element.packIndex(iBuffer, element.indexStart, element.location / this._vertexSize);\n\n                element.batch = batch;\n\n                continue;\n            }\n\n            source._batchTick = BATCH_TICK;\n\n            if (textureBatch.count >= MAX_TEXTURES || blendModeChange)\n            {\n                this._finishBatch(\n                    batch,\n                    start,\n                    size - start,\n                    textureBatch,\n                    blendMode,\n                    instructionSet,\n                    action\n                );\n\n                action = 'renderBatch';\n                start = size;\n                // create a batch...\n                blendMode = adjustedBlendMode;\n\n                textureBatch = this._textureBatchPool[this._textureBatchPoolIndex++] || new BatchTextureArray();\n                textureBatch.clear();\n\n                batch = this._batchPool[this._batchPoolIndex++] || new Batch();\n                ++BATCH_TICK;\n            }\n\n            element.textureId = source._textureBindLocation = textureBatch.count;\n            textureBatch.ids[source.uid] = textureBatch.count;\n            textureBatch.textures[textureBatch.count++] = source;\n            element.batch = batch;\n\n            size += element.indexSize;\n            element.packAttributes(f32, u32, element.location, element.textureId);\n            element.packIndex(iBuffer, element.indexStart, element.location / this._vertexSize);\n        }\n\n        if (textureBatch.count > 0)\n        {\n            this._finishBatch(\n                batch,\n                start,\n                size - start,\n                textureBatch,\n                blendMode,\n                instructionSet,\n                action\n            );\n\n            start = size;\n            ++BATCH_TICK;\n        }\n\n        this.elementStart = this.elementSize;\n        this._batchIndexStart = start;\n        this._batchIndexSize = size;\n    }\n\n    private _finishBatch(\n        batch: Batch,\n        indexStart: number,\n        indexSize: number,\n        textureBatch: BatchTextureArray,\n        blendMode: BLEND_MODES,\n        instructionSet: InstructionSet,\n        action: BatchAction\n    )\n    {\n        batch.gpuBindGroup = null;\n        batch.action = action;\n\n        batch.batcher = this;\n        batch.textures = textureBatch;\n        batch.blendMode = blendMode;\n\n        batch.start = indexStart;\n        batch.size = indexSize;\n\n        ++BATCH_TICK;\n\n        instructionSet.add(batch);\n    }\n\n    public finish(instructionSet: InstructionSet)\n    {\n        this.break(instructionSet);\n    }\n\n    /**\n     * Resizes the attribute buffer to the given size (1 = 1 float32)\n     * @param size - the size in vertices to ensure (not bytes!)\n     */\n    public ensureAttributeBuffer(size: number)\n    {\n        if (size * 4 <= this.attributeBuffer.size) return;\n\n        this._resizeAttributeBuffer(size * 4);\n    }\n\n    /**\n     * Resizes the index buffer to the given size (1 = 1 float32)\n     * @param size - the size in vertices to ensure (not bytes!)\n     */\n    public ensureIndexBuffer(size: number)\n    {\n        if (size <= this.indexBuffer.length) return;\n\n        this._resizeIndexBuffer(size);\n    }\n\n    private _resizeAttributeBuffer(size: number)\n    {\n        const newSize = Math.max(size, this.attributeBuffer.size * 2);\n\n        const newArrayBuffer = new ViewableBuffer(newSize);\n\n        fastCopy(this.attributeBuffer.rawBinaryData, newArrayBuffer.rawBinaryData);\n\n        this.attributeBuffer = newArrayBuffer;\n    }\n\n    private _resizeIndexBuffer(size: number)\n    {\n        const indexBuffer = this.indexBuffer;\n\n        let newSize = Math.max(size, indexBuffer.length * 1.5);\n\n        newSize += newSize % 2;\n\n        // this, is technically not 100% accurate, as really we should\n        // be checking the maximum value in the buffer. This approximation\n        // does the trick though...\n\n        // make sure buffer is always an even number..\n        const newIndexBuffer = (newSize > 65535) ? new Uint32Array(newSize) : new Uint16Array(newSize);\n\n        if (newIndexBuffer.BYTES_PER_ELEMENT !== indexBuffer.BYTES_PER_ELEMENT)\n        {\n            for (let i = 0; i < indexBuffer.length; i++)\n            {\n                newIndexBuffer[i] = indexBuffer[i];\n            }\n        }\n        else\n        {\n            fastCopy(indexBuffer.buffer, newIndexBuffer.buffer);\n        }\n\n        this.indexBuffer = newIndexBuffer;\n    }\n\n    public destroy()\n    {\n        for (let i = 0; i < this.batches.length; i++)\n        {\n            this.batches[i].destroy();\n        }\n\n        this.batches = null;\n\n        for (let i = 0; i < this._elements.length; i++)\n        {\n            this._elements[i].batch = null;\n        }\n\n        this._elements = null;\n\n        this.indexBuffer = null;\n\n        this.attributeBuffer.destroy();\n        this.attributeBuffer = null;\n    }\n}\n\n"],"names":[],"mappings":";;;;;;;;AAoBO,MAAM,KACb,CAAA;AAAA,EADO,WAAA,GAAA;AAEH,IAAA,IAAA,CAAO,YAAe,GAAA,OAAA,CAAA;AACtB,IAAA,IAAA,CAAO,MAAsB,GAAA,YAAA,CAAA;AAO7B;AAAA;AAAA;AAAA;AAAA,IAAA,IAAA,CAAO,KAAQ,GAAA,CAAA,CAAA;AACf,IAAA,IAAA,CAAO,IAAO,GAAA,CAAA,CAAA;AAGd,IAAA,IAAA,CAAO,SAAyB,GAAA,QAAA,CAAA;AAEhC,IAAA,IAAA,CAAO,SAAY,GAAA,IAAA,CAAA;AAAA,GAAA;AAAA,EAiBZ,OACP,GAAA;AACI,IAAA,IAAA,CAAK,QAAW,GAAA,IAAA,CAAA;AAChB,IAAA,IAAA,CAAK,YAAe,GAAA,IAAA,CAAA;AACpB,IAAA,IAAA,CAAK,SAAY,GAAA,IAAA,CAAA;AACjB,IAAA,IAAA,CAAK,OAAU,GAAA,IAAA,CAAA;AAAA,GACnB;AACJ,CAAA;AA4BA,IAAI,UAAa,GAAA,CAAA,CAAA;AAkBV,MAAM,QAAA,GAAN,MAAM,QACb,CAAA;AAAA,EAgCI,WAAA,CAAY,OAA0B,GAAA,EACtC,EAAA;AA3BA,IAAO,IAAA,CAAA,GAAA,GAAM,IAAI,SAAS,CAAA,CAAA;AAS1B,IAAA,IAAA,CAAO,KAAQ,GAAA,IAAA,CAAA;AAEf,IAAA,IAAA,CAAO,UAAa,GAAA,CAAA,CAAA;AACpB,IAAA,IAAA,CAAO,UAAmB,EAAC,CAAA;AAG3B;AAAA,IAAA,IAAA,CAAiB,WAAsB,GAAA,CAAA,CAAA;AAEvC,IAAA,IAAA,CAAQ,YAA+B,EAAC,CAAA;AAExC,IAAA,IAAA,CAAiB,aAAsB,EAAC,CAAA;AACxC,IAAA,IAAA,CAAQ,eAAkB,GAAA,CAAA,CAAA;AAC1B,IAAA,IAAA,CAAiB,oBAAyC,EAAC,CAAA;AAC3D,IAAA,IAAA,CAAQ,sBAAyB,GAAA,CAAA,CAAA;AAM7B,IAAA,OAAA,GAAU,EAAE,GAAG,QAAQ,CAAA,cAAA,EAAgB,GAAG,OAAQ,EAAA,CAAA;AAElD,IAAM,MAAA,EAAE,UAAY,EAAA,SAAA,EAAc,GAAA,OAAA,CAAA;AAElC,IAAA,IAAA,CAAK,kBAAkB,IAAI,cAAA,CAAe,UAAa,GAAA,IAAA,CAAK,cAAc,CAAC,CAAA,CAAA;AAE3E,IAAK,IAAA,CAAA,WAAA,GAAc,IAAI,WAAA,CAAY,SAAS,CAAA,CAAA;AAAA,GAChD;AAAA,EAEO,KACP,GAAA;AACI,IAAA,IAAA,CAAK,UAAa,GAAA,CAAA,CAAA;AAClB,IAAA,IAAA,CAAK,WAAc,GAAA,CAAA,CAAA;AACnB,IAAA,IAAA,CAAK,YAAe,GAAA,CAAA,CAAA;AACpB,IAAA,IAAA,CAAK,SAAY,GAAA,CAAA,CAAA;AACjB,IAAA,IAAA,CAAK,aAAgB,GAAA,CAAA,CAAA;AACrB,IAAA,IAAA,CAAK,eAAkB,GAAA,CAAA,CAAA;AACvB,IAAA,IAAA,CAAK,sBAAyB,GAAA,CAAA,CAAA;AAC9B,IAAA,IAAA,CAAK,gBAAmB,GAAA,CAAA,CAAA;AACxB,IAAA,IAAA,CAAK,eAAkB,GAAA,CAAA,CAAA;AAEvB,IAAA,IAAA,CAAK,KAAQ,GAAA,IAAA,CAAA;AAAA,GACjB;AAAA,EAEO,IAAI,eACX,EAAA;AACI,IAAK,IAAA,CAAA,SAAA,CAAU,IAAK,CAAA,WAAA,EAAa,CAAI,GAAA,eAAA,CAAA;AAErC,IAAA,eAAA,CAAgB,aAAa,IAAK,CAAA,SAAA,CAAA;AAClC,IAAA,eAAA,CAAgB,WAAW,IAAK,CAAA,aAAA,CAAA;AAChC,IAAA,eAAA,CAAgB,OAAU,GAAA,IAAA,CAAA;AAE1B,IAAA,IAAA,CAAK,aAAa,eAAgB,CAAA,SAAA,CAAA;AAClC,IAAK,IAAA,CAAA,aAAA,IAAmB,eAAgB,CAAA,UAAA,GAAc,IAAK,CAAA,WAAA,CAAA;AAAA,GAC/D;AAAA,EAEO,qBAAA,CAAsB,iBAAkC,OAC/D,EAAA;AACI,IAAA,MAAM,YAAY,eAAgB,CAAA,KAAA,CAAM,SAAS,GAAI,CAAA,OAAA,CAAQ,QAAQ,GAAG,CAAA,CAAA;AAIxE,IAAI,IAAA,CAAC,aAAa,SAAc,KAAA,CAAA;AAAG,MAAO,OAAA,KAAA,CAAA;AAE1C,IAAA,eAAA,CAAgB,SAAY,GAAA,SAAA,CAAA;AAC5B,IAAA,eAAA,CAAgB,OAAU,GAAA,OAAA,CAAA;AAE1B,IAAO,OAAA,IAAA,CAAA;AAAA,GACX;AAAA,EAEO,cAAc,eACrB,EAAA;AACI,IAAA,IAAA,CAAK,KAAQ,GAAA,IAAA,CAAA;AAEb,IAAgB,eAAA,CAAA,cAAA;AAAA,MACZ,KAAK,eAAgB,CAAA,WAAA;AAAA,MACrB,KAAK,eAAgB,CAAA,UAAA;AAAA,MACrB,eAAgB,CAAA,QAAA;AAAA,MAAU,eAAgB,CAAA,SAAA;AAAA,KAAS,CAAA;AAAA,GAC3D;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOO,MAAM,cACb,EAAA;AAEI,IAAA,MAAM,WAAW,IAAK,CAAA,SAAA,CAAA;AAEtB,IAAA,IAAI,eAAe,IAAK,CAAA,iBAAA,CAAkB,KAAK,sBAAwB,EAAA,CAAA,IAAK,IAAI,iBAAkB,EAAA,CAAA;AAElG,IAAA,YAAA,CAAa,KAAM,EAAA,CAAA;AAGnB,IAAI,IAAA,CAAC,QAAS,CAAA,IAAA,CAAK,YAAY,CAAA;AAAG,MAAA,OAAA;AAElC,IAAM,MAAA,YAAA,GAAe,QAAS,CAAA,IAAA,CAAK,YAAY,CAAA,CAAA;AAC/C,IAAA,IAAI,YAAY,yBAA0B,CAAA,YAAA,CAAa,SAAW,EAAA,YAAA,CAAa,QAAQ,OAAO,CAAA,CAAA;AAE9F,IAAA,IAAI,IAAK,CAAA,aAAA,GAAgB,CAAI,GAAA,IAAA,CAAK,gBAAgB,IAClD,EAAA;AACI,MAAK,IAAA,CAAA,sBAAA,CAAuB,IAAK,CAAA,aAAA,GAAgB,CAAC,CAAA,CAAA;AAAA,KACtD;AAEA,IAAA,IAAI,IAAK,CAAA,SAAA,GAAY,IAAK,CAAA,WAAA,CAAY,MACtC,EAAA;AACI,MAAK,IAAA,CAAA,kBAAA,CAAmB,KAAK,SAAS,CAAA,CAAA;AAAA,KAC1C;AAEA,IAAM,MAAA,GAAA,GAAM,KAAK,eAAgB,CAAA,WAAA,CAAA;AACjC,IAAM,MAAA,GAAA,GAAM,KAAK,eAAgB,CAAA,UAAA,CAAA;AACjC,IAAA,MAAM,UAAU,IAAK,CAAA,WAAA,CAAA;AAErB,IAAA,IAAI,OAAO,IAAK,CAAA,eAAA,CAAA;AAChB,IAAA,IAAI,QAAQ,IAAK,CAAA,gBAAA,CAAA;AAEjB,IAAA,IAAI,MAAsB,GAAA,YAAA,CAAA;AAC1B,IAAA,IAAI,QAAQ,IAAK,CAAA,UAAA,CAAW,KAAK,eAAiB,EAAA,CAAA,IAAK,IAAI,KAAM,EAAA,CAAA;AAEjE,IAAA,KAAA,IAAS,IAAI,IAAK,CAAA,YAAA,EAAc,IAAI,IAAK,CAAA,WAAA,EAAa,EAAE,CACxD,EAAA;AACI,MAAM,MAAA,OAAA,GAAU,SAAS,CAAC,CAAA,CAAA;AAE1B,MAAA,QAAA,CAAS,CAAC,CAAI,GAAA,IAAA,CAAA;AAEd,MAAA,MAAM,UAAU,OAAQ,CAAA,OAAA,CAAA;AACxB,MAAA,MAAM,SAAS,OAAQ,CAAA,OAAA,CAAA;AAEvB,MAAA,MAAM,iBAAoB,GAAA,yBAAA,CAA0B,OAAQ,CAAA,SAAA,EAAW,MAAM,CAAA,CAAA;AAE7E,MAAA,MAAM,kBAAkB,SAAc,KAAA,iBAAA,CAAA;AAEtC,MAAA,IAAI,MAAO,CAAA,UAAA,KAAe,UAAc,IAAA,CAAC,eACzC,EAAA;AACI,QAAA,OAAA,CAAQ,YAAY,MAAO,CAAA,oBAAA,CAAA;AAE3B,QAAA,IAAA,IAAQ,OAAQ,CAAA,SAAA,CAAA;AAChB,QAAA,OAAA,CAAQ,eAAe,GAAK,EAAA,GAAA,EAAK,OAAQ,CAAA,QAAA,EAAU,QAAQ,SAAS,CAAA,CAAA;AACpE,QAAA,OAAA,CAAQ,UAAU,OAAS,EAAA,OAAA,CAAQ,YAAY,OAAQ,CAAA,QAAA,GAAW,KAAK,WAAW,CAAA,CAAA;AAElF,QAAA,OAAA,CAAQ,KAAQ,GAAA,KAAA,CAAA;AAEhB,QAAA,SAAA;AAAA,OACJ;AAEA,MAAA,MAAA,CAAO,UAAa,GAAA,UAAA,CAAA;AAEpB,MAAI,IAAA,YAAA,CAAa,KAAS,IAAA,YAAA,IAAgB,eAC1C,EAAA;AACI,QAAK,IAAA,CAAA,YAAA;AAAA,UACD,KAAA;AAAA,UACA,KAAA;AAAA,UACA,IAAO,GAAA,KAAA;AAAA,UACP,YAAA;AAAA,UACA,SAAA;AAAA,UACA,cAAA;AAAA,UACA,MAAA;AAAA,SACJ,CAAA;AAEA,QAAS,MAAA,GAAA,aAAA,CAAA;AACT,QAAQ,KAAA,GAAA,IAAA,CAAA;AAER,QAAY,SAAA,GAAA,iBAAA,CAAA;AAEZ,QAAA,YAAA,GAAe,KAAK,iBAAkB,CAAA,IAAA,CAAK,sBAAwB,EAAA,CAAA,IAAK,IAAI,iBAAkB,EAAA,CAAA;AAC9F,QAAA,YAAA,CAAa,KAAM,EAAA,CAAA;AAEnB,QAAA,KAAA,GAAQ,KAAK,UAAW,CAAA,IAAA,CAAK,eAAiB,EAAA,CAAA,IAAK,IAAI,KAAM,EAAA,CAAA;AAC7D,QAAE,EAAA,UAAA,CAAA;AAAA,OACN;AAEA,MAAQ,OAAA,CAAA,SAAA,GAAY,MAAO,CAAA,oBAAA,GAAuB,YAAa,CAAA,KAAA,CAAA;AAC/D,MAAA,YAAA,CAAa,GAAI,CAAA,MAAA,CAAO,GAAG,CAAA,GAAI,YAAa,CAAA,KAAA,CAAA;AAC5C,MAAa,YAAA,CAAA,QAAA,CAAS,YAAa,CAAA,KAAA,EAAO,CAAI,GAAA,MAAA,CAAA;AAC9C,MAAA,OAAA,CAAQ,KAAQ,GAAA,KAAA,CAAA;AAEhB,MAAA,IAAA,IAAQ,OAAQ,CAAA,SAAA,CAAA;AAChB,MAAA,OAAA,CAAQ,eAAe,GAAK,EAAA,GAAA,EAAK,OAAQ,CAAA,QAAA,EAAU,QAAQ,SAAS,CAAA,CAAA;AACpE,MAAA,OAAA,CAAQ,UAAU,OAAS,EAAA,OAAA,CAAQ,YAAY,OAAQ,CAAA,QAAA,GAAW,KAAK,WAAW,CAAA,CAAA;AAAA,KACtF;AAEA,IAAI,IAAA,YAAA,CAAa,QAAQ,CACzB,EAAA;AACI,MAAK,IAAA,CAAA,YAAA;AAAA,QACD,KAAA;AAAA,QACA,KAAA;AAAA,QACA,IAAO,GAAA,KAAA;AAAA,QACP,YAAA;AAAA,QACA,SAAA;AAAA,QACA,cAAA;AAAA,QACA,MAAA;AAAA,OACJ,CAAA;AAEA,MAAQ,KAAA,GAAA,IAAA,CAAA;AACR,MAAE,EAAA,UAAA,CAAA;AAAA,KACN;AAEA,IAAA,IAAA,CAAK,eAAe,IAAK,CAAA,WAAA,CAAA;AACzB,IAAA,IAAA,CAAK,gBAAmB,GAAA,KAAA,CAAA;AACxB,IAAA,IAAA,CAAK,eAAkB,GAAA,IAAA,CAAA;AAAA,GAC3B;AAAA,EAEQ,aACJ,KACA,EAAA,UAAA,EACA,WACA,YACA,EAAA,SAAA,EACA,gBACA,MAEJ,EAAA;AACI,IAAA,KAAA,CAAM,YAAe,GAAA,IAAA,CAAA;AACrB,IAAA,KAAA,CAAM,MAAS,GAAA,MAAA,CAAA;AAEf,IAAA,KAAA,CAAM,OAAU,GAAA,IAAA,CAAA;AAChB,IAAA,KAAA,CAAM,QAAW,GAAA,YAAA,CAAA;AACjB,IAAA,KAAA,CAAM,SAAY,GAAA,SAAA,CAAA;AAElB,IAAA,KAAA,CAAM,KAAQ,GAAA,UAAA,CAAA;AACd,IAAA,KAAA,CAAM,IAAO,GAAA,SAAA,CAAA;AAEb,IAAE,EAAA,UAAA,CAAA;AAEF,IAAA,cAAA,CAAe,IAAI,KAAK,CAAA,CAAA;AAAA,GAC5B;AAAA,EAEO,OAAO,cACd,EAAA;AACI,IAAA,IAAA,CAAK,MAAM,cAAc,CAAA,CAAA;AAAA,GAC7B;AAAA;AAAA;AAAA;AAAA;AAAA,EAMO,sBAAsB,IAC7B,EAAA;AACI,IAAI,IAAA,IAAA,GAAO,CAAK,IAAA,IAAA,CAAK,eAAgB,CAAA,IAAA;AAAM,MAAA,OAAA;AAE3C,IAAK,IAAA,CAAA,sBAAA,CAAuB,OAAO,CAAC,CAAA,CAAA;AAAA,GACxC;AAAA;AAAA;AAAA;AAAA;AAAA,EAMO,kBAAkB,IACzB,EAAA;AACI,IAAI,IAAA,IAAA,IAAQ,KAAK,WAAY,CAAA,MAAA;AAAQ,MAAA,OAAA;AAErC,IAAA,IAAA,CAAK,mBAAmB,IAAI,CAAA,CAAA;AAAA,GAChC;AAAA,EAEQ,uBAAuB,IAC/B,EAAA;AACI,IAAA,MAAM,UAAU,IAAK,CAAA,GAAA,CAAI,MAAM,IAAK,CAAA,eAAA,CAAgB,OAAO,CAAC,CAAA,CAAA;AAE5D,IAAM,MAAA,cAAA,GAAiB,IAAI,cAAA,CAAe,OAAO,CAAA,CAAA;AAEjD,IAAA,QAAA,CAAS,IAAK,CAAA,eAAA,CAAgB,aAAe,EAAA,cAAA,CAAe,aAAa,CAAA,CAAA;AAEzE,IAAA,IAAA,CAAK,eAAkB,GAAA,cAAA,CAAA;AAAA,GAC3B;AAAA,EAEQ,mBAAmB,IAC3B,EAAA;AACI,IAAA,MAAM,cAAc,IAAK,CAAA,WAAA,CAAA;AAEzB,IAAA,IAAI,UAAU,IAAK,CAAA,GAAA,CAAI,IAAM,EAAA,WAAA,CAAY,SAAS,GAAG,CAAA,CAAA;AAErD,IAAA,OAAA,IAAW,OAAU,GAAA,CAAA,CAAA;AAOrB,IAAM,MAAA,cAAA,GAAkB,UAAU,KAAS,GAAA,IAAI,YAAY,OAAO,CAAA,GAAI,IAAI,WAAA,CAAY,OAAO,CAAA,CAAA;AAE7F,IAAI,IAAA,cAAA,CAAe,iBAAsB,KAAA,WAAA,CAAY,iBACrD,EAAA;AACI,MAAA,KAAA,IAAS,CAAI,GAAA,CAAA,EAAG,CAAI,GAAA,WAAA,CAAY,QAAQ,CACxC,EAAA,EAAA;AACI,QAAe,cAAA,CAAA,CAAC,CAAI,GAAA,WAAA,CAAY,CAAC,CAAA,CAAA;AAAA,OACrC;AAAA,KAGJ,MAAA;AACI,MAAS,QAAA,CAAA,WAAA,CAAY,MAAQ,EAAA,cAAA,CAAe,MAAM,CAAA,CAAA;AAAA,KACtD;AAEA,IAAA,IAAA,CAAK,WAAc,GAAA,cAAA,CAAA;AAAA,GACvB;AAAA,EAEO,OACP,GAAA;AACI,IAAA,KAAA,IAAS,IAAI,CAAG,EAAA,CAAA,GAAI,IAAK,CAAA,OAAA,CAAQ,QAAQ,CACzC,EAAA,EAAA;AACI,MAAK,IAAA,CAAA,OAAA,CAAQ,CAAC,CAAA,CAAE,OAAQ,EAAA,CAAA;AAAA,KAC5B;AAEA,IAAA,IAAA,CAAK,OAAU,GAAA,IAAA,CAAA;AAEf,IAAA,KAAA,IAAS,IAAI,CAAG,EAAA,CAAA,GAAI,IAAK,CAAA,SAAA,CAAU,QAAQ,CAC3C,EAAA,EAAA;AACI,MAAK,IAAA,CAAA,SAAA,CAAU,CAAC,CAAA,CAAE,KAAQ,GAAA,IAAA,CAAA;AAAA,KAC9B;AAEA,IAAA,IAAA,CAAK,SAAY,GAAA,IAAA,CAAA;AAEjB,IAAA,IAAA,CAAK,WAAc,GAAA,IAAA,CAAA;AAEnB,IAAA,IAAA,CAAK,gBAAgB,OAAQ,EAAA,CAAA;AAC7B,IAAA,IAAA,CAAK,eAAkB,GAAA,IAAA,CAAA;AAAA,GAC3B;AACJ,CAAA,CAAA;AA5Ua,QAAA,CAEK,cAAiC,GAAA;AAAA,EAC3C,UAAY,EAAA,CAAA;AAAA,EACZ,SAAW,EAAA,CAAA;AACf,CAAA,CAAA;AALG,IAAM,OAAN,GAAA;;;;"}