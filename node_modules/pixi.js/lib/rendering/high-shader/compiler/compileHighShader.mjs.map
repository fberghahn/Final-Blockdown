{"version":3,"file":"compileHighShader.mjs","sources":["../../../../src/rendering/high-shader/compiler/compileHighShader.ts"],"sourcesContent":["import { addBits } from './utils/addBits';\nimport { compileHooks } from './utils/compileHooks';\nimport { compileInputs } from './utils/compileInputs';\nimport { compileOutputs } from './utils/compileOutputs';\nimport { injectBits } from './utils/injectBits';\n\nimport type { HighShaderBit, HighShaderSource } from './types';\n\n/** A high template consists of vertex and fragment source */\nexport interface HighShaderTemplate\n{\n    name?: string;\n    fragment: string;\n    vertex: string;\n}\n\nexport interface CompileHighShaderOptions\n{\n    template: HighShaderTemplate;\n    bits: HighShaderBit[];\n}\n\nconst cacheMap: {[key: string]: HighShaderSource} = Object.create(null);\nconst bitCacheMap: Map<HighShaderBit, number> = new Map();\n\nlet CACHE_UID = 0;\n\n/**\n * This function will take a HighShader template, some High fragments and then merge them in to a shader source.\n * @param options\n * @param options.template\n * @param options.bits\n */\nexport function compileHighShader({\n    template,\n    bits\n}: CompileHighShaderOptions): HighShaderSource\n{\n    const cacheId = generateCacheId(template, bits);\n\n    if (cacheMap[cacheId]) return cacheMap[cacheId];\n\n    const { vertex, fragment } = compileInputsAndOutputs(template, bits);\n\n    cacheMap[cacheId] = compileBits(vertex, fragment, bits);\n\n    return cacheMap[cacheId];\n}\n\nexport function compileHighShaderGl({\n    template,\n    bits\n}: CompileHighShaderOptions): HighShaderSource\n{\n    const cacheId = generateCacheId(template, bits);\n\n    if (cacheMap[cacheId]) return cacheMap[cacheId];\n\n    cacheMap[cacheId] = compileBits(template.vertex, template.fragment, bits);\n\n    return cacheMap[cacheId];\n}\n\nfunction compileInputsAndOutputs(template: HighShaderTemplate, bits: HighShaderBit[])\n{\n    const vertexFragments = bits.map((shaderBit) => shaderBit.vertex).filter((v) => !!v);\n    const fragmentFragments = bits.map((shaderBit) => shaderBit.fragment).filter((v) => !!v);\n\n    // WebGPU compile inputs and outputs..\n    let compiledVertex = compileInputs(vertexFragments, template.vertex, true);\n\n    compiledVertex = compileOutputs(vertexFragments, compiledVertex);\n\n    const compiledFragment = compileInputs(fragmentFragments, template.fragment, true);\n\n    return {\n        vertex: compiledVertex,\n        fragment: compiledFragment,\n    };\n}\n\nfunction generateCacheId(template: HighShaderTemplate, bits: HighShaderBit[]): string\n{\n    return bits\n        .map((highFragment) =>\n        {\n            if (!bitCacheMap.has(highFragment))\n            {\n                bitCacheMap.set(highFragment, CACHE_UID++);\n            }\n\n            return bitCacheMap.get(highFragment);\n        })\n        .sort((a, b) => a - b)\n        .join('-') + template.vertex + template.fragment;\n}\n\nfunction compileBits(vertex: string, fragment: string, bits: HighShaderBit[])\n{\n    const vertexParts = compileHooks(vertex);\n    const fragmentParts = compileHooks(fragment);\n\n    bits.forEach((shaderBit) =>\n    {\n        addBits(shaderBit.vertex, vertexParts, shaderBit.name);\n        addBits(shaderBit.fragment, fragmentParts, shaderBit.name);\n    });\n\n    return {\n        vertex: injectBits(vertex, vertexParts),\n        fragment: injectBits(fragment, fragmentParts),\n    };\n}\n"],"names":[],"mappings":"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"}