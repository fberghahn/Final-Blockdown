{"version":3,"file":"generateTextureBatchBit.mjs","sources":["../../../../src/rendering/high-shader/shader-bits/generateTextureBatchBit.ts"],"sourcesContent":["import type { HighShaderBit } from '../compiler/types';\n\nconst textureBatchBitGpuCache: Record<number, HighShaderBit> = {};\n\n/**\n *\n * @param maxTextures - the max textures the shader can use.\n * @returns a shader bit that will allow the shader to sample multiple textures AND round pixels.\n */\nfunction generateBindingSrc(maxTextures: number): string\n{\n    const src = [];\n\n    if (maxTextures === 1)\n    {\n        src.push('@group(1) @binding(0) var textureSource1: texture_2d<f32>;');\n        src.push('@group(1) @binding(1) var textureSampler1: sampler;');\n    }\n    else\n    {\n        let bindingIndex = 0;\n\n        for (let i = 0; i < maxTextures; i++)\n        {\n            src.push(`@group(1) @binding(${bindingIndex++}) var textureSource${i + 1}: texture_2d<f32>;`);\n            src.push(`@group(1) @binding(${bindingIndex++}) var textureSampler${i + 1}: sampler;`);\n        }\n    }\n\n    return src.join('\\n');\n}\n\nfunction generateSampleSrc(maxTextures: number): string\n{\n    const src = [];\n\n    if (maxTextures === 1)\n    {\n        src.push('outColor = textureSampleGrad(textureSource1, textureSampler1, vUV, uvDx, uvDy);');\n    }\n    else\n    {\n        src.push('switch vTextureId {');\n\n        for (let i = 0; i < maxTextures; i++)\n        {\n            if (i === maxTextures - 1)\n            {\n                src.push(`  default:{`);\n            }\n            else\n            {\n                src.push(`  case ${i}:{`);\n            }\n            src.push(`      outColor = textureSampleGrad(textureSource${i + 1}, textureSampler${i + 1}, vUV, uvDx, uvDy);`);\n            src.push(`      break;}`);\n        }\n\n        src.push(`}`);\n    }\n\n    return src.join('\\n');\n}\n\nexport function generateTextureBatchBit(maxTextures: number): HighShaderBit\n{\n    if (!textureBatchBitGpuCache[maxTextures])\n    {\n        textureBatchBitGpuCache[maxTextures] = {\n            name: 'texture-batch-bit',\n            vertex: {\n                header: `\n                @in aTextureIdAndRound: vec2<u32>;\n                @out @interpolate(flat) vTextureId : u32;\n            `,\n                main: `\n                vTextureId = aTextureIdAndRound.y;\n            `,\n                end: `\n                if(aTextureIdAndRound.x == 1)\n                {\n                    vPosition = vec4<f32>(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n                }\n            `\n            },\n            fragment: {\n                header: `\n                @in @interpolate(flat) vTextureId: u32;\n    \n                ${generateBindingSrc(16)}\n            `,\n                main: `\n                var uvDx = dpdx(vUV);\n                var uvDy = dpdy(vUV);\n    \n                ${generateSampleSrc(16)}\n            `\n            }\n        };\n    }\n\n    return textureBatchBitGpuCache[maxTextures];\n}\n\nconst textureBatchBitGlCache: Record<number, HighShaderBit> = {};\n\n/**\n *\n * @param maxTextures - the max textures the shader can use.\n * @returns a shader bit that will allow the shader to sample multiple textures AND round pixels.\n */\nfunction generateSampleGlSrc(maxTextures: number): string\n{\n    const src = [];\n\n    for (let i = 0; i < maxTextures; i++)\n    {\n        if (i > 0)\n        {\n            src.push('else');\n        }\n\n        if (i < maxTextures - 1)\n        {\n            src.push(`if(vTextureId < ${i}.5)`);\n        }\n\n        src.push('{');\n        src.push(`\\toutColor = texture(uTextures[${i}], vUV);`);\n        src.push('}');\n    }\n\n    return src.join('\\n');\n}\n\nexport function generateTextureBatchBitGl(maxTextures: number): HighShaderBit\n{\n    if (!textureBatchBitGlCache[maxTextures])\n    {\n        textureBatchBitGlCache[maxTextures] = {\n            name: 'texture-batch-bit',\n            vertex: {\n                header: `\n                in vec2 aTextureIdAndRound;\n                out float vTextureId;\n              \n            `,\n                main: `\n                vTextureId = aTextureIdAndRound.y;\n            `,\n                end: `\n                if(aTextureIdAndRound.x == 1.)\n                {\n                    gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n                }\n            `\n            },\n            fragment: {\n                header: `\n                in float vTextureId;\n    \n                uniform sampler2D uTextures[${maxTextures}];\n              \n            `,\n                main: `\n    \n                ${generateSampleGlSrc(16)}\n            `\n            }\n        };\n    }\n\n    return textureBatchBitGlCache[maxTextures];\n}\n"],"names":[],"mappings":"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"}