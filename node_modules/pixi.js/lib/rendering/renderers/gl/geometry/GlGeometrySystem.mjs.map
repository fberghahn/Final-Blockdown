{"version":3,"file":"GlGeometrySystem.mjs","sources":["../../../../../src/rendering/renderers/gl/geometry/GlGeometrySystem.ts"],"sourcesContent":["import { ExtensionType } from '../../../../extensions/Extensions';\nimport { getAttributeInfoFromFormat } from '../../shared/geometry/utils/getAttributeInfoFromFormat';\nimport { ensureAttributes } from '../shader/program/ensureAttributes';\nimport { getGlTypeFromFormat } from './utils/getGlTypeFromFormat';\n\nimport type { Topology } from '../../shared/geometry/const';\nimport type { Geometry } from '../../shared/geometry/Geometry';\nimport type { System } from '../../shared/system/System';\nimport type { GlRenderingContext } from '../context/GlRenderingContext';\nimport type { GlProgram } from '../shader/GlProgram';\nimport type { WebGLRenderer } from '../WebGLRenderer';\n\nconst topologyToGlMap = {\n    'point-list': 0x0000,\n    'line-list': 0x0001,\n    'line-strip': 0x0003,\n    'triangle-list': 0x0004,\n    'triangle-strip': 0x0005\n};\n\n/**\n * System plugin to the renderer to manage geometry.\n * @memberof rendering\n */\nexport class GlGeometrySystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n        ],\n        name: 'geometry',\n    } as const;\n\n    /**\n     * `true` if we has `*_vertex_array_object` extension.\n     * @readonly\n     */\n    public hasVao: boolean;\n\n    /**\n     * `true` if has `ANGLE_instanced_arrays` extension.\n     * @readonly\n     */\n    public hasInstance: boolean;\n\n    protected gl: GlRenderingContext;\n    protected _activeGeometry: Geometry;\n    protected _activeVao: WebGLVertexArrayObject;\n\n    protected _geometryVaoHash: Record<number, Record<string, WebGLVertexArrayObject>> = Object.create(null);\n\n    /** Renderer that owns this {@link GeometrySystem}. */\n    private _renderer: WebGLRenderer;\n\n    /** @param renderer - The renderer this System works for. */\n    constructor(renderer: WebGLRenderer)\n    {\n        this._renderer = renderer;\n        this._activeGeometry = null;\n        this._activeVao = null;\n\n        this.hasVao = true;\n        this.hasInstance = true;\n    }\n\n    /** Sets up the renderer context and necessary buffers. */\n    protected contextChange(): void\n    {\n        const gl = this.gl = this._renderer.gl;\n\n        if (!this._renderer.context.supports.vertexArrayObject)\n        {\n            throw new Error('[PixiJS] Vertex Array Objects are not supported on this device');\n        }\n\n        const nativeVaoExtension = this._renderer.context.extensions.vertexArrayObject;\n\n        if (nativeVaoExtension)\n        {\n            gl.createVertexArray = (): WebGLVertexArrayObject =>\n                nativeVaoExtension.createVertexArrayOES();\n\n            gl.bindVertexArray = (vao): void =>\n                nativeVaoExtension.bindVertexArrayOES(vao);\n\n            gl.deleteVertexArray = (vao): void =>\n                nativeVaoExtension.deleteVertexArrayOES(vao);\n        }\n\n        const nativeInstancedExtension = this._renderer.context.extensions.vertexAttribDivisorANGLE;\n\n        if (nativeInstancedExtension)\n        {\n            gl.drawArraysInstanced = (a, b, c, d): void =>\n            {\n                nativeInstancedExtension.drawArraysInstancedANGLE(a, b, c, d);\n            };\n\n            gl.drawElementsInstanced = (a, b, c, d, e): void =>\n            {\n                nativeInstancedExtension.drawElementsInstancedANGLE(a, b, c, d, e);\n            };\n\n            gl.vertexAttribDivisor = (a, b): void =>\n                nativeInstancedExtension.vertexAttribDivisorANGLE(a, b);\n        }\n\n        this._activeGeometry = null;\n        this._activeVao = null;\n        this._geometryVaoHash = Object.create(null);\n    }\n\n    /**\n     * Binds geometry so that is can be drawn. Creating a Vao if required\n     * @param geometry - Instance of geometry to bind.\n     * @param program - Instance of program to use vao for.\n     */\n    public bind(geometry?: Geometry, program?: GlProgram): void\n    {\n        // shader = shader || this.renderer.shader.shader;\n\n        const gl = this.gl;\n\n        this._activeGeometry = geometry;\n\n        const vao = this.getVao(geometry, program);\n\n        if (this._activeVao !== vao)\n        {\n            this._activeVao = vao;\n\n            gl.bindVertexArray(vao);\n        }\n\n        this.updateBuffers();\n    }\n\n    /** Reset and unbind any active VAO and geometry. */\n    public reset(): void\n    {\n        this.unbind();\n    }\n\n    /** Update buffers of the currently bound geometry. */\n    public updateBuffers(): void\n    {\n        const geometry = this._activeGeometry;\n\n        const bufferSystem = this._renderer.buffer;\n\n        for (let i = 0; i < geometry.buffers.length; i++)\n        {\n            const buffer = geometry.buffers[i];\n\n            bufferSystem.updateBuffer(buffer);\n        }\n    }\n\n    /**\n     * Check compatibility between a geometry and a program\n     * @param geometry - Geometry instance.\n     * @param program - Program instance.\n     */\n    protected checkCompatibility(geometry: Geometry, program: GlProgram): void\n    {\n        // geometry must have at least all the attributes that the shader requires.\n        const geometryAttributes = geometry.attributes;\n        const shaderAttributes = program._attributeData;\n\n        for (const j in shaderAttributes)\n        {\n            if (!geometryAttributes[j])\n            {\n                throw new Error(`shader and geometry incompatible, geometry missing the \"${j}\" attribute`);\n            }\n        }\n    }\n\n    /**\n     * Takes a geometry and program and generates a unique signature for them.\n     * @param geometry - To get signature from.\n     * @param program - To test geometry against.\n     * @returns - Unique signature of the geometry and program\n     */\n    protected getSignature(geometry: Geometry, program: GlProgram): string\n    {\n        const attribs = geometry.attributes;\n        const shaderAttributes = program._attributeData;\n\n        const strings = ['g', geometry.uid];\n\n        for (const i in attribs)\n        {\n            if (shaderAttributes[i])\n            {\n                strings.push(i, shaderAttributes[i].location);\n            }\n        }\n\n        return strings.join('-');\n    }\n\n    protected getVao(geometry: Geometry, program: GlProgram): WebGLVertexArrayObject\n    {\n        return this._geometryVaoHash[geometry.uid]?.[program._key] || this.initGeometryVao(geometry, program);\n    }\n\n    /**\n     * Creates or gets Vao with the same structure as the geometry and stores it on the geometry.\n     * If vao is created, it is bound automatically. We use a shader to infer what and how to set up the\n     * attribute locations.\n     * @param geometry - Instance of geometry to to generate Vao for.\n     * @param program\n     * @param _incRefCount - Increment refCount of all geometry buffers.\n     */\n    protected initGeometryVao(geometry: Geometry, program: GlProgram, _incRefCount = true): WebGLVertexArrayObject\n    {\n        const gl = this._renderer.gl;\n        // const CONTEXT_UID = this.CONTEXT_UID;\n        const bufferSystem = this._renderer.buffer;\n\n        this._renderer.shader._getProgramData(program);\n\n        this.checkCompatibility(geometry, program);\n\n        const signature = this.getSignature(geometry, program);\n\n        if (!this._geometryVaoHash[geometry.uid])\n        {\n            this._geometryVaoHash[geometry.uid] = Object.create(null);\n\n            geometry.on('destroy', this.onGeometryDestroy, this);\n        }\n\n        const vaoObjectHash = this._geometryVaoHash[geometry.uid];\n\n        let vao = vaoObjectHash[signature];\n\n        if (vao)\n        {\n            // this will give us easy access to the vao\n            vaoObjectHash[program._key] = vao;\n\n            return vao;\n        }\n\n        ensureAttributes(geometry, program._attributeData);\n\n        const buffers = geometry.buffers;\n\n        // @TODO: We don't know if VAO is supported.\n        vao = gl.createVertexArray();\n\n        gl.bindVertexArray(vao);\n\n        // first update - and create the buffers!\n        // only create a gl buffer if it actually gets\n        for (let i = 0; i < buffers.length; i++)\n        {\n            const buffer = buffers[i];\n\n            bufferSystem.bind(buffer);\n        }\n\n        // TODO - maybe make this a data object?\n        // lets wait to see if we need to first!\n\n        this.activateVao(geometry, program);\n\n        // add it to the cache!\n        vaoObjectHash[program._key] = vao;\n        vaoObjectHash[signature] = vao;\n\n        gl.bindVertexArray(null);\n\n        return vao;\n    }\n\n    /**\n     * Disposes geometry.\n     * @param geometry - Geometry with buffers. Only VAO will be disposed\n     * @param [contextLost=false] - If context was lost, we suppress deleteVertexArray\n     */\n    protected onGeometryDestroy(geometry: Geometry, contextLost?: boolean): void\n    {\n        const vaoObjectHash = this._geometryVaoHash[geometry.uid];\n\n        const gl = this.gl;\n\n        if (vaoObjectHash)\n        {\n            if (contextLost)\n            {\n                for (const i in vaoObjectHash)\n                {\n                    if (this._activeVao !== vaoObjectHash[i])\n                    {\n                        this.unbind();\n                    }\n\n                    gl.deleteVertexArray(vaoObjectHash[i]);\n                }\n            }\n\n            this._geometryVaoHash[geometry.uid] = null;\n        }\n    }\n\n    /**\n     * Dispose all WebGL resources of all managed geometries.\n     * @param [contextLost=false] - If context was lost, we suppress `gl.delete` calls\n     */\n    public destroyAll(contextLost = false): void\n    {\n        const gl = this.gl;\n\n        for (const i in this._geometryVaoHash)\n        {\n            if (contextLost)\n            {\n                for (const j in this._geometryVaoHash[i])\n                {\n                    const vaoObjectHash = this._geometryVaoHash[i];\n\n                    if (this._activeVao !== vaoObjectHash)\n                    {\n                        this.unbind();\n                    }\n\n                    gl.deleteVertexArray(vaoObjectHash[j]);\n                }\n            }\n\n            this._geometryVaoHash[i] = null;\n        }\n    }\n\n    /**\n     * Activate vertex array object.\n     * @param geometry - Geometry instance.\n     * @param program - Shader program instance.\n     */\n    protected activateVao(geometry: Geometry, program: GlProgram): void\n    {\n        const gl = this._renderer.gl;\n\n        const bufferSystem = this._renderer.buffer;\n        const attributes = geometry.attributes;\n\n        if (geometry.indexBuffer)\n        {\n            // first update the index buffer if we have one..\n            bufferSystem.bind(geometry.indexBuffer);\n        }\n\n        let lastBuffer = null;\n\n        // add a new one!\n        for (const j in attributes)\n        {\n            const attribute = attributes[j];\n            const buffer = attribute.buffer;\n            const glBuffer = bufferSystem.getGlBuffer(buffer);\n\n            if (program._attributeData[j])\n            {\n                if (lastBuffer !== glBuffer)\n                {\n                    bufferSystem.bind(buffer);\n\n                    lastBuffer = glBuffer;\n                }\n\n                const location = attribute.location;\n\n                // TODO introduce state again\n                // we can optimise this for older devices that have no VAOs\n                gl.enableVertexAttribArray(location);\n\n                const attributeInfo = getAttributeInfoFromFormat(attribute.format);\n\n                gl.vertexAttribPointer(location,\n                    attributeInfo.size,\n                    getGlTypeFromFormat(attribute.format),\n                    attributeInfo.normalised,\n                    attribute.stride,\n                    attribute.offset);\n\n                if (attribute.instance)\n                {\n                    // TODO calculate instance count based of this...\n                    if (this.hasInstance)\n                    {\n                        gl.vertexAttribDivisor(location, 1);// attribute.divisor);\n                    }\n                    else\n                    {\n                        throw new Error('geometry error, GPU Instancing is not supported on this device');\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Draws the currently bound geometry.\n     * @param topology - The type primitive to render.\n     * @param size - The number of elements to be rendered. If not specified, all vertices after the\n     *  starting vertex will be drawn.\n     * @param start - The starting vertex in the geometry to start drawing from. If not specified,\n     *  drawing will start from the first vertex.\n     * @param instanceCount - The number of instances of the set of elements to execute. If not specified,\n     *  all instances will be drawn.\n     */\n    public draw(topology?: Topology, size?: number, start?: number, instanceCount?: number): this\n    {\n        const { gl } = this._renderer;\n        const geometry = this._activeGeometry;\n\n        const glTopology = topologyToGlMap[geometry.topology || topology];\n\n        instanceCount ||= geometry.instanceCount;\n\n        if (geometry.indexBuffer)\n        {\n            const byteSize = geometry.indexBuffer.data.BYTES_PER_ELEMENT;\n            const glType = byteSize === 2 ? gl.UNSIGNED_SHORT : gl.UNSIGNED_INT;\n\n            if (instanceCount > 1)\n            {\n                /* eslint-disable max-len */\n                gl.drawElementsInstanced(glTopology, size || geometry.indexBuffer.data.length, glType, (start || 0) * byteSize, instanceCount);\n                /* eslint-enable max-len */\n            }\n            else\n            {\n                /* eslint-disable max-len */\n                gl.drawElements(glTopology, size || geometry.indexBuffer.data.length, glType, (start || 0) * byteSize);\n                /* eslint-enable max-len */\n            }\n        }\n        else if (instanceCount > 1)\n        {\n            // TODO need a better way to calculate size..\n            gl.drawArraysInstanced(glTopology, start || 0, size || geometry.getSize(), instanceCount);\n        }\n        else\n        {\n            gl.drawArrays(glTopology, start || 0, size || geometry.getSize());\n        }\n\n        return this;\n    }\n\n    /** Unbind/reset everything. */\n    protected unbind(): void\n    {\n        this.gl.bindVertexArray(null);\n        this._activeVao = null;\n        this._activeGeometry = null;\n    }\n\n    public destroy(): void\n    {\n        this._renderer = null;\n        this.gl = null;\n        this._activeVao = null;\n        this._activeGeometry = null;\n    }\n}\n"],"names":[],"mappings":"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"}