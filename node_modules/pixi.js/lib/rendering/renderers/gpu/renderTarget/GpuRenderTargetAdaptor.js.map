{"version":3,"file":"GpuRenderTargetAdaptor.js","sources":["../../../../../src/rendering/renderers/gpu/renderTarget/GpuRenderTargetAdaptor.ts"],"sourcesContent":["import { CLEAR } from '../../gl/const';\nimport { CanvasSource } from '../../shared/texture/sources/CanvasSource';\nimport { TextureSource } from '../../shared/texture/sources/TextureSource';\nimport { GpuRenderTarget } from './GpuRenderTarget';\n\nimport type { RgbaArray } from '../../../../color/Color';\nimport type { Rectangle } from '../../../../maths/shapes/Rectangle';\nimport type { CLEAR_OR_BOOL } from '../../gl/const';\nimport type { RenderTarget } from '../../shared/renderTarget/RenderTarget';\nimport type { RenderTargetAdaptor, RenderTargetSystem } from '../../shared/renderTarget/RenderTargetSystem';\nimport type { Texture } from '../../shared/texture/Texture';\nimport type { WebGPURenderer } from '../WebGPURenderer';\n\n/**\n * The WebGPU adaptor for the render target system. Allows the Render Target System to\n * be used with the WebGPU renderer\n * @memberof rendering\n * @ignore\n */\nexport class GpuRenderTargetAdaptor implements RenderTargetAdaptor<GpuRenderTarget>\n{\n    private _renderTargetSystem: RenderTargetSystem<GpuRenderTarget>;\n    private _renderer: WebGPURenderer<HTMLCanvasElement>;\n\n    public init(renderer: WebGPURenderer, renderTargetSystem: RenderTargetSystem<GpuRenderTarget>): void\n    {\n        this._renderer = renderer;\n        this._renderTargetSystem = renderTargetSystem;\n    }\n\n    public copyToTexture(\n        sourceRenderSurfaceTexture: RenderTarget,\n        destinationTexture: Texture,\n        originSrc: { x: number; y: number; },\n        size: { width: number; height: number; },\n        originDest: { x: number; y: number; },\n    )\n    {\n        const renderer = this._renderer;\n\n        const baseGpuTexture = this._getGpuColorTexture(\n            sourceRenderSurfaceTexture\n        );\n\n        const backGpuTexture = renderer.texture.getGpuSource(\n            destinationTexture.source\n        );\n\n        renderer.encoder.commandEncoder.copyTextureToTexture(\n            {\n                texture: baseGpuTexture,\n                origin: originSrc,\n            },\n            {\n                texture: backGpuTexture,\n                origin: originDest,\n            },\n            size\n        );\n\n        return destinationTexture;\n    }\n\n    public startRenderPass(\n        renderTarget: RenderTarget,\n        clear: CLEAR_OR_BOOL = true,\n        clearColor?: RgbaArray,\n        viewport?: Rectangle\n    )\n    {\n        const renderTargetSystem = this._renderTargetSystem;\n\n        const gpuRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);\n\n        const descriptor = this.getDescriptor(renderTarget, clear, clearColor);\n\n        gpuRenderTarget.descriptor = descriptor;\n\n        // TODO we should not finish a render pass each time we bind\n        // for example filters - we would want to push / pop render targets\n        this._renderer.pipeline.setRenderTarget(gpuRenderTarget);\n        this._renderer.encoder.beginRenderPass(gpuRenderTarget);\n        this._renderer.encoder.setViewport(viewport);\n    }\n\n    public finishRenderPass()\n    {\n        this._renderer.encoder.endRenderPass();\n    }\n\n    /**\n     * returns the gpu texture for the first color texture in the render target\n     * mainly used by the filter manager to get copy the texture for blending\n     * @param renderTarget\n     * @returns a gpu texture\n     */\n    private _getGpuColorTexture(renderTarget: RenderTarget): GPUTexture\n    {\n        const gpuRenderTarget = this._renderTargetSystem.getGpuRenderTarget(renderTarget);\n\n        if (gpuRenderTarget.contexts[0])\n        {\n            return gpuRenderTarget.contexts[0].getCurrentTexture();\n        }\n\n        return this._renderer.texture.getGpuSource(\n            renderTarget.colorTextures[0].source\n        );\n    }\n\n    public getDescriptor(\n        renderTarget: RenderTarget,\n        clear: CLEAR_OR_BOOL,\n        clearValue: RgbaArray\n    ): GPURenderPassDescriptor\n    {\n        if (typeof clear === 'boolean')\n        {\n            clear = clear ? CLEAR.ALL : CLEAR.NONE;\n        }\n\n        const renderTargetSystem = this._renderTargetSystem;\n\n        const gpuRenderTarget = renderTargetSystem.getGpuRenderTarget(renderTarget);\n\n        const colorAttachments = renderTarget.colorTextures.map(\n            (texture, i) =>\n            {\n                const context = gpuRenderTarget.contexts[i];\n\n                let view: GPUTextureView;\n                let resolveTarget: GPUTextureView;\n\n                if (context)\n                {\n                    const currentTexture = context.getCurrentTexture();\n\n                    const canvasTextureView = currentTexture.createView();\n\n                    view = canvasTextureView;\n                }\n                else\n                {\n                    view = this._renderer.texture.getGpuSource(texture).createView({\n                        mipLevelCount: 1,\n                    });\n                }\n\n                if (gpuRenderTarget.msaaTextures[i])\n                {\n                    resolveTarget = view;\n                    view = this._renderer.texture.getTextureView(\n                        gpuRenderTarget.msaaTextures[i]\n                    );\n                }\n\n                const loadOp = ((clear as CLEAR) & CLEAR.COLOR ? 'clear' : 'load') as GPULoadOp;\n\n                clearValue ??= renderTargetSystem.defaultClearColor;\n\n                return {\n                    view,\n                    resolveTarget,\n                    clearValue,\n                    storeOp: 'store',\n                    loadOp\n                };\n            }\n        ) as GPURenderPassColorAttachment[];\n\n        let depthStencilAttachment: GPURenderPassDepthStencilAttachment;\n\n        // if we have a depth or stencil buffer, we need to ensure we have a texture for it\n        // this is WebGPU specific - as WebGL does not require textures to run a depth / stencil buffer\n        if ((renderTarget.stencil || renderTarget.depth) && !renderTarget.depthStencilTexture)\n        {\n            renderTarget.ensureDepthStencilTexture();\n            renderTarget.depthStencilTexture.source.sampleCount = gpuRenderTarget.msaa ? 4 : 1;\n        }\n\n        if (renderTarget.depthStencilTexture)\n        {\n            const stencilLoadOp = (clear & CLEAR.STENCIL ? 'clear' : 'load') as GPULoadOp;\n            const depthLoadOp = (clear & CLEAR.DEPTH ? 'clear' : 'load') as GPULoadOp;\n\n            depthStencilAttachment = {\n                view: this._renderer.texture\n                    .getGpuSource(renderTarget.depthStencilTexture.source)\n                    .createView(),\n                stencilStoreOp: 'store',\n                stencilLoadOp,\n                depthClearValue: 1.0,\n                depthLoadOp,\n                depthStoreOp: 'store',\n            };\n        }\n\n        const descriptor: GPURenderPassDescriptor = {\n            colorAttachments,\n            depthStencilAttachment,\n        };\n\n        return descriptor;\n    }\n\n    public clear(renderTarget: RenderTarget, clear: CLEAR_OR_BOOL = true, clearColor?: RgbaArray, viewport?: Rectangle)\n    {\n        if (!clear) return;\n\n        const { gpu, encoder } = this._renderer;\n\n        const device = gpu.device;\n\n        const standAlone = encoder.commandEncoder === null;\n\n        if (standAlone)\n        {\n            const commandEncoder = device.createCommandEncoder();\n            const renderPassDescriptor = this.getDescriptor(renderTarget, clear, clearColor);\n\n            const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);\n\n            passEncoder.setViewport(viewport.x, viewport.y, viewport.width, viewport.height, 0, 1);\n\n            passEncoder.end();\n\n            const gpuCommands = commandEncoder.finish();\n\n            device.queue.submit([gpuCommands]);\n        }\n        else\n        {\n            this.startRenderPass(renderTarget, clear, clearColor, viewport);\n        }\n    }\n\n    public initGpuRenderTarget(renderTarget: RenderTarget): GpuRenderTarget\n    {\n        // always false for WebGPU\n        renderTarget.isRoot = true;\n\n        const gpuRenderTarget = new GpuRenderTarget();\n\n        // create a context...\n        // is a canvas...\n        renderTarget.colorTextures.forEach((colorTexture, i) =>\n        {\n            if (CanvasSource.test(colorTexture.resource))\n            {\n                const context = colorTexture.resource.getContext(\n                    'webgpu'\n                ) as unknown as GPUCanvasContext;\n\n                const alphaMode = (colorTexture as CanvasSource).transparent ? 'premultiplied' : 'opaque';\n\n                try\n                {\n                    context.configure({\n                        device: this._renderer.gpu.device,\n                        // eslint-disable-next-line max-len\n                        usage: GPUTextureUsage.TEXTURE_BINDING\n                            | GPUTextureUsage.COPY_DST\n                            | GPUTextureUsage.RENDER_ATTACHMENT\n                            | GPUTextureUsage.COPY_SRC,\n                        format: 'bgra8unorm',\n                        alphaMode,\n                    });\n                }\n                catch (e)\n                {\n                    console.error(e);\n                }\n\n                gpuRenderTarget.contexts[i] = context;\n            }\n\n            gpuRenderTarget.msaa = colorTexture.source.antialias;\n\n            if (colorTexture.source.antialias)\n            {\n                const msaaTexture = new TextureSource({\n                    width: 0,\n                    height: 0,\n                    sampleCount: 4,\n                });\n\n                gpuRenderTarget.msaaTextures[i] = msaaTexture;\n            }\n        });\n\n        if (gpuRenderTarget.msaa)\n        {\n            gpuRenderTarget.msaaSamples = 4;\n\n            if (renderTarget.depthStencilTexture)\n            {\n                renderTarget.depthStencilTexture.source.sampleCount = 4;\n            }\n        }\n\n        return gpuRenderTarget;\n    }\n\n    public ensureDepthStencilTexture(renderTarget: RenderTarget)\n    {\n        // TODO This function will be more useful once we cache the descriptors\n        const gpuRenderTarget = this._renderTargetSystem.getGpuRenderTarget(renderTarget);\n\n        if (renderTarget.depthStencilTexture && gpuRenderTarget.msaa)\n        {\n            renderTarget.depthStencilTexture.source.sampleCount = 4;\n        }\n    }\n\n    public resizeGpuRenderTarget(renderTarget: RenderTarget)\n    {\n        const gpuRenderTarget = this._renderTargetSystem.getGpuRenderTarget(renderTarget);\n\n        gpuRenderTarget.width = renderTarget.width;\n        gpuRenderTarget.height = renderTarget.height;\n\n        if (gpuRenderTarget.msaa)\n        {\n            renderTarget.colorTextures.forEach((colorTexture, i) =>\n            {\n                const msaaTexture = gpuRenderTarget.msaaTextures[i];\n\n                msaaTexture?.resize(\n                    colorTexture.source.width,\n                    colorTexture.source.height,\n                    colorTexture.source._resolution\n                );\n            });\n        }\n    }\n}\n"],"names":["CLEAR","GpuRenderTarget","CanvasSource","TextureSource"],"mappings":"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"}