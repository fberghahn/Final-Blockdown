{"version":3,"file":"GenerateTextureSystem.js","sources":["../../../../../src/rendering/renderers/shared/extract/GenerateTextureSystem.ts"],"sourcesContent":["import { Color, type ColorSource } from '../../../../color/Color';\nimport { ExtensionType } from '../../../../extensions/Extensions';\nimport { Matrix } from '../../../../maths/matrix/Matrix';\nimport { Rectangle } from '../../../../maths/shapes/Rectangle';\nimport { Bounds } from '../../../../scene/container/bounds/Bounds';\nimport { getLocalBounds } from '../../../../scene/container/bounds/getLocalBounds';\nimport { Container } from '../../../../scene/container/Container';\nimport { RenderTexture } from '../texture/RenderTexture';\n\nimport type { Renderer } from '../../types';\nimport type { System } from '../system/System';\nimport type { TextureSourceOptions } from '../texture/sources/TextureSource';\nimport type { Texture } from '../texture/Texture';\n\nexport type GenerateTextureSourceOptions = Omit<TextureSourceOptions, 'resource' | 'width' | 'height' | 'resolution'>;\n\n/**\n * Options for generating a texture from a container.\n * @memberof rendering\n */\nexport type GenerateTextureOptions =\n{\n    /** The container to generate the texture from */\n    target: Container;\n    /**\n     * The region of the container, that shall be rendered,\n     * if no region is specified, defaults to the local bounds of the container.\n     */\n    frame?: Rectangle;\n    /** The resolution of the texture being generated. */\n    resolution?: number;\n    /** The color used to clear the texture. */\n    clearColor?: ColorSource;\n    /** Whether to enable anti-aliasing. This may affect performance. */\n    antialias?: boolean;\n    /** The options passed to the texture source. */\n    textureSourceOptions?: GenerateTextureSourceOptions,\n};\n\nconst tempRect = new Rectangle();\nconst tempBounds = new Bounds();\nconst noColor: ColorSource = [0, 0, 0, 0];\n\n/**\n * System that manages the generation of textures from the renderer\n *\n *\n * Do not instantiate these plugins directly. It is available from the `renderer.textureGenerator` property.\n * @memberof rendering\n */\nexport class GenerateTextureSystem implements System\n{\n    /** @ignore */\n    public static extension = {\n        type: [\n            ExtensionType.WebGLSystem,\n            ExtensionType.WebGPUSystem,\n        ],\n        name: 'textureGenerator',\n    } as const;\n\n    private readonly _renderer: Renderer;\n\n    constructor(renderer: Renderer)\n    {\n        this._renderer = renderer;\n    }\n\n    /**\n     * A Useful function that returns a texture of the display object that can then be used to create sprites\n     * This can be quite useful if your container is complicated and needs to be reused multiple times.\n     * @param {GenerateTextureOptions | Container} options - Generate texture options.\n     * @param {Container} [options.container] - If not given, the renderer's resolution is used.\n     * @param {Rectangle} options.region - The region of the container, that shall be rendered,\n     * @param {number} [options.resolution] - The resolution of the texture being generated.\n     *        if no region is specified, defaults to the local bounds of the container.\n     * @param {GenerateTextureSourceOptions} [options.textureSourceOptions] - Texture options for GPU.\n     * @returns a shiny new texture of the container passed in\n     */\n    public generateTexture(options: GenerateTextureOptions | Container): Texture\n    {\n        if (options instanceof Container)\n        {\n            options = {\n                target: options,\n                frame: undefined,\n                textureSourceOptions: {},\n                resolution: undefined,\n            };\n        }\n\n        const resolution = options.resolution || this._renderer.resolution;\n        const antialias = options.antialias || this._renderer.view.antialias;\n\n        const container = options.target;\n\n        let clearColor = options.clearColor;\n\n        if (clearColor)\n        {\n            const isRGBAArray = Array.isArray(clearColor) && clearColor.length === 4;\n\n            clearColor = isRGBAArray ? clearColor : Color.shared.setValue(clearColor).toArray();\n        }\n        else\n        {\n            clearColor = noColor;\n        }\n\n        const region = options.frame?.copyTo(tempRect)\n            || getLocalBounds(container, tempBounds).rectangle;\n\n        region.width = Math.max(region.width, 1 / resolution) | 0;\n        region.height = Math.max(region.height, 1 / resolution) | 0;\n\n        const target = RenderTexture.create({\n            ...options.textureSourceOptions,\n            width: region.width,\n            height: region.height,\n            resolution,\n            antialias,\n        });\n\n        const transform = Matrix.shared.translate(-region.x, -region.y);\n\n        this._renderer.render({\n            container,\n            transform,\n            target,\n            clearColor,\n        });\n\n        return target;\n    }\n\n    public destroy(): void\n    {\n        (this._renderer as null) = null;\n    }\n}\n"],"names":["Rectangle","Bounds","Container","Color","getLocalBounds","RenderTexture","Matrix","ExtensionType"],"mappings":"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"}