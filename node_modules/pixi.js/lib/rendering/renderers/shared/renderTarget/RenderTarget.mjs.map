{"version":3,"file":"RenderTarget.mjs","sources":["../../../../../src/rendering/renderers/shared/renderTarget/RenderTarget.ts"],"sourcesContent":["// what we are building is a platform and a framework.\n// import { Matrix } from '../../shared/maths/Matrix';\nimport { uid } from '../../../../utils/data/uid';\nimport { TextureSource } from '../texture/sources/TextureSource';\nimport { Texture } from '../texture/Texture';\n\nimport type { BindableTexture } from '../texture/Texture';\n\n/**\n * Options for creating a render target.\n * @memberof rendering\n */\nexport interface RenderTargetOptions\n{\n    /** the width of the RenderTarget */\n    width?: number;\n    /** the height of the RenderTarget */\n    height?: number;\n    /** the resolution of the RenderTarget */\n    resolution?: number;\n    /** an array of textures, or a number indicating how many color textures there should be */\n    colorTextures?: BindableTexture[] | number;\n    /** should this render target have a stencil buffer? */\n    stencil?: boolean;\n    /** should this render target have a depth buffer? */\n    depth?: boolean;\n    /** a depth stencil texture that the depth and stencil outputs will be written to */\n    depthStencilTexture?: BindableTexture | boolean;\n    /** should this render target be antialiased? */\n    antialias?: boolean;\n    /** is this a root element, true if this is gl context owners render target */\n    isRoot?: boolean;\n}\n\n/**\n * A class that describes what the renderers are rendering to.\n * This can be as simple as a Texture, or as complex as a multi-texture, multi-sampled render target.\n * Support for stencil and depth buffers is also included.\n *\n * If you need something more complex than a Texture to render to, you should use this class.\n * Under the hood, all textures you render to have a RenderTarget created on their behalf.\n * @memberof rendering\n */\nexport class RenderTarget\n{\n    /** The default options for a render target */\n    public static defaultOptions: RenderTargetOptions = {\n        /** the width of the RenderTarget */\n        width: 0,\n        /** the height of the RenderTarget */\n        height: 0,\n        /** the resolution of the RenderTarget */\n        resolution: 1,\n        /** an array of textures, or a number indicating how many color textures there should be */\n        colorTextures: 1,\n        /** should this render target have a stencil buffer? */\n        stencil: false,\n        /** should this render target have a depth buffer? */\n        depth: false,\n        /** should this render target be antialiased? */\n        antialias: false, // save on perf by default!\n        /** is this a root element, true if this is gl context owners render target */\n        isRoot: false\n    };\n\n    public uid = uid('renderTarget');\n\n    /**\n     * An array of textures that can be written to by the GPU - mostly this has one texture in Pixi, but you could\n     * write to multiple if required! (eg deferred lighting)\n     */\n    public colorTextures: TextureSource[] = [];\n    /** the stencil and depth buffer will right to this texture in WebGPU */\n    public depthStencilTexture: TextureSource;\n    /** if true, will ensure a stencil buffer is added. For WebGPU, this will automatically create a depthStencilTexture */\n    public stencil: boolean;\n    /** if true, will ensure a depth buffer is added. For WebGPU, this will automatically create a depthStencilTexture */\n    public depth: boolean;\n\n    public dirtyId = 0;\n    public isRoot = false;\n\n    private readonly _size = new Float32Array(2);\n\n    /**\n     * @param [descriptor] - Options for creating a render target.\n     */\n    constructor(descriptor: RenderTargetOptions = {})\n    {\n        descriptor = { ...RenderTarget.defaultOptions, ...descriptor };\n\n        this.stencil = descriptor.stencil;\n        this.depth = descriptor.depth;\n        this.isRoot = descriptor.isRoot;\n\n        if (typeof descriptor.colorTextures === 'number')\n        {\n            for (let i = 0; i < descriptor.colorTextures; i++)\n            {\n                this.colorTextures.push(new TextureSource({\n                    width: descriptor.width,\n                    height: descriptor.height,\n                    resolution: descriptor.resolution,\n                    antialias: descriptor.antialias,\n                })\n                );\n            }\n        }\n        else\n        {\n            this.colorTextures = [...descriptor.colorTextures.map((texture) => texture.source)];\n\n            const colorSource = this.colorTexture.source;\n\n            this.resize(colorSource.width, colorSource.height, colorSource._resolution);\n        }\n\n        // the first color texture drives the size of all others..\n        this.colorTexture.source.on('resize', this.onSourceResize, this);\n\n        // TODO should listen for texture destroyed?\n\n        if (descriptor.depthStencilTexture || this.stencil)\n        {\n            // TODO add a test\n            if (descriptor.depthStencilTexture instanceof Texture\n                || descriptor.depthStencilTexture instanceof TextureSource)\n            {\n                this.depthStencilTexture = descriptor.depthStencilTexture.source;\n            }\n            else\n            {\n                this.ensureDepthStencilTexture();\n            }\n        }\n    }\n\n    get size(): [number, number]\n    {\n        const _size = this._size;\n\n        _size[0] = this.pixelWidth;\n        _size[1] = this.pixelHeight;\n\n        return _size as any as [number, number];\n    }\n\n    get width(): number\n    {\n        return this.colorTexture.source.width;\n    }\n\n    get height(): number\n    {\n        return this.colorTexture.source.height;\n    }\n    get pixelWidth(): number\n    {\n        return this.colorTexture.source.pixelWidth;\n    }\n\n    get pixelHeight(): number\n    {\n        return this.colorTexture.source.pixelHeight;\n    }\n\n    get resolution(): number\n    {\n        return this.colorTexture.source._resolution;\n    }\n\n    get colorTexture(): TextureSource\n    {\n        return this.colorTextures[0];\n    }\n\n    protected onSourceResize(source: TextureSource)\n    {\n        this.resize(source.width, source.height, source._resolution, true);\n    }\n\n    /**\n     * This will ensure a depthStencil texture is created for this render target.\n     * Most likely called by the mask system to make sure we have stencil buffer added.\n     * @internal\n     * @ignore\n     */\n    public ensureDepthStencilTexture()\n    {\n        if (!this.depthStencilTexture)\n        {\n            this.depthStencilTexture = new TextureSource({\n                width: this.width,\n                height: this.height,\n                resolution: this.resolution,\n                format: 'depth24plus-stencil8',\n                autoGenerateMipmaps: false,\n                antialias: false,\n                mipLevelCount: 1,\n                // sampleCount: handled by the render target system..\n            });\n        }\n    }\n\n    public resize(width: number, height: number, resolution = this.resolution, skipColorTexture = false)\n    {\n        this.dirtyId++;\n\n        this.colorTextures.forEach((colorTexture, i) =>\n        {\n            if (skipColorTexture && i === 0) return;\n\n            colorTexture.source.resize(width, height, resolution);\n        });\n\n        if (this.depthStencilTexture)\n        {\n            this.depthStencilTexture.source.resize(width, height, resolution);\n        }\n    }\n\n    public destroy()\n    {\n        this.colorTexture.source.off('resize', this.onSourceResize, this);\n\n        if (this.depthStencilTexture)\n        {\n            this.depthStencilTexture.destroy();\n            delete this.depthStencilTexture;\n        }\n    }\n}\n"],"names":[],"mappings":"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"}