{"version":3,"file":"uniformParsers.js","sources":["../../../../../../src/rendering/renderers/shared/shader/utils/uniformParsers.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/explicit-module-boundary-types */\n// Parsers, each one of these will take a look at the type of shader property and uniform.\n// if they pass the test function then the code function is called that returns a the shader upload code for that uniform.\n// Shader upload code is automagically generated with these parsers.\n// If no parser is valid then the default upload functions are used.\n// exposing Parsers means that custom upload logic can be added to pixi's shaders.\n// A good example would be a pixi rectangle can be directly set on a uniform.\n// If the shader sees it it knows how to upload the rectangle structure as a vec4\n// format is as follows:\n//\n// {\n//     test: (data, uniform) => {} <--- test is this code should be used for this uniform\n//     code: (name, uniform) => {} <--- returns the string of the piece of code that uploads the uniform\n//     codeUbo: (name, uniform) => {} <--- returns the string of the piece of code that uploads the\n//                                         uniform to a uniform buffer\n// }\n// import { Texture } from '../../texture/Texture';\n\nimport type { Color } from '../../../../../color/Color';\nimport type { Matrix } from '../../../../../maths/matrix/Matrix';\nimport type { PointLike } from '../../../../../maths/point/PointLike';\nimport type { Rectangle } from '../../../../../maths/shapes/Rectangle';\nimport type { UNIFORM_TYPES, UniformData } from '../types';\n\ninterface UniformParserDefinition\n{\n    type: UNIFORM_TYPES;\n    test(data: UniformData): boolean;\n    ubo?: string;\n    uboWgsl?: string;\n    uboStd40?: string;\n    uniform?: string;\n}\n\nexport const uniformParsers: UniformParserDefinition[] = [\n    // uploading pixi matrix object to mat3\n    {\n        type: 'mat3x3<f32>',\n        test: (data: UniformData): boolean =>\n        {\n            const value = data.value as Matrix;\n\n            return value.a !== undefined;\n        },\n        ubo: `\n            var matrix = uv[name].toArray(true);\n            data[offset] = matrix[0];\n            data[offset + 1] = matrix[1];\n            data[offset + 2] = matrix[2];\n            data[offset + 4] = matrix[3];\n            data[offset + 5] = matrix[4];\n            data[offset + 6] = matrix[5];\n            data[offset + 8] = matrix[6];\n            data[offset + 9] = matrix[7];\n            data[offset + 10] = matrix[8];\n        `,\n        uniform: ` \n            gl.uniformMatrix3fv(ud[name].location, false, uv[name].toArray(true));\n        `\n    },\n    // uploading a pixi rectangle as a vec4\n    {\n        type: 'vec4<f32>',\n        test: (data: UniformData): boolean =>\n            data.type === 'vec4<f32>' && data.size === 1 && (data.value as Rectangle).width !== undefined,\n        ubo: `\n            v = uv[name];\n            data[offset] = v.x;\n            data[offset + 1] = v.y;\n            data[offset + 2] = v.width;\n            data[offset + 3] = v.height;\n        `,\n        uniform: `\n            cv = ud[name].value;\n            v = uv[name];\n            if (cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height) {\n                cv[0] = v.x;\n                cv[1] = v.y;\n                cv[2] = v.width;\n                cv[3] = v.height;\n                gl.uniform4f(ud[name].location, v.x, v.y, v.width, v.height);\n            }\n        `\n    },\n    // uploading a pixi point as a vec2\n    {\n        type: 'vec2<f32>',\n        test: (data: UniformData): boolean =>\n            data.type === 'vec2<f32>' && data.size === 1 && (data.value as PointLike).x !== undefined,\n        ubo:  `\n            v = uv[name];\n            data[offset] = v.x;\n            data[offset + 1] = v.y;\n        `,\n        uniform: `\n            cv = ud[name].value;\n            v = uv[name];\n            if (cv[0] !== v.x || cv[1] !== v.y) {\n                cv[0] = v.x;\n                cv[1] = v.y;\n                gl.uniform2f(ud[name].location, v.x, v.y);\n            }\n        `\n    },\n    // uploading a pixi color as a vec4\n    {\n        type: 'vec4<f32>',\n        test: (data: UniformData): boolean =>\n            data.type === 'vec4<f32>' && data.size === 1 && (data.value as Color).red !== undefined,\n        ubo: `\n            v = uv[name];\n            data[offset] = v.red;\n            data[offset + 1] = v.green;\n            data[offset + 2] = v.blue;\n            data[offset + 3] = v.alpha;\n        `,\n        uniform: `\n            cv = ud[name].value;\n            v = uv[name];\n            if (cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue || cv[3] !== v.alpha) {\n                cv[0] = v.red;\n                cv[1] = v.green;\n                cv[2] = v.blue;\n                cv[3] = v.alpha;\n                gl.uniform4f(ud[name].location, v.red, v.green, v.blue, v.alpha);\n            }\n        `\n    },\n    // uploading a pixi color as a vec3\n    {\n        type: 'vec3<f32>',\n        test: (data: UniformData): boolean =>\n            data.type === 'vec3<f32>' && data.size === 1 && (data.value as Color).red !== undefined,\n        ubo: `\n            v = uv[name];\n            data[offset] = v.red;\n            data[offset + 1] = v.green;\n            data[offset + 2] = v.blue;\n        `,\n        uniform: `\n            cv = ud[name].value;\n            v = uv[name];\n            if (cv[0] !== v.red || cv[1] !== v.green || cv[2] !== v.blue) {\n                cv[0] = v.red;\n                cv[1] = v.green;\n                cv[2] = v.blue;\n                gl.uniform3f(ud[name].location, v.red, v.green, v.blue);\n            }\n        `\n    },\n];\n"],"names":[],"mappings":";;;AAkCO,MAAM,cAA4C,GAAA;AAAA;AAAA,EAErD;AAAA,IACI,IAAM,EAAA,aAAA;AAAA,IACN,IAAA,EAAM,CAAC,IACP,KAAA;AACI,MAAA,MAAM,QAAQ,IAAK,CAAA,KAAA,CAAA;AAEnB,MAAA,OAAO,MAAM,CAAM,KAAA,KAAA,CAAA,CAAA;AAAA,KACvB;AAAA,IACA,GAAK,EAAA,CAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,QAAA,CAAA;AAAA,IAYL,OAAS,EAAA,CAAA;AAAA;AAAA,QAAA,CAAA;AAAA,GAGb;AAAA;AAAA,EAEA;AAAA,IACI,IAAM,EAAA,WAAA;AAAA,IACN,IAAA,EAAM,CAAC,IAAA,KACH,IAAK,CAAA,IAAA,KAAS,WAAe,IAAA,IAAA,CAAK,IAAS,KAAA,CAAA,IAAM,IAAK,CAAA,KAAA,CAAoB,KAAU,KAAA,KAAA,CAAA;AAAA,IACxF,GAAK,EAAA,CAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,QAAA,CAAA;AAAA,IAOL,OAAS,EAAA,CAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,QAAA,CAAA;AAAA,GAWb;AAAA;AAAA,EAEA;AAAA,IACI,IAAM,EAAA,WAAA;AAAA,IACN,IAAA,EAAM,CAAC,IAAA,KACH,IAAK,CAAA,IAAA,KAAS,WAAe,IAAA,IAAA,CAAK,IAAS,KAAA,CAAA,IAAM,IAAK,CAAA,KAAA,CAAoB,CAAM,KAAA,KAAA,CAAA;AAAA,IACpF,GAAM,EAAA,CAAA;AAAA;AAAA;AAAA;AAAA,QAAA,CAAA;AAAA,IAKN,OAAS,EAAA,CAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,QAAA,CAAA;AAAA,GASb;AAAA;AAAA,EAEA;AAAA,IACI,IAAM,EAAA,WAAA;AAAA,IACN,IAAA,EAAM,CAAC,IAAA,KACH,IAAK,CAAA,IAAA,KAAS,WAAe,IAAA,IAAA,CAAK,IAAS,KAAA,CAAA,IAAM,IAAK,CAAA,KAAA,CAAgB,GAAQ,KAAA,KAAA,CAAA;AAAA,IAClF,GAAK,EAAA,CAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,QAAA,CAAA;AAAA,IAOL,OAAS,EAAA,CAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,QAAA,CAAA;AAAA,GAWb;AAAA;AAAA,EAEA;AAAA,IACI,IAAM,EAAA,WAAA;AAAA,IACN,IAAA,EAAM,CAAC,IAAA,KACH,IAAK,CAAA,IAAA,KAAS,WAAe,IAAA,IAAA,CAAK,IAAS,KAAA,CAAA,IAAM,IAAK,CAAA,KAAA,CAAgB,GAAQ,KAAA,KAAA,CAAA;AAAA,IAClF,GAAK,EAAA,CAAA;AAAA;AAAA;AAAA;AAAA;AAAA,QAAA,CAAA;AAAA,IAML,OAAS,EAAA,CAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,QAAA,CAAA;AAAA,GAUb;AACJ;;;;"}