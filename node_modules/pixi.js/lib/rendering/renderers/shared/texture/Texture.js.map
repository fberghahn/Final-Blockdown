{"version":3,"file":"Texture.js","sources":["../../../../../src/rendering/renderers/shared/texture/Texture.ts"],"sourcesContent":["import EventEmitter from 'eventemitter3';\nimport { groupD8 } from '../../../../maths/matrix/groupD8';\nimport { Rectangle } from '../../../../maths/shapes/Rectangle';\nimport { uid } from '../../../../utils/data/uid';\nimport { deprecation, v8_0_0 } from '../../../../utils/logging/deprecation';\nimport { NOOP } from '../../../../utils/misc/NOOP';\nimport { BufferImageSource } from './sources/BufferSource';\nimport { TextureSource } from './sources/TextureSource';\nimport { TextureMatrix } from './TextureMatrix';\n\nimport type { TextureResourceOrOptions } from './utils/textureFrom';\n\n/**\n * Stores the width of the non-scalable borders, for example when used with {@link scene.NineSlicePlane} texture.\n * @memberof rendering\n */\nexport interface TextureBorders\n{\n    /** left border in pixels */\n    left: number;\n    /** top border in pixels */\n    top: number;\n    /** right border in pixels */\n    right: number;\n    /** bottom border in pixels */\n    bottom: number;\n}\n\n/**\n * The UVs data structure for a texture.\n * @memberof rendering\n */\nexport type UVs = {\n    x0: number;\n    y0: number;\n    x1: number;\n    y1: number;\n    x2: number;\n    y2: number;\n    x3: number;\n    y3: number;\n};\n\n/**\n * The options that can be passed to a new Texture\n * @memberof rendering\n */\nexport interface TextureOptions\n{\n    /** the underlying texture data that this texture will use  */\n    source?: TextureSource;\n    /** optional label, for debugging */\n    label?: string;\n    /** The rectangle frame of the texture to show */\n    frame?: Rectangle;\n    /** The area of original texture */\n    orig?: Rectangle;\n    /** Trimmed rectangle of original texture */\n    trim?: Rectangle;\n    /** Default anchor point used for sprite placement / rotation */\n    defaultAnchor?: { x: number; y: number };\n    /** Default borders used for 9-slice scaling {@link NineSlicePlane}*/\n    defaultBorders?: TextureBorders;\n    /** indicates how the texture was rotated by texture packer. See {@link groupD8} */\n    rotate?: number;\n}\n\nexport interface BindableTexture\n{\n    source: TextureSource;\n}\n\nexport type TextureSourceLike = TextureSource | TextureResourceOrOptions | string;\n\n/**\n * A texture stores the information that represents an image or part of an image.\n *\n * A texture must have a loaded resource passed to it to work. It does not contain any\n * loading mechanisms.\n *\n * The Assets class can be used to load an texture from a file. This is the recommended\n * way as it will handle the loading and caching for you.\n *\n * ```js\n *\n * const texture = await Asset.load('assets/image.png');\n *\n * // once Assets has loaded the image it will be available via the from method\n * const sameTexture = Texture.from('assets/image.png');\n * // another way to acces the texture once loaded\n * const sameAgainTexture = Asset.get('assets/image.png');\n *\n * const sprite1 = new Sprite(texture);\n *\n * ```\n *\n * It cannot be added to the display list directly; instead use it as the texture for a Sprite.\n * If no frame is provided for a texture, then the whole image is used.\n *\n * You can directly create a texture from an image and then reuse it multiple times like this :\n *\n * ```js\n * import { Sprite, Texture } from 'pixi.js';\n *\n * const texture = await Asset.load('assets/image.png');\n * const sprite1 = new Sprite(texture);\n * const sprite2 = new Sprite(texture);\n * ```\n *\n * If you didn't pass the texture frame to constructor, it enables `noFrame` mode:\n * it subscribes on baseTexture events, it automatically resizes at the same time as baseTexture.\n * @memberof rendering\n * @class\n */\nexport class Texture extends EventEmitter<{\n    update: Texture\n    destroy: Texture\n}> implements BindableTexture\n{\n    /**\n     * Helper function that creates a returns Texture based on the source you provide.\n     * The source should be loaded and ready to go. If not its best to grab the asset using Assets.\n     * @param id - String or Source to create texture from\n     * @param skipCache - Skip adding the texture to the cache\n     * @returns The texture based on the Id provided\n     */\n    public static from: (id: TextureSourceLike, skipCache?: boolean) => Texture;\n\n    /** label used for debugging */\n    public label?: string;\n    /** unique id for this texture */\n    public uid = uid('texture');\n    /**\n     * Has the texture been destroyed?\n     * @readonly\n     */\n    public destroyed: boolean;\n\n    public _source: TextureSource;\n\n    /**\n     * Indicates whether the texture is rotated inside the atlas\n     * set to 2 to compensate for texture packer rotation\n     * set to 6 to compensate for spine packer rotation\n     * can be used to rotate or mirror sprites\n     * See {@link PIXI.groupD8} for explanation\n     */\n    public readonly rotate: number;\n    /** A uvs object based on the given frame and the texture source */\n    public readonly uvs: UVs = { x0: 0, y0: 0, x1: 0, y1: 0, x2: 0, y2: 0, x3: 0, y3: 0 };\n    /**\n     * Anchor point that is used as default if sprite is created with this texture.\n     * Changing the `defaultAnchor` at a later point of time will not update Sprite's anchor point.\n     * @default {0,0}\n     */\n    public readonly defaultAnchor?: { x: number; y: number };\n    /**\n     * Default width of the non-scalable border that is used if 9-slice plane is created with this texture.\n     * @since 7.2.0\n     * @see PIXI.NineSlicePlane\n     */\n    public readonly defaultBorders?: TextureBorders;\n    /**\n     * This is the area of the BaseTexture image to actually copy to the Canvas / WebGL when rendering,\n     * irrespective of the actual frame size or placement (which can be influenced by trimmed texture atlases)\n     */\n    public readonly frame = new Rectangle();\n    /** This is the area of original texture, before it was put in atlas. */\n    public readonly orig: Rectangle;\n    /**\n     * This is the trimmed area of original texture, before it was put in atlas\n     * Please call `updateUvs()` after you change coordinates of `trim` manually.\n     */\n    public readonly trim: Rectangle;\n\n    /**\n     * Does this Texture have any frame data assigned to it?\n     *\n     * This mode is enabled automatically if no frame was passed inside constructor.\n     *\n     * In this mode texture is subscribed to baseTexture events, and fires `update` on any change.\n     *\n     * Beware, after loading or resize of baseTexture event can fired two times!\n     * If you want more control, subscribe on baseTexture itself.\n     * @example\n     * texture.on('update', () => {});\n     */\n    public noFrame = false;\n\n    private _textureMatrix: TextureMatrix;\n\n    /** is it a texture? yes! used for type checking */\n    public readonly isTexture = true;\n\n    /**\n     * @param {TextureOptions} param0 - Options for the texture\n     */\n    constructor({\n        source,\n        label,\n        frame,\n        orig,\n        trim,\n        defaultAnchor,\n        defaultBorders,\n        rotate\n    }: TextureOptions = {})\n    {\n        super();\n\n        this.label = label;\n        this.source = source?.source ?? new TextureSource();\n\n        this.noFrame = !frame;\n\n        if (frame)\n        {\n            this.frame.copyFrom(frame);\n        }\n        else\n        {\n            const { width, height } = this._source;\n\n            this.frame.width = width;\n            this.frame.height = height;\n        }\n\n        this.orig = orig || this.frame;\n        this.trim = trim;\n\n        this.rotate = rotate ?? 0;\n        this.defaultAnchor = defaultAnchor;\n        this.defaultBorders = defaultBorders;\n\n        this.destroyed = false;\n\n        this.updateUvs();\n    }\n\n    set source(value: TextureSource)\n    {\n        if (this._source)\n        {\n            this._source.off('resize', this.update, this);\n        }\n\n        this._source = value;\n\n        value.on('resize', this.update, this);\n\n        this.emit('update', this);\n    }\n\n    /** the underlying source of the texture (equivalent of baseTexture in v7) */\n    get source(): TextureSource\n    {\n        return this._source;\n    }\n\n    /** returns a TextureMatrix instance for this texture. By default, that object is not created because its heavy. */\n    get textureMatrix()\n    {\n        if (!this._textureMatrix)\n        {\n            this._textureMatrix = new TextureMatrix(this);\n        }\n\n        return this._textureMatrix;\n    }\n\n    /** The width of the Texture in pixels. */\n    get width(): number\n    {\n        return this.orig.width;\n    }\n\n    /** The height of the Texture in pixels. */\n    get height(): number\n    {\n        return this.orig.height;\n    }\n\n    /** Call this function when you have modified the frame of this texture. */\n    public updateUvs()\n    {\n        const { uvs, frame } = this;\n        const { width, height } = this._source;\n\n        const nX = frame.x / width;\n        const nY = frame.y / height;\n\n        const nW = frame.width / width;\n        const nH = frame.height / height;\n\n        let rotate = this.rotate;\n\n        if (rotate)\n        {\n            // width and height div 2 div baseFrame size\n            const w2 = nW / 2;\n            const h2 = nH / 2;\n\n            // coordinates of center\n            const cX = nX + w2;\n            const cY = nY + h2;\n\n            rotate = groupD8.add(rotate, groupD8.NW); // NW is top-left corner\n            uvs.x0 = cX + (w2 * groupD8.uX(rotate));\n            uvs.y0 = cY + (h2 * groupD8.uY(rotate));\n\n            rotate = groupD8.add(rotate, 2); // rotate 90 degrees clockwise\n            uvs.x1 = cX + (w2 * groupD8.uX(rotate));\n            uvs.y1 = cY + (h2 * groupD8.uY(rotate));\n\n            rotate = groupD8.add(rotate, 2);\n            uvs.x2 = cX + (w2 * groupD8.uX(rotate));\n            uvs.y2 = cY + (h2 * groupD8.uY(rotate));\n\n            rotate = groupD8.add(rotate, 2);\n            uvs.x3 = cX + (w2 * groupD8.uX(rotate));\n            uvs.y3 = cY + (h2 * groupD8.uY(rotate));\n        }\n\n        else\n        {\n            uvs.x0 = nX;\n            uvs.y0 = nY;\n            uvs.x1 = nX + nW;\n            uvs.y1 = nY;\n            uvs.x2 = nX + nW;\n            uvs.y2 = nY + nH;\n            uvs.x3 = nX;\n            uvs.y3 = nY + nH;\n        }\n    }\n\n    /**\n     * Destroys this texture\n     * @param destroySource - Destroy the source when the texture is destroyed.\n     */\n    public destroy(destroySource = false)\n    {\n        if (this._source)\n        {\n            if (destroySource)\n            {\n                this._source.destroy();\n                this._source = null;\n            }\n        }\n\n        this._textureMatrix = null;\n        this.destroyed = true;\n        this.emit('destroy', this);\n        this.removeAllListeners();\n    }\n\n    /** call this if you have modified the `texture outside` of the constructor */\n    public update(): void\n    {\n        if (this.noFrame)\n        {\n            this.frame.width = this._source.width;\n            this.frame.height = this._source.height;\n        }\n\n        this.updateUvs();\n        this.emit('update', this);\n    }\n\n    /** @deprecated since 8.0.0 */\n    get baseTexture(): TextureSource\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'Texture.baseTexture is now Texture.source');\n        // #endif\n\n        return this._source;\n    }\n\n    /** an Empty Texture used internally by the engine */\n    public static EMPTY: Texture;\n    /** a White texture used internally by the engine */\n    public static WHITE: Texture;\n}\n\nTexture.EMPTY = new Texture({\n    label: 'EMPTY',\n    source: new TextureSource({\n        label: 'EMPTY',\n    })\n});\n\nTexture.EMPTY.destroy = NOOP;\n\nTexture.WHITE = new Texture({\n    source: new BufferImageSource({\n        resource: new Uint8Array([255, 255, 255, 255]),\n        width: 1,\n        height: 1,\n        alphaMode: 'premultiply-alpha-on-upload',\n        label: 'WHITE',\n    }),\n    label: 'WHITE',\n});\n\nTexture.WHITE.destroy = NOOP;\n"],"names":["uid","Rectangle","TextureSource","TextureMatrix","groupD8","deprecation","v8_0_0","NOOP","BufferImageSource"],"mappings":";;;;;;;;;;;;;AAkHO,MAAM,gBAAgB,YAI7B,CAAA;AAAA;AAAA;AAAA;AAAA,EA+EI,WAAY,CAAA;AAAA,IACR,MAAA;AAAA,IACA,KAAA;AAAA,IACA,KAAA;AAAA,IACA,IAAA;AAAA,IACA,IAAA;AAAA,IACA,aAAA;AAAA,IACA,cAAA;AAAA,IACA,MAAA;AAAA,GACJ,GAAoB,EACpB,EAAA;AACI,IAAM,KAAA,EAAA,CAAA;AA7EV;AAAA,IAAO,IAAA,CAAA,GAAA,GAAMA,QAAI,SAAS,CAAA,CAAA;AAkB1B;AAAA,IAAA,IAAA,CAAgB,MAAW,EAAE,EAAA,EAAI,CAAG,EAAA,EAAA,EAAI,GAAG,EAAI,EAAA,CAAA,EAAG,EAAI,EAAA,CAAA,EAAG,IAAI,CAAG,EAAA,EAAA,EAAI,GAAG,EAAI,EAAA,CAAA,EAAG,IAAI,CAAE,EAAA,CAAA;AAiBpF;AAAA;AAAA;AAAA;AAAA,IAAgB,IAAA,CAAA,KAAA,GAAQ,IAAIC,mBAAU,EAAA,CAAA;AAqBtC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAAA,IAAA,CAAO,OAAU,GAAA,KAAA,CAAA;AAKjB;AAAA,IAAA,IAAA,CAAgB,SAAY,GAAA,IAAA,CAAA;AAkBxB,IAAA,IAAA,CAAK,KAAQ,GAAA,KAAA,CAAA;AACb,IAAA,IAAA,CAAK,MAAS,GAAA,MAAA,EAAQ,MAAU,IAAA,IAAIC,2BAAc,EAAA,CAAA;AAElD,IAAA,IAAA,CAAK,UAAU,CAAC,KAAA,CAAA;AAEhB,IAAA,IAAI,KACJ,EAAA;AACI,MAAK,IAAA,CAAA,KAAA,CAAM,SAAS,KAAK,CAAA,CAAA;AAAA,KAG7B,MAAA;AACI,MAAA,MAAM,EAAE,KAAA,EAAO,MAAO,EAAA,GAAI,IAAK,CAAA,OAAA,CAAA;AAE/B,MAAA,IAAA,CAAK,MAAM,KAAQ,GAAA,KAAA,CAAA;AACnB,MAAA,IAAA,CAAK,MAAM,MAAS,GAAA,MAAA,CAAA;AAAA,KACxB;AAEA,IAAK,IAAA,CAAA,IAAA,GAAO,QAAQ,IAAK,CAAA,KAAA,CAAA;AACzB,IAAA,IAAA,CAAK,IAAO,GAAA,IAAA,CAAA;AAEZ,IAAA,IAAA,CAAK,SAAS,MAAU,IAAA,CAAA,CAAA;AACxB,IAAA,IAAA,CAAK,aAAgB,GAAA,aAAA,CAAA;AACrB,IAAA,IAAA,CAAK,cAAiB,GAAA,cAAA,CAAA;AAEtB,IAAA,IAAA,CAAK,SAAY,GAAA,KAAA,CAAA;AAEjB,IAAA,IAAA,CAAK,SAAU,EAAA,CAAA;AAAA,GACnB;AAAA,EAEA,IAAI,OAAO,KACX,EAAA;AACI,IAAA,IAAI,KAAK,OACT,EAAA;AACI,MAAA,IAAA,CAAK,OAAQ,CAAA,GAAA,CAAI,QAAU,EAAA,IAAA,CAAK,QAAQ,IAAI,CAAA,CAAA;AAAA,KAChD;AAEA,IAAA,IAAA,CAAK,OAAU,GAAA,KAAA,CAAA;AAEf,IAAA,KAAA,CAAM,EAAG,CAAA,QAAA,EAAU,IAAK,CAAA,MAAA,EAAQ,IAAI,CAAA,CAAA;AAEpC,IAAK,IAAA,CAAA,IAAA,CAAK,UAAU,IAAI,CAAA,CAAA;AAAA,GAC5B;AAAA;AAAA,EAGA,IAAI,MACJ,GAAA;AACI,IAAA,OAAO,IAAK,CAAA,OAAA,CAAA;AAAA,GAChB;AAAA;AAAA,EAGA,IAAI,aACJ,GAAA;AACI,IAAI,IAAA,CAAC,KAAK,cACV,EAAA;AACI,MAAK,IAAA,CAAA,cAAA,GAAiB,IAAIC,2BAAA,CAAc,IAAI,CAAA,CAAA;AAAA,KAChD;AAEA,IAAA,OAAO,IAAK,CAAA,cAAA,CAAA;AAAA,GAChB;AAAA;AAAA,EAGA,IAAI,KACJ,GAAA;AACI,IAAA,OAAO,KAAK,IAAK,CAAA,KAAA,CAAA;AAAA,GACrB;AAAA;AAAA,EAGA,IAAI,MACJ,GAAA;AACI,IAAA,OAAO,KAAK,IAAK,CAAA,MAAA,CAAA;AAAA,GACrB;AAAA;AAAA,EAGO,SACP,GAAA;AACI,IAAM,MAAA,EAAE,GAAK,EAAA,KAAA,EAAU,GAAA,IAAA,CAAA;AACvB,IAAA,MAAM,EAAE,KAAA,EAAO,MAAO,EAAA,GAAI,IAAK,CAAA,OAAA,CAAA;AAE/B,IAAM,MAAA,EAAA,GAAK,MAAM,CAAI,GAAA,KAAA,CAAA;AACrB,IAAM,MAAA,EAAA,GAAK,MAAM,CAAI,GAAA,MAAA,CAAA;AAErB,IAAM,MAAA,EAAA,GAAK,MAAM,KAAQ,GAAA,KAAA,CAAA;AACzB,IAAM,MAAA,EAAA,GAAK,MAAM,MAAS,GAAA,MAAA,CAAA;AAE1B,IAAA,IAAI,SAAS,IAAK,CAAA,MAAA,CAAA;AAElB,IAAA,IAAI,MACJ,EAAA;AAEI,MAAA,MAAM,KAAK,EAAK,GAAA,CAAA,CAAA;AAChB,MAAA,MAAM,KAAK,EAAK,GAAA,CAAA,CAAA;AAGhB,MAAA,MAAM,KAAK,EAAK,GAAA,EAAA,CAAA;AAChB,MAAA,MAAM,KAAK,EAAK,GAAA,EAAA,CAAA;AAEhB,MAAA,MAAA,GAASC,eAAQ,CAAA,GAAA,CAAI,MAAQ,EAAAA,eAAA,CAAQ,EAAE,CAAA,CAAA;AACvC,MAAA,GAAA,CAAI,EAAK,GAAA,EAAA,GAAM,EAAK,GAAAA,eAAA,CAAQ,GAAG,MAAM,CAAA,CAAA;AACrC,MAAA,GAAA,CAAI,EAAK,GAAA,EAAA,GAAM,EAAK,GAAAA,eAAA,CAAQ,GAAG,MAAM,CAAA,CAAA;AAErC,MAAS,MAAA,GAAAA,eAAA,CAAQ,GAAI,CAAA,MAAA,EAAQ,CAAC,CAAA,CAAA;AAC9B,MAAA,GAAA,CAAI,EAAK,GAAA,EAAA,GAAM,EAAK,GAAAA,eAAA,CAAQ,GAAG,MAAM,CAAA,CAAA;AACrC,MAAA,GAAA,CAAI,EAAK,GAAA,EAAA,GAAM,EAAK,GAAAA,eAAA,CAAQ,GAAG,MAAM,CAAA,CAAA;AAErC,MAAS,MAAA,GAAAA,eAAA,CAAQ,GAAI,CAAA,MAAA,EAAQ,CAAC,CAAA,CAAA;AAC9B,MAAA,GAAA,CAAI,EAAK,GAAA,EAAA,GAAM,EAAK,GAAAA,eAAA,CAAQ,GAAG,MAAM,CAAA,CAAA;AACrC,MAAA,GAAA,CAAI,EAAK,GAAA,EAAA,GAAM,EAAK,GAAAA,eAAA,CAAQ,GAAG,MAAM,CAAA,CAAA;AAErC,MAAS,MAAA,GAAAA,eAAA,CAAQ,GAAI,CAAA,MAAA,EAAQ,CAAC,CAAA,CAAA;AAC9B,MAAA,GAAA,CAAI,EAAK,GAAA,EAAA,GAAM,EAAK,GAAAA,eAAA,CAAQ,GAAG,MAAM,CAAA,CAAA;AACrC,MAAA,GAAA,CAAI,EAAK,GAAA,EAAA,GAAM,EAAK,GAAAA,eAAA,CAAQ,GAAG,MAAM,CAAA,CAAA;AAAA,KAIzC,MAAA;AACI,MAAA,GAAA,CAAI,EAAK,GAAA,EAAA,CAAA;AACT,MAAA,GAAA,CAAI,EAAK,GAAA,EAAA,CAAA;AACT,MAAA,GAAA,CAAI,KAAK,EAAK,GAAA,EAAA,CAAA;AACd,MAAA,GAAA,CAAI,EAAK,GAAA,EAAA,CAAA;AACT,MAAA,GAAA,CAAI,KAAK,EAAK,GAAA,EAAA,CAAA;AACd,MAAA,GAAA,CAAI,KAAK,EAAK,GAAA,EAAA,CAAA;AACd,MAAA,GAAA,CAAI,EAAK,GAAA,EAAA,CAAA;AACT,MAAA,GAAA,CAAI,KAAK,EAAK,GAAA,EAAA,CAAA;AAAA,KAClB;AAAA,GACJ;AAAA;AAAA;AAAA;AAAA;AAAA,EAMO,OAAA,CAAQ,gBAAgB,KAC/B,EAAA;AACI,IAAA,IAAI,KAAK,OACT,EAAA;AACI,MAAA,IAAI,aACJ,EAAA;AACI,QAAA,IAAA,CAAK,QAAQ,OAAQ,EAAA,CAAA;AACrB,QAAA,IAAA,CAAK,OAAU,GAAA,IAAA,CAAA;AAAA,OACnB;AAAA,KACJ;AAEA,IAAA,IAAA,CAAK,cAAiB,GAAA,IAAA,CAAA;AACtB,IAAA,IAAA,CAAK,SAAY,GAAA,IAAA,CAAA;AACjB,IAAK,IAAA,CAAA,IAAA,CAAK,WAAW,IAAI,CAAA,CAAA;AACzB,IAAA,IAAA,CAAK,kBAAmB,EAAA,CAAA;AAAA,GAC5B;AAAA;AAAA,EAGO,MACP,GAAA;AACI,IAAA,IAAI,KAAK,OACT,EAAA;AACI,MAAK,IAAA,CAAA,KAAA,CAAM,KAAQ,GAAA,IAAA,CAAK,OAAQ,CAAA,KAAA,CAAA;AAChC,MAAK,IAAA,CAAA,KAAA,CAAM,MAAS,GAAA,IAAA,CAAK,OAAQ,CAAA,MAAA,CAAA;AAAA,KACrC;AAEA,IAAA,IAAA,CAAK,SAAU,EAAA,CAAA;AACf,IAAK,IAAA,CAAA,IAAA,CAAK,UAAU,IAAI,CAAA,CAAA;AAAA,GAC5B;AAAA;AAAA,EAGA,IAAI,WACJ,GAAA;AAEI,IAAAC,uBAAA,CAAYC,oBAAQ,2CAA2C,CAAA,CAAA;AAG/D,IAAA,OAAO,IAAK,CAAA,OAAA,CAAA;AAAA,GAChB;AAMJ,CAAA;AAEA,OAAQ,CAAA,KAAA,GAAQ,IAAI,OAAQ,CAAA;AAAA,EACxB,KAAO,EAAA,OAAA;AAAA,EACP,MAAA,EAAQ,IAAIJ,2BAAc,CAAA;AAAA,IACtB,KAAO,EAAA,OAAA;AAAA,GACV,CAAA;AACL,CAAC,CAAA,CAAA;AAED,OAAA,CAAQ,MAAM,OAAU,GAAAK,SAAA,CAAA;AAExB,OAAQ,CAAA,KAAA,GAAQ,IAAI,OAAQ,CAAA;AAAA,EACxB,MAAA,EAAQ,IAAIC,8BAAkB,CAAA;AAAA,IAC1B,QAAA,EAAU,IAAI,UAAW,CAAA,CAAC,KAAK,GAAK,EAAA,GAAA,EAAK,GAAG,CAAC,CAAA;AAAA,IAC7C,KAAO,EAAA,CAAA;AAAA,IACP,MAAQ,EAAA,CAAA;AAAA,IACR,SAAW,EAAA,6BAAA;AAAA,IACX,KAAO,EAAA,OAAA;AAAA,GACV,CAAA;AAAA,EACD,KAAO,EAAA,OAAA;AACX,CAAC,CAAA,CAAA;AAED,OAAA,CAAQ,MAAM,OAAU,GAAAD,SAAA;;;;"}