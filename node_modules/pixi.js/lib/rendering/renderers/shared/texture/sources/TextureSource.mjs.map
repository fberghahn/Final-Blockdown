{"version":3,"file":"TextureSource.mjs","sources":["../../../../../../src/rendering/renderers/shared/texture/sources/TextureSource.ts"],"sourcesContent":["import EventEmitter from 'eventemitter3';\nimport { isPow2 } from '../../../../../maths/misc/pow2';\nimport { definedProps } from '../../../../../scene/container/utils/definedProps';\nimport { uid } from '../../../../../utils/data/uid';\nimport { TextureStyle } from '../TextureStyle';\n\nimport type { BindResource } from '../../../gpu/shader/BindResource';\nimport type { ALPHA_MODES, SCALE_MODE, TEXTURE_DIMENSIONS, TEXTURE_FORMATS, WRAP_MODE } from '../const';\nimport type { TextureStyleOptions } from '../TextureStyle';\n\n/**\n * options for creating a new TextureSource\n * @memberof rendering\n */\nexport interface TextureSourceOptions<T extends Record<string, any> = any> extends TextureStyleOptions\n{\n    /**\n     * the resource that will be upladed to the GPU. This is where we get our pixels from\n     * eg an ImageBimt / Canvas / Video etc\n     */\n    resource?: T;\n    /** the pixel width of this texture source. This is the REAL pure number, not accounting resolution */\n    width?: number;\n    /** the pixel height of this texture source. This is the REAL pure number, not accounting resolution */\n    height?: number;\n    /** the resolution of the texture. */\n    resolution?: number;\n    /** the format that the texture data has */\n    format?: TEXTURE_FORMATS;\n    /**\n     * Used by internal textures\n     * @ignore\n     */\n    sampleCount?: number;\n    /**\n     * Only really affects RenderTextures.\n     * Should we use antialiasing for this texture. It will look better, but may impact performance as a\n     * Blit operation will be required to resolve the texture.\n     */\n    antialias?: boolean;\n    /** how many dimensions does this texture have? currently v8 only supports 2d */\n    dimensions?: TEXTURE_DIMENSIONS;\n    /** The number of mip levels to generate for this texture. this is  overridden if autoGenerateMipmaps is true */\n    mipLevelCount?: number;\n    /**\n     * Should we auto generate mipmaps for this texture? This will automatically generate mipmaps\n     * for this texture when uploading to the GPU. Mipmapped textures take up more memory, but\n     * can look better when scaled down.\n     *\n     * For performance reasons, it is recommended to NOT use this with RenderTextures, as they are often updated every frame.\n     * If you do, make sure to call `updateMipmaps` after you update the texture.\n     */\n    autoGenerateMipmaps?: boolean;\n    /** the alpha mode of the texture */\n    alphaMode?: ALPHA_MODES;\n    /** optional label, can be used for debugging */\n    label?: string;\n    /** If true, the Garbage Collector will unload this texture if it is not used after a period of time */\n    autoGarbageCollect?: boolean;\n}\n\n/**\n * A TextureSource stores the information that represents an image.\n * All textures have require TextureSource, which contains information about the source.\n * Therefore you can have many textures all using a single TextureSource (eg a sprite sheet)\n *\n * This is an class is extended depending on the source of the texture.\n * Eg if you are using an an image as your resource, then an ImageSource is used.\n * @memberof rendering\n * @typeParam T - The TextureSource's Resource type.\n */\nexport class TextureSource<T extends Record<string, any> = any> extends EventEmitter<{\n    change: BindResource;\n    update: TextureSource;\n    unload: TextureSource;\n    destroy: TextureSource;\n    resize: TextureSource;\n    styleChange: TextureSource;\n    updateMipmaps: TextureSource;\n    error: Error;\n}> implements BindResource\n{\n    /** The default options used when creating a new TextureSource. override these to add your own defaults */\n    public static defaultOptions: TextureSourceOptions = {\n        resolution: 1,\n        format: 'bgra8unorm',\n        alphaMode: 'premultiply-alpha-on-upload',\n        dimensions: '2d',\n        mipLevelCount: 1,\n        autoGenerateMipmaps: false,\n        sampleCount: 1,\n        antialias: false,\n        autoGarbageCollect: false,\n    };\n\n    /** unique id for this Texture source */\n    public readonly uid = uid('textureSource');\n    /** optional label, can be used for debugging */\n    public label: string;\n\n    /**\n     * The resource type used by this TextureSource. This is used by the bind groups to determine\n     * how to handle this resource.\n     * @ignore\n     * @internal\n     */\n    public readonly _resourceType = 'textureSource';\n    /**\n     * i unique resource id, used by the bind group systems.\n     * This can change if the texture is resized or its resource changes\n     */\n    public _resourceId = uid('resource');\n    /**\n     * this is how the backends know how to upload this texture to the GPU\n     * It changes depending on the resource type. Classes that extend TextureSource\n     * should override this property.\n     * @ignore\n     * @internal\n     */\n    public uploadMethodId = 'unknown';\n\n    // dimensions\n    public _resolution = 1;\n\n    /** the pixel width of this texture source. This is the REAL pure number, not accounting resolution */\n    public pixelWidth = 1;\n    /** the pixel height of this texture source. This is the REAL pure number, not accounting resolution */\n    public pixelHeight = 1;\n\n    /**\n     * the width of this texture source, accounting for resolution\n     * eg pixelWidth 200, resolution 2, then width will be 100\n     */\n    public width = 1;\n    /**\n     * the height of this texture source, accounting for resolution\n     * eg pixelHeight 200, resolution 2, then height will be 100\n     */\n    public height = 1;\n\n    /**\n     * the resource that will be upladed to the GPU. This is where we get our pixels from\n     * eg an ImageBimt / Canvas / Video etc\n     */\n    public resource: T;\n\n    /**\n     * The number of samples of a multisample texture. This is always 1 for non-multisample textures.\n     * To enable multisample for a texture, set antialias to true\n     * @internal\n     * @ignore\n     */\n    public sampleCount = 1;\n\n    /** The number of mip levels to generate for this texture. this is  overridden if autoGenerateMipmaps is true */\n    public mipLevelCount = 1;\n    /**\n     * Should we auto generate mipmaps for this texture? This will automatically generate mipmaps\n     * for this texture when uploading to the GPU. Mipmapped textures take up more memory, but\n     * can look better when scaled down.\n     *\n     * For performance reasons, it is recommended to NOT use this with RenderTextures, as they are often updated every frame.\n     * If you do, make sure to call `updateMipmaps` after you update the texture.\n     */\n    public autoGenerateMipmaps = false;\n    /** the format that the texture data has */\n    public format: TEXTURE_FORMATS = 'rgba8unorm';\n    /** how many dimensions does this texture have? currently v8 only supports 2d */\n    public dimension: TEXTURE_DIMENSIONS = '2d';\n    /** the alpha mode of the texture */\n    public alphaMode: ALPHA_MODES;\n    private _style: TextureStyle;\n\n    /**\n     * Only really affects RenderTextures.\n     * Should we use antialiasing for this texture. It will look better, but may impact performance as a\n     * Blit operation will be required to resolve the texture.\n     */\n    public antialias = false;\n\n    /**\n     * Has the source been destroyed?\n     * @readonly\n     */\n    public destroyed: boolean;\n\n    /**\n     * Used by automatic texture Garbage Collection, stores last GC tick when it was bound\n     * @protected\n     */\n    public _touched = 0;\n\n    /**\n     * Used by the batcher to build texture batches. faster to have the variable here!\n     * @protected\n     */\n    public _batchTick = -1;\n    /**\n     * A temporary batch location for the texture batching. Here for performance reasons only!\n     * @protected\n     */\n    public _textureBindLocation = -1;\n\n    public isPowerOfTwo: boolean;\n\n    /** If true, the Garbage Collector will unload this texture if it is not used after a period of time */\n    public autoGarbageCollect: boolean;\n\n    /**\n     * used internally to know where a texture came from. Usually assigned by the asset loader!\n     * @ignore\n     */\n    public _sourceOrigin: string;\n\n    /**\n     * @param options - options for creating a new TextureSource\n     */\n    constructor(protected readonly options: TextureSourceOptions<T> = {})\n    {\n        super();\n\n        options = { ...TextureSource.defaultOptions, ...options };\n\n        this.label = options.label ?? '';\n        this.resource = options.resource;\n        this.autoGarbageCollect = options.autoGarbageCollect;\n        this._resolution = options.resolution;\n\n        if (options.width)\n        {\n            this.pixelWidth = options.width * this._resolution;\n        }\n        else\n        {\n            this.pixelWidth = this.resource ? (this.resourceWidth ?? 1) : 1;\n        }\n\n        if (options.height)\n        {\n            this.pixelHeight = options.height * this._resolution;\n        }\n        else\n        {\n            this.pixelHeight = this.resource ? (this.resourceHeight ?? 1) : 1;\n        }\n\n        this.width = this.pixelWidth / this._resolution;\n        this.height = this.pixelHeight / this._resolution;\n\n        this.format = options.format;\n        this.dimension = options.dimensions;\n        this.mipLevelCount = options.mipLevelCount;\n        this.autoGenerateMipmaps = options.autoGenerateMipmaps;\n        this.sampleCount = options.sampleCount;\n        this.antialias = options.antialias;\n        this.alphaMode = options.alphaMode;\n\n        this.style = new TextureStyle(definedProps(options));\n\n        this.destroyed = false;\n\n        this._refreshPOT();\n    }\n\n    /** returns itself */\n    get source(): TextureSource\n    {\n        return this;\n    }\n\n    /** the style of the texture */\n    get style(): TextureStyle\n    {\n        return this._style;\n    }\n\n    set style(value: TextureStyle)\n    {\n        if (this.style === value) return;\n\n        this._style?.off('change', this._onStyleChange, this);\n        this._style = value;\n        this._style?.on('change', this._onStyleChange, this);\n\n        this._onStyleChange();\n    }\n\n    /** setting this will set wrapModeU,wrapModeV and wrapModeW all at once! */\n    get addressMode(): WRAP_MODE\n    {\n        return this._style.addressMode;\n    }\n\n    set addressMode(value: WRAP_MODE)\n    {\n        this._style.addressMode = value;\n    }\n\n    /** setting this will set wrapModeU,wrapModeV and wrapModeW all at once! */\n    get repeatMode(): WRAP_MODE\n    {\n        return this._style.addressMode;\n    }\n\n    set repeatMode(value: WRAP_MODE)\n    {\n        this._style.addressMode = value;\n    }\n\n    /** Specifies the sampling behavior when the sample footprint is smaller than or equal to one texel. */\n    get magFilter(): SCALE_MODE\n    {\n        return this._style.magFilter;\n    }\n\n    set magFilter(value: SCALE_MODE)\n    {\n        this._style.magFilter = value;\n    }\n\n    /** Specifies the sampling behavior when the sample footprint is larger than one texel. */\n    get minFilter(): SCALE_MODE\n    {\n        return this._style.minFilter;\n    }\n\n    set minFilter(value: SCALE_MODE)\n    {\n        this._style.minFilter = value;\n    }\n\n    /** Specifies behavior for sampling between mipmap levels. */\n    get mipmapFilter(): SCALE_MODE\n    {\n        return this._style.mipmapFilter;\n    }\n\n    set mipmapFilter(value: SCALE_MODE)\n    {\n        this._style.mipmapFilter = value;\n    }\n\n    /** Specifies the minimum and maximum levels of detail, respectively, used internally when sampling a texture. */\n    get lodMinClamp(): number\n    {\n        return this._style.lodMinClamp;\n    }\n\n    set lodMinClamp(value: number)\n    {\n        this._style.lodMinClamp = value;\n    }\n\n    /** Specifies the minimum and maximum levels of detail, respectively, used internally when sampling a texture. */\n    get lodMaxClamp(): number\n    {\n        return this._style.lodMaxClamp;\n    }\n\n    set lodMaxClamp(value: number)\n    {\n        this._style.lodMaxClamp = value;\n    }\n\n    private _onStyleChange()\n    {\n        this.emit('styleChange', this);\n    }\n\n    /** call this if you have modified the texture outside of the constructor */\n    public update()\n    {\n        // update resource...\n        if (this.resource)\n        {\n            const resolution = this._resolution;\n\n            const didResize = this.resize(this.resourceWidth / resolution, this.resourceHeight / resolution);\n\n            // no ned to dispatch the update we resized as that will\n            // notify the texture systems anyway\n            if (didResize) return;\n        }\n\n        this.emit('update', this);\n    }\n\n    /** Destroys this texture source */\n    public destroy()\n    {\n        this.destroyed = true;\n        this.emit('destroy', this);\n\n        if (this._style)\n        {\n            this._style.destroy();\n            this._style = null;\n        }\n\n        this.uploadMethodId = null;\n        this.resource = null;\n        this.removeAllListeners();\n    }\n\n    /**\n     * This will unload the Texture source from the GPU. This will free up the GPU memory\n     * As soon as it is required fore rendering, it will be re-uploaded.\n     */\n    public unload()\n    {\n        this._resourceId = uid('resource');\n        this.emit('change', this);\n        this.emit('unload', this);\n    }\n\n    /** the width of the resource. This is the REAL pure number, not accounting resolution   */\n    public get resourceWidth(): number\n    {\n        const { resource } = this;\n\n        return resource.naturalWidth || resource.videoWidth || resource.displayWidth || resource.width;\n    }\n\n    /** the height of the resource. This is the REAL pure number, not accounting resolution */\n    public get resourceHeight(): number\n    {\n        const { resource } = this;\n\n        return resource.naturalHeight || resource.videoHeight || resource.displayHeight || resource.height;\n    }\n\n    /**\n     * the resolution of the texture. Changing this number, will not change the number of pixels in the actual texture\n     * but will the size of the texture when rendered.\n     *\n     * changing the resolution of this texture to 2 for example will make it appear twice as small when rendered (as pixel\n     * density will have increased)\n     */\n    get resolution(): number\n    {\n        return this._resolution;\n    }\n\n    set resolution(resolution: number)\n    {\n        if (this._resolution === resolution) return;\n\n        this._resolution = resolution;\n\n        this.width = this.pixelWidth / resolution;\n        this.height = this.pixelHeight / resolution;\n    }\n\n    /**\n     * Resize the texture, this is handy if you want to use the texture as a render texture\n     * @param width - the new width of the texture\n     * @param height - the new height of the texture\n     * @param resolution - the new resolution of the texture\n     * @returns - if the texture was resized\n     */\n    public resize(width?: number, height?: number, resolution?: number): boolean\n    {\n        resolution = resolution || this._resolution;\n        width = width || this.width;\n        height = height || this.height;\n\n        // make sure we work with rounded pixels\n        const newPixelWidth = Math.round(width * resolution);\n        const newPixelHeight = Math.round(height * resolution);\n\n        this.width = newPixelWidth / resolution;\n        this.height = newPixelHeight / resolution;\n\n        this._resolution = resolution;\n\n        if (this.pixelWidth === newPixelWidth && this.pixelHeight === newPixelHeight)\n        {\n            return false;\n        }\n\n        this._refreshPOT();\n\n        this.pixelWidth = newPixelWidth;\n        this.pixelHeight = newPixelHeight;\n\n        this.emit('resize', this);\n\n        this._resourceId = uid('resource');\n        this.emit('change', this);\n\n        return true;\n    }\n\n    /**\n     * Lets the renderer know that this texture has been updated and its mipmaps should be re-generated.\n     * This is only important for RenderTexture instances, as standard Texture instances will have their\n     * mipmaps generated on upload. You should call this method after you make any change to the texture\n     *\n     * The reason for this is is can be quite expensive to update mipmaps for a texture. So by default,\n     * We want you, the developer to specify when this action should happen.\n     *\n     * Generally you don't want to have mipmaps generated on Render targets that are changed every frame,\n     */\n    public updateMipmaps()\n    {\n        if (this.autoGenerateMipmaps && this.mipLevelCount > 1)\n        {\n            this.emit('updateMipmaps', this);\n        }\n    }\n\n    set wrapMode(value: WRAP_MODE)\n    {\n        this._style.wrapMode = value;\n    }\n\n    get wrapMode(): WRAP_MODE\n    {\n        return this._style.wrapMode;\n    }\n\n    set scaleMode(value: SCALE_MODE)\n    {\n        this._style.scaleMode = value;\n    }\n\n    /** setting this will set magFilter,minFilter and mipmapFilter all at once!  */\n    get scaleMode(): SCALE_MODE\n    {\n        return this._style.scaleMode;\n    }\n\n    /**\n     * Refresh check for isPowerOfTwo texture based on size\n     * @private\n     */\n    protected _refreshPOT(): void\n    {\n        this.isPowerOfTwo = isPow2(this.pixelWidth) && isPow2(this.pixelHeight);\n    }\n\n    public static test(_resource: any): any\n    {\n        // this should be overridden by other sources..\n        throw new Error('Unimplemented');\n    }\n}\n"],"names":[],"mappings":"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"}