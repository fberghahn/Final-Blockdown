{"version":3,"file":"textureFrom.js","sources":["../../../../../../src/rendering/renderers/shared/texture/utils/textureFrom.ts"],"sourcesContent":["import { Cache } from '../../../../../assets/cache/Cache';\nimport { extensions, ExtensionType } from '../../../../../extensions/Extensions';\nimport { TextureSource } from '../sources/TextureSource';\nimport { Texture } from '../Texture';\n\nimport type { TypedArray } from '../../buffer/Buffer';\nimport type { BufferSourceOptions } from '../sources/BufferSource';\nimport type { ImageResource } from '../sources/ImageSource';\nimport type { TextureSourceOptions } from '../sources/TextureSource';\nimport type { TextureSourceLike } from '../Texture';\n\ninterface TextureSourceConstructor<T extends TextureSource = TextureSource>\n{\n    new (options: TextureSourceOptions): T;\n    test(options: ImageResource | TypedArray | ArrayBuffer): boolean;\n}\n\nconst sources: TextureSourceConstructor[] = [];\n\nextensions.handleByList(ExtensionType.TextureSource, sources);\n\nexport type TextureResourceOrOptions =\n  ImageResource\n  | TextureSourceOptions<ImageResource>\n  | BufferSourceOptions;\n\nexport function autoDetectSource(options: TextureResourceOrOptions = {}): TextureSource\n{\n    const hasResource = options && (options as TextureSourceOptions).resource;\n    const res = hasResource ? (options as TextureSourceOptions).resource : options;\n    const opts = hasResource ? options as TextureSourceOptions : { resource: options } as TextureSourceOptions;\n\n    for (let i = 0; i < sources.length; i++)\n    {\n        const Source = sources[i];\n\n        if (Source.test(res))\n        {\n            return new Source(opts);\n        }\n    }\n\n    throw new Error(`Could not find a source type for resource: ${opts.resource}`);\n}\n\nexport function resourceToTexture(\n    options: TextureResourceOrOptions = {},\n    skipCache = false\n): Texture\n{\n    const hasResource = options && (options as TextureSourceOptions).resource;\n    const resource = hasResource ? (options as TextureSourceOptions).resource : options;\n    const opts = hasResource ? options as TextureSourceOptions : { resource: options } as TextureSourceOptions;\n\n    if (!skipCache && Cache.has(resource))\n    {\n        return Cache.get(resource);\n    }\n\n    const texture = new Texture({ source: autoDetectSource(opts) });\n\n    texture.on('destroy', () =>\n    {\n        if (Cache.has(resource))\n        {\n            Cache.remove(resource);\n        }\n    });\n\n    if (!skipCache)\n    {\n        Cache.set(resource, texture);\n    }\n\n    return texture;\n}\n\n/**\n * Helper function that creates a returns Texture based on the source you provide.\n * The source should be loaded and ready to go. If not its best to grab the asset using Assets.\n * @param id - String or Source to create texture from\n * @param skipCache - Skip adding the texture to the cache\n * @returns The texture based on the Id provided\n */\nexport function textureFrom(id: TextureSourceLike, skipCache = false): Texture\n{\n    if (typeof id === 'string')\n    {\n        return Cache.get(id);\n    }\n    else if (id instanceof TextureSource)\n    {\n        return new Texture({ source: id });\n    }\n\n    // return a auto generated texture from resource\n    return resourceToTexture(id, skipCache);\n}\n\nTexture.from = textureFrom;\n"],"names":["extensions","ExtensionType","Cache","Texture","TextureSource"],"mappings":";;;;;;;;AAiBA,MAAM,UAAsC,EAAC,CAAA;AAE7CA,qBAAW,CAAA,YAAA,CAAaC,wBAAc,CAAA,aAAA,EAAe,OAAO,CAAA,CAAA;AAO5C,SAAA,gBAAA,CAAiB,OAAoC,GAAA,EACrE,EAAA;AACI,EAAM,MAAA,WAAA,GAAc,WAAY,OAAiC,CAAA,QAAA,CAAA;AACjE,EAAM,MAAA,GAAA,GAAM,WAAe,GAAA,OAAA,CAAiC,QAAW,GAAA,OAAA,CAAA;AACvE,EAAA,MAAM,IAAO,GAAA,WAAA,GAAc,OAAkC,GAAA,EAAE,UAAU,OAAQ,EAAA,CAAA;AAEjF,EAAA,KAAA,IAAS,CAAI,GAAA,CAAA,EAAG,CAAI,GAAA,OAAA,CAAQ,QAAQ,CACpC,EAAA,EAAA;AACI,IAAM,MAAA,MAAA,GAAS,QAAQ,CAAC,CAAA,CAAA;AAExB,IAAI,IAAA,MAAA,CAAO,IAAK,CAAA,GAAG,CACnB,EAAA;AACI,MAAO,OAAA,IAAI,OAAO,IAAI,CAAA,CAAA;AAAA,KAC1B;AAAA,GACJ;AAEA,EAAA,MAAM,IAAI,KAAA,CAAM,CAA8C,2CAAA,EAAA,IAAA,CAAK,QAAQ,CAAE,CAAA,CAAA,CAAA;AACjF,CAAA;AAEO,SAAS,iBACZ,CAAA,OAAA,GAAoC,EAAC,EACrC,YAAY,KAEhB,EAAA;AACI,EAAM,MAAA,WAAA,GAAc,WAAY,OAAiC,CAAA,QAAA,CAAA;AACjE,EAAM,MAAA,QAAA,GAAW,WAAe,GAAA,OAAA,CAAiC,QAAW,GAAA,OAAA,CAAA;AAC5E,EAAA,MAAM,IAAO,GAAA,WAAA,GAAc,OAAkC,GAAA,EAAE,UAAU,OAAQ,EAAA,CAAA;AAEjF,EAAA,IAAI,CAAC,SAAA,IAAaC,WAAM,CAAA,GAAA,CAAI,QAAQ,CACpC,EAAA;AACI,IAAO,OAAAA,WAAA,CAAM,IAAI,QAAQ,CAAA,CAAA;AAAA,GAC7B;AAEA,EAAM,MAAA,OAAA,GAAU,IAAIC,eAAQ,CAAA,EAAE,QAAQ,gBAAiB,CAAA,IAAI,GAAG,CAAA,CAAA;AAE9D,EAAQ,OAAA,CAAA,EAAA,CAAG,WAAW,MACtB;AACI,IAAI,IAAAD,WAAA,CAAM,GAAI,CAAA,QAAQ,CACtB,EAAA;AACI,MAAAA,WAAA,CAAM,OAAO,QAAQ,CAAA,CAAA;AAAA,KACzB;AAAA,GACH,CAAA,CAAA;AAED,EAAA,IAAI,CAAC,SACL,EAAA;AACI,IAAMA,WAAA,CAAA,GAAA,CAAI,UAAU,OAAO,CAAA,CAAA;AAAA,GAC/B;AAEA,EAAO,OAAA,OAAA,CAAA;AACX,CAAA;AASgB,SAAA,WAAA,CAAY,EAAuB,EAAA,SAAA,GAAY,KAC/D,EAAA;AACI,EAAI,IAAA,OAAO,OAAO,QAClB,EAAA;AACI,IAAO,OAAAA,WAAA,CAAM,IAAI,EAAE,CAAA,CAAA;AAAA,GACvB,MAAA,IACS,cAAcE,2BACvB,EAAA;AACI,IAAA,OAAO,IAAID,eAAA,CAAQ,EAAE,MAAA,EAAQ,IAAI,CAAA,CAAA;AAAA,GACrC;AAGA,EAAO,OAAA,iBAAA,CAAkB,IAAI,SAAS,CAAA,CAAA;AAC1C,CAAA;AAEAA,eAAA,CAAQ,IAAO,GAAA,WAAA;;;;;;"}