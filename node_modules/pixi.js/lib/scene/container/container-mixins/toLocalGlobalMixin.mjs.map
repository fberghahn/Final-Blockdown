{"version":3,"file":"toLocalGlobalMixin.mjs","sources":["../../../../src/scene/container/container-mixins/toLocalGlobalMixin.ts"],"sourcesContent":["import { Matrix } from '../../../maths/matrix/Matrix';\nimport { Point } from '../../../maths/point/Point';\nimport { updateTransformBackwards } from '../bounds/getGlobalBounds';\n\nimport type { PointData } from '../../../maths/point/PointData';\nimport type { Container } from '../Container';\n\nexport interface ToLocalGlobalMixin\n{\n    getGlobalPosition(point?: Point, skipUpdate?: boolean): Point;\n    toGlobal<P extends PointData = Point>(position: PointData, point?: P, skipUpdate?: boolean): P;\n    toLocal<P extends PointData = Point>(position: PointData, from?: Container, point?: P, skipUpdate?: boolean): P;\n}\n\nexport const toLocalGlobalMixin: Partial<Container> = {\n    /**\n     * Returns the global position of the container.\n     * @param point - The optional point to write the global value to.\n     * @param skipUpdate - Should we skip the update transform.\n     * @returns - The updated point.\n     * @memberof scene.Container#\n     */\n    getGlobalPosition(point: Point = new Point(), skipUpdate = false): Point\n    {\n        if (this.parent)\n        {\n            this.parent.toGlobal(this._position, point, skipUpdate);\n        }\n        else\n        {\n            point.x = this._position.x;\n            point.y = this._position.y;\n        }\n\n        return point;\n    },\n\n    /**\n     * Calculates the global position of the container.\n     * @param position - The world origin to calculate from.\n     * @param point - A Point object in which to store the value, optional\n     *  (otherwise will create a new Point).\n     * @param skipUpdate - Should we skip the update transform.\n     * @returns - A point object representing the position of this object.\n     * @memberof scene.Container#\n     */\n    toGlobal<P extends PointData = Point>(position: PointData, point?: P, skipUpdate = false): P\n    {\n        if (!skipUpdate)\n        {\n            this.updateLocalTransform();\n\n            const globalMatrix = updateTransformBackwards(this, new Matrix());\n\n            globalMatrix.append(this.localTransform);\n\n            return globalMatrix.apply<P>(position, point);\n        }\n\n        // simply apply the matrix..\n        return this.worldTransform.apply<P>(position, point);\n    },\n\n    /**\n     * Calculates the local position of the container relative to another point.\n     * @param position - The world origin to calculate from.\n     * @param from - The Container to calculate the global position from.\n     * @param point - A Point object in which to store the value, optional\n     *  (otherwise will create a new Point).\n     * @param skipUpdate - Should we skip the update transform\n     * @returns - A point object representing the position of this object\n     * @memberof scene.Container#\n     */\n    toLocal<P extends PointData = Point>(position: PointData, from?: Container, point?: P, skipUpdate?: boolean): P\n    {\n        if (from)\n        {\n            position = from.toGlobal(position, point, skipUpdate);\n        }\n\n        if (!skipUpdate)\n        {\n            this.updateLocalTransform();\n\n            const globalMatrix = updateTransformBackwards(this, new Matrix());\n\n            globalMatrix.append(this.localTransform);\n\n            return globalMatrix.applyInverse<P>(position, point);\n        }\n\n        // simply apply the matrix..\n        return this.worldTransform.applyInverse<P>(position, point);\n    }\n} as Container;\n"],"names":[],"mappings":";;;;;AAcO,MAAM,kBAAyC,GAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQlD,kBAAkB,KAAe,GAAA,IAAI,KAAM,EAAA,EAAG,aAAa,KAC3D,EAAA;AACI,IAAA,IAAI,KAAK,MACT,EAAA;AACI,MAAA,IAAA,CAAK,MAAO,CAAA,QAAA,CAAS,IAAK,CAAA,SAAA,EAAW,OAAO,UAAU,CAAA,CAAA;AAAA,KAG1D,MAAA;AACI,MAAM,KAAA,CAAA,CAAA,GAAI,KAAK,SAAU,CAAA,CAAA,CAAA;AACzB,MAAM,KAAA,CAAA,CAAA,GAAI,KAAK,SAAU,CAAA,CAAA,CAAA;AAAA,KAC7B;AAEA,IAAO,OAAA,KAAA,CAAA;AAAA,GACX;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWA,QAAsC,CAAA,QAAA,EAAqB,KAAW,EAAA,UAAA,GAAa,KACnF,EAAA;AACI,IAAA,IAAI,CAAC,UACL,EAAA;AACI,MAAA,IAAA,CAAK,oBAAqB,EAAA,CAAA;AAE1B,MAAA,MAAM,YAAe,GAAA,wBAAA,CAAyB,IAAM,EAAA,IAAI,QAAQ,CAAA,CAAA;AAEhE,MAAa,YAAA,CAAA,MAAA,CAAO,KAAK,cAAc,CAAA,CAAA;AAEvC,MAAO,OAAA,YAAA,CAAa,KAAS,CAAA,QAAA,EAAU,KAAK,CAAA,CAAA;AAAA,KAChD;AAGA,IAAA,OAAO,IAAK,CAAA,cAAA,CAAe,KAAS,CAAA,QAAA,EAAU,KAAK,CAAA,CAAA;AAAA,GACvD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAYA,OAAqC,CAAA,QAAA,EAAqB,IAAkB,EAAA,KAAA,EAAW,UACvF,EAAA;AACI,IAAA,IAAI,IACJ,EAAA;AACI,MAAA,QAAA,GAAW,IAAK,CAAA,QAAA,CAAS,QAAU,EAAA,KAAA,EAAO,UAAU,CAAA,CAAA;AAAA,KACxD;AAEA,IAAA,IAAI,CAAC,UACL,EAAA;AACI,MAAA,IAAA,CAAK,oBAAqB,EAAA,CAAA;AAE1B,MAAA,MAAM,YAAe,GAAA,wBAAA,CAAyB,IAAM,EAAA,IAAI,QAAQ,CAAA,CAAA;AAEhE,MAAa,YAAA,CAAA,MAAA,CAAO,KAAK,cAAc,CAAA,CAAA;AAEvC,MAAO,OAAA,YAAA,CAAa,YAAgB,CAAA,QAAA,EAAU,KAAK,CAAA,CAAA;AAAA,KACvD;AAGA,IAAA,OAAO,IAAK,CAAA,cAAA,CAAe,YAAgB,CAAA,QAAA,EAAU,KAAK,CAAA,CAAA;AAAA,GAC9D;AACJ;;;;"}