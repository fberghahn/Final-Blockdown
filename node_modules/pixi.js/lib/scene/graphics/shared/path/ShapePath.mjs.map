{"version":3,"file":"ShapePath.mjs","sources":["../../../../../src/scene/graphics/shared/path/ShapePath.ts"],"sourcesContent":["// a shape lets you build out a shape with lines and curves and primitives..\n\nimport { Circle } from '../../../../maths/shapes/Circle';\nimport { Ellipse } from '../../../../maths/shapes/Ellipse';\nimport { Polygon } from '../../../../maths/shapes/Polygon';\nimport { Rectangle } from '../../../../maths/shapes/Rectangle';\nimport { RoundedRectangle } from '../../../../maths/shapes/RoundedRectangle';\nimport { Bounds } from '../../../container/bounds/Bounds';\nimport { buildAdaptiveBezier } from '../buildCommands/buildAdaptiveBezier';\nimport { buildAdaptiveQuadratic } from '../buildCommands/buildAdaptiveQuadratic';\nimport { buildArc } from '../buildCommands/buildArc';\nimport { buildArcTo } from '../buildCommands/buildArcTo';\nimport { buildArcToSvg } from '../buildCommands/buildArcToSvg';\nimport { roundedShapeArc, roundedShapeQuadraticCurve } from './roundShape';\n\nimport type { Matrix } from '../../../../maths/matrix/Matrix';\nimport type { PointData } from '../../../../maths/point/PointData';\nimport type { ShapePrimitive } from '../../../../maths/shapes/ShapePrimitive';\nimport type { GraphicsPath } from './GraphicsPath';\nimport type { RoundedPoint } from './roundShape';\n\nconst tempRectangle = new Rectangle();\n\n/**\n * The `ShapePath` class acts as a bridge between high-level drawing commands\n * and the lower-level `GraphicsContext` rendering engine.\n * It translates drawing commands, such as those for creating lines, arcs, ellipses, rectangles, and complex polygons, into a\n * format that can be efficiently processed by a `GraphicsContext`. This includes handling path starts,\n * ends, and transformations for shapes.\n *\n * It is used internally by `GraphicsPath` to build up the path.\n * @memberof scene\n */\nexport class ShapePath\n{\n    /** The list of shape primitives that make up the path. */\n    public shapePrimitives: { shape: ShapePrimitive, transform?: Matrix }[] = [];\n    private _currentPoly: Polygon | null = null;\n    private readonly _graphicsPath2D: GraphicsPath;\n    private readonly _bounds = new Bounds();\n\n    constructor(graphicsPath2D: GraphicsPath)\n    {\n        this._graphicsPath2D = graphicsPath2D;\n    }\n\n    /**\n     * Sets the starting point for a new sub-path. Any subsequent drawing commands are considered part of this path.\n     * @param x - The x-coordinate for the starting point.\n     * @param y - The y-coordinate for the starting point.\n     * @returns The instance of the current object for chaining.\n     */\n    public moveTo(x: number, y: number): this\n    {\n        this.startPoly(x, y);\n\n        return this;\n    }\n\n    /**\n     * Connects the current point to a new point with a straight line. This method updates the current path.\n     * @param x - The x-coordinate of the new point to connect to.\n     * @param y - The y-coordinate of the new point to connect to.\n     * @returns The instance of the current object for chaining.\n     */\n    public lineTo(x: number, y: number): this\n    {\n        this._ensurePoly();\n\n        const points = this._currentPoly.points;\n\n        const fromX = points[points.length - 2];\n        const fromY = points[points.length - 1];\n\n        if (fromX !== x || fromY !== y)\n        {\n            points.push(x, y);\n        }\n\n        return this;\n    }\n\n    /**\n     * Adds an arc to the path. The arc is centered at (x, y)\n     *  position with radius `radius` starting at `startAngle` and ending at `endAngle`.\n     * @param x - The x-coordinate of the arc's center.\n     * @param y - The y-coordinate of the arc's center.\n     * @param radius - The radius of the arc.\n     * @param startAngle - The starting angle of the arc, in radians.\n     * @param endAngle - The ending angle of the arc, in radians.\n     * @param counterclockwise - Specifies whether the arc should be drawn in the anticlockwise direction. False by default.\n     * @returns The instance of the current object for chaining.\n     */\n    public arc(x: number, y: number, radius: number, startAngle: number, endAngle: number, counterclockwise: boolean): this\n    {\n        // TODO - if its 360 degrees.. make it a circle object?\n\n        this._ensurePoly(false);\n\n        const points = this._currentPoly.points;\n\n        buildArc(points, x, y, radius, startAngle, endAngle, counterclockwise);\n\n        return this;\n    }\n\n    /**\n     * Adds an arc to the path with the arc tangent to the line joining two specified points.\n     * The arc radius is specified by `radius`.\n     * @param x1 - The x-coordinate of the first point.\n     * @param y1 - The y-coordinate of the first point.\n     * @param x2 - The x-coordinate of the second point.\n     * @param y2 - The y-coordinate of the second point.\n     * @param radius - The radius of the arc.\n     * @returns The instance of the current object for chaining.\n     */\n    public arcTo(x1: number, y1: number, x2: number, y2: number, radius: number): this\n    {\n        this._ensurePoly();\n\n        const points = this._currentPoly.points;\n\n        buildArcTo(points, x1, y1, x2, y2, radius);\n\n        return this;\n    }\n\n    /**\n     * Adds an SVG-style arc to the path, allowing for elliptical arcs based on the SVG spec.\n     * @param rx - The x-radius of the ellipse.\n     * @param ry - The y-radius of the ellipse.\n     * @param xAxisRotation - The rotation of the ellipse's x-axis relative\n     * to the x-axis of the coordinate system, in degrees.\n     * @param largeArcFlag - Determines if the arc should be greater than or less than 180 degrees.\n     * @param sweepFlag - Determines if the arc should be swept in a positive angle direction.\n     * @param x - The x-coordinate of the arc's end point.\n     * @param y - The y-coordinate of the arc's end point.\n     * @returns The instance of the current object for chaining.\n     */\n    public arcToSvg(\n        rx: number, ry: number,\n        xAxisRotation: number, largeArcFlag: number, sweepFlag: number,\n        x: number, y: number\n    ): this\n    {\n        const points = this._currentPoly.points;\n\n        // this needs to work on both canvas and GPU backends so might want to move this to the Graphics2D path..\n        buildArcToSvg(\n            points,\n            this._currentPoly.lastX,\n            this._currentPoly.lastY,\n            x,\n            y,\n            rx,\n            ry,\n            xAxisRotation,\n            largeArcFlag,\n            sweepFlag,\n        );\n\n        return this;\n    }\n\n    /**\n     * Adds a cubic Bezier curve to the path.\n     * It requires three points: the first two are control points and the third one is the end point.\n     * The starting point is the last point in the current path.\n     * @param cp1x - The x-coordinate of the first control point.\n     * @param cp1y - The y-coordinate of the first control point.\n     * @param cp2x - The x-coordinate of the second control point.\n     * @param cp2y - The y-coordinate of the second control point.\n     * @param x - The x-coordinate of the end point.\n     * @param y - The y-coordinate of the end point.\n     * @param smoothness - Optional parameter to adjust the smoothness of the curve.\n     * @returns The instance of the current object for chaining.\n     */\n    public bezierCurveTo(\n        cp1x: number, cp1y: number, cp2x: number, cp2y: number,\n        x: number, y: number,\n        smoothness?: number\n    ): this\n    {\n        this._ensurePoly();\n\n        const currentPoly = this._currentPoly;\n\n        // ensure distance from last point to first control point is not too small\n\n        // TODO - make this a plugin that people can override..\n        buildAdaptiveBezier(\n            this._currentPoly.points,\n            currentPoly.lastX, currentPoly.lastY,\n            cp1x, cp1y, cp2x, cp2y, x, y,\n            smoothness,\n        );\n\n        return this;\n    }\n\n    /**\n     * Adds a quadratic curve to the path. It requires two points: the control point and the end point.\n     * The starting point is the last point in the current path.\n     * @param cp1x - The x-coordinate of the control point.\n     * @param cp1y - The y-coordinate of the control point.\n     * @param x - The x-coordinate of the end point.\n     * @param y - The y-coordinate of the end point.\n     * @param smoothing - Optional parameter to adjust the smoothness of the curve.\n     * @returns The instance of the current object for chaining.\n     */\n    public quadraticCurveTo(cp1x: number, cp1y: number, x: number, y: number, smoothing?: number): this\n    {\n        this._ensurePoly();\n\n        const currentPoly = this._currentPoly;\n\n        // ensure distance from last point to first control point is not too small\n\n        // TODO - make this a plugin that people can override..\n        buildAdaptiveQuadratic(\n            this._currentPoly.points,\n            currentPoly.lastX, currentPoly.lastY,\n            cp1x, cp1y, x, y,\n            smoothing,\n        );\n\n        return this;\n    }\n\n    /**\n     * Closes the current path by drawing a straight line back to the start.\n     * If the shape is already closed or there are no points in the path, this method does nothing.\n     * @returns The instance of the current object for chaining.\n     */\n    public closePath(): this\n    {\n        this.endPoly(true);\n\n        return this;\n    }\n\n    /**\n     * Adds another path to the current path. This method allows for the combination of multiple paths into one.\n     * @param path - The `GraphicsPath` object representing the path to add.\n     * @param transform - An optional `Matrix` object to apply a transformation to the path before adding it.\n     * @returns The instance of the current object for chaining.\n     */\n    public addPath(path: GraphicsPath, transform?: Matrix): this\n    {\n        this.endPoly();\n\n        if (transform && !transform.isIdentity())\n        {\n            path = path.clone(true);\n            path.transform(transform);\n        }\n\n        for (let i = 0; i < path.instructions.length; i++)\n        {\n            const instruction = path.instructions[i];\n\n            // Sorry TS! this is the best we could do...\n            this[instruction.action](...(instruction.data as [never, never, never, never, never, never, never]));\n            // build out the path points\n        }\n\n        return this;\n    }\n\n    /**\n     * Finalizes the drawing of the current path. Optionally, it can close the path.\n     * @param closePath - A boolean indicating whether to close the path after finishing. False by default.\n     */\n    public finish(closePath = false)\n    {\n        this.endPoly(closePath);\n    }\n\n    /**\n     * Draws a rectangle shape. This method adds a new rectangle path to the current drawing.\n     * @param x - The x-coordinate of the top-left corner of the rectangle.\n     * @param y - The y-coordinate of the top-left corner of the rectangle.\n     * @param w - The width of the rectangle.\n     * @param h - The height of the rectangle.\n     * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.\n     * @returns The instance of the current object for chaining.\n     */\n    public rect(x: number, y: number, w: number, h: number, transform?: Matrix): this\n    {\n        this.drawShape(new Rectangle(x, y, w, h), transform);\n\n        return this;\n    }\n\n    /**\n     * Draws a circle shape. This method adds a new circle path to the current drawing.\n     * @param x - The x-coordinate of the center of the circle.\n     * @param y - The y-coordinate of the center of the circle.\n     * @param radius - The radius of the circle.\n     * @param transform - An optional `Matrix` object to apply a transformation to the circle.\n     * @returns The instance of the current object for chaining.\n     */\n    public circle(x: number, y: number, radius: number, transform?: Matrix): this\n    {\n        this.drawShape(new Circle(x, y, radius), transform);\n\n        return this;\n    }\n\n    /**\n     * Draws a polygon shape. This method allows for the creation of complex polygons by specifying a sequence of points.\n     * @param points - An array of numbers, or or an array of PointData objects eg [{x,y}, {x,y}, {x,y}]\n     * representing the x and y coordinates of the polygon's vertices, in sequence.\n     * @param close - A boolean indicating whether to close the polygon path. True by default.\n     * @param transform - An optional `Matrix` object to apply a transformation to the polygon.\n     * @returns The instance of the current object for chaining.\n     */\n    public poly(points: number[] | PointData[], close?: boolean, transform?: Matrix): this\n    {\n        const polygon = new Polygon(points);\n\n        polygon.closePath = close;\n\n        this.drawShape(polygon, transform);\n\n        return this;\n    }\n\n    /**\n     * Draws a regular polygon with a specified number of sides. All sides and angles are equal.\n     * @param x - The x-coordinate of the center of the polygon.\n     * @param y - The y-coordinate of the center of the polygon.\n     * @param radius - The radius of the circumscribed circle of the polygon.\n     * @param sides - The number of sides of the polygon. Must be 3 or more.\n     * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n     * @param transform - An optional `Matrix` object to apply a transformation to the polygon.\n     * @returns The instance of the current object for chaining.\n     */\n    public regularPoly(x: number, y: number, radius: number, sides: number, rotation = 0, transform?: Matrix): this\n    {\n        sides = Math.max(sides | 0, 3);\n        const startAngle = (-1 * Math.PI / 2) + rotation;\n        const delta = (Math.PI * 2) / sides;\n        const polygon = [];\n\n        for (let i = 0; i < sides; i++)\n        {\n            const angle = (i * delta) + startAngle;\n\n            polygon.push(\n                x + (radius * Math.cos(angle)),\n                y + (radius * Math.sin(angle))\n            );\n        }\n\n        this.poly(polygon, true, transform);\n\n        return this;\n    }\n\n    /**\n     * Draws a polygon with rounded corners.\n     * Similar to `regularPoly` but with the ability to round the corners of the polygon.\n     * @param x - The x-coordinate of the center of the polygon.\n     * @param y - The y-coordinate of the center of the polygon.\n     * @param radius - The radius of the circumscribed circle of the polygon.\n     * @param sides - The number of sides of the polygon. Must be 3 or more.\n     * @param corner - The radius of the rounding of the corners.\n     * @param rotation - The rotation angle of the polygon, in radians. Zero by default.\n     * @param smoothness - Optional parameter to adjust the smoothness of the rounding.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundPoly(\n        x: number, y: number,\n        radius: number,\n        sides: number, corner: number,\n        rotation = 0,\n        smoothness?: number,\n    ): this\n    {\n        sides = Math.max((sides | 0), 3);\n\n        if (corner <= 0)\n        {\n            return this.regularPoly(x, y, radius, sides, rotation);\n        }\n\n        const sideLength = (radius * Math.sin(Math.PI / sides)) - 0.001;\n\n        corner = Math.min(corner, sideLength);\n\n        const startAngle = (-1 * Math.PI / 2) + rotation;\n        const delta = (Math.PI * 2) / sides;\n        const internalAngle = ((sides - 2) * Math.PI) / sides / 2;\n\n        for (let i = 0; i < sides; i++)\n        {\n            const angle = (i * delta) + startAngle;\n            const x0 = x + (radius * Math.cos(angle));\n            const y0 = y + (radius * Math.sin(angle));\n            const a1 = angle + (Math.PI) + internalAngle;\n            const a2 = angle - (Math.PI) - internalAngle;\n            const x1 = x0 + (corner * Math.cos(a1));\n            const y1 = y0 + (corner * Math.sin(a1));\n            const x3 = x0 + (corner * Math.cos(a2));\n            const y3 = y0 + (corner * Math.sin(a2));\n\n            if (i === 0)\n            {\n                this.moveTo(x1, y1);\n            }\n            else\n            {\n                this.lineTo(x1, y1);\n            }\n            this.quadraticCurveTo(x0, y0, x3, y3, smoothness);\n        }\n\n        return this.closePath();\n    }\n\n    /**\n     * Draws a shape with rounded corners. This function supports custom radius for each corner of the shape.\n     * Optionally, corners can be rounded using a quadratic curve instead of an arc, providing a different aesthetic.\n     * @param points - An array of `RoundedPoint` representing the corners of the shape to draw.\n     * A minimum of 3 points is required.\n     * @param radius - The default radius for the corners.\n     * This radius is applied to all corners unless overridden in `points`.\n     * @param useQuadratic - If set to true, rounded corners are drawn using a quadraticCurve\n     *  method instead of an arc method. Defaults to false.\n     * @param smoothness - Specifies the smoothness of the curve when `useQuadratic` is true.\n     * Higher values make the curve smoother.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundShape(points: RoundedPoint[], radius: number, useQuadratic = false, smoothness?: number): this\n    {\n        if (points.length < 3)\n        {\n            return this;\n        }\n\n        if (useQuadratic)\n        {\n            roundedShapeQuadraticCurve(this, points, radius, smoothness);\n        }\n        else\n        {\n            roundedShapeArc(this, points, radius);\n        }\n\n        return this.closePath();\n    }\n\n    /**\n     * Draw Rectangle with fillet corners. This is much like rounded rectangle\n     * however it support negative numbers as well for the corner radius.\n     * @param x - Upper left corner of rect\n     * @param y - Upper right corner of rect\n     * @param width - Width of rect\n     * @param height - Height of rect\n     * @param fillet - accept negative or positive values\n     */\n    public filletRect(x: number, y: number, width: number, height: number, fillet: number): this\n    {\n        if (fillet === 0)\n        {\n            return this.rect(x, y, width, height);\n        }\n\n        const maxFillet = Math.min(width, height) / 2;\n        const inset = Math.min(maxFillet, Math.max(-maxFillet, fillet));\n        const right = x + width;\n        const bottom = y + height;\n        const dir = inset < 0 ? -inset : 0;\n        const size = Math.abs(inset);\n\n        return this\n            .moveTo(x, y + size)\n            .arcTo(x + dir, y + dir, x + size, y, size)\n            .lineTo(right - size, y)\n            .arcTo(right - dir, y + dir, right, y + size, size)\n            .lineTo(right, bottom - size)\n            .arcTo(right - dir, bottom - dir, x + width - size, bottom, size)\n            .lineTo(x + size, bottom)\n            .arcTo(x + dir, bottom - dir, x, bottom - size, size)\n            .closePath();\n    }\n\n    /**\n     * Draw Rectangle with chamfer corners. These are angled corners.\n     * @param x - Upper left corner of rect\n     * @param y - Upper right corner of rect\n     * @param width - Width of rect\n     * @param height - Height of rect\n     * @param chamfer - non-zero real number, size of corner cutout\n     * @param transform\n     */\n    public chamferRect(x: number, y: number, width: number, height: number, chamfer: number, transform?: Matrix): this\n    {\n        if (chamfer <= 0)\n        {\n            return this.rect(x, y, width, height);\n        }\n\n        const inset = Math.min(chamfer, Math.min(width, height) / 2);\n        const right = x + width;\n        const bottom = y + height;\n        const points = [\n            x + inset, y,\n            right - inset, y,\n            right, y + inset,\n            right, bottom - inset,\n            right - inset, bottom,\n            x + inset, bottom,\n            x, bottom - inset,\n            x, y + inset,\n        ];\n\n        // Remove overlapping points\n        for (let i = points.length - 1; i >= 2; i -= 2)\n        {\n            if (points[i] === points[i - 2] && points[i - 1] === points[i - 3])\n            {\n                points.splice(i - 1, 2);\n            }\n        }\n\n        return this.poly(points, true, transform);\n    }\n\n    /**\n     * Draws an ellipse at the specified location and with the given x and y radii.\n     * An optional transformation can be applied, allowing for rotation, scaling, and translation.\n     * @param x - The x-coordinate of the center of the ellipse.\n     * @param y - The y-coordinate of the center of the ellipse.\n     * @param radiusX - The horizontal radius of the ellipse.\n     * @param radiusY - The vertical radius of the ellipse.\n     * @param transform - An optional `Matrix` object to apply a transformation to the ellipse. This can include rotations.\n     * @returns The instance of the current object for chaining.\n     */\n    public ellipse(x: number, y: number, radiusX: number, radiusY: number, transform?: Matrix): this\n    {\n        // TODO apply rotation to transform...\n\n        this.drawShape(new Ellipse(x, y, radiusX, radiusY), transform);\n\n        return this;\n    }\n\n    /**\n     * Draws a rectangle with rounded corners.\n     * The corner radius can be specified to determine how rounded the corners should be.\n     * An optional transformation can be applied, which allows for rotation, scaling, and translation of the rectangle.\n     * @param x - The x-coordinate of the top-left corner of the rectangle.\n     * @param y - The y-coordinate of the top-left corner of the rectangle.\n     * @param w - The width of the rectangle.\n     * @param h - The height of the rectangle.\n     * @param radius - The radius of the rectangle's corners. If not specified, corners will be sharp.\n     * @param transform - An optional `Matrix` object to apply a transformation to the rectangle.\n     * @returns The instance of the current object for chaining.\n     */\n    public roundRect(x: number, y: number, w: number, h: number, radius?: number, transform?: Matrix): this\n    {\n        this.drawShape(new RoundedRectangle(x, y, w, h, radius), transform);\n\n        return this;\n    }\n\n    /**\n     * Draws a given shape on the canvas.\n     * This is a generic method that can draw any type of shape specified by the `ShapePrimitive` parameter.\n     * An optional transformation matrix can be applied to the shape, allowing for complex transformations.\n     * @param shape - The shape to draw, defined as a `ShapePrimitive` object.\n     * @param matrix - An optional `Matrix` for transforming the shape. This can include rotations,\n     * scaling, and translations.\n     * @returns The instance of the current object for chaining.\n     */\n    public drawShape(shape: ShapePrimitive, matrix?: Matrix): this\n    {\n        this.endPoly();\n\n        this.shapePrimitives.push({ shape, transform: matrix });\n\n        return this;\n    }\n\n    /**\n     * Starts a new polygon path from the specified starting point.\n     * This method initializes a new polygon or ends the current one if it exists.\n     * @param x - The x-coordinate of the starting point of the new polygon.\n     * @param y - The y-coordinate of the starting point of the new polygon.\n     * @returns The instance of the current object for chaining.\n     */\n    public startPoly(x: number, y: number): this\n    {\n        let currentPoly = this._currentPoly;\n\n        if (currentPoly)\n        {\n            this.endPoly();\n        }\n\n        currentPoly = new Polygon();\n\n        currentPoly.points.push(x, y);\n\n        this._currentPoly = currentPoly;\n\n        return this;\n    }\n\n    /**\n     * Ends the current polygon path. If `closePath` is set to true,\n     * the path is closed by connecting the last point to the first one.\n     * This method finalizes the current polygon and prepares it for drawing or adding to the shape primitives.\n     * @param closePath - A boolean indicating whether to close the polygon by connecting the last point\n     *  back to the starting point. False by default.\n     * @returns The instance of the current object for chaining.\n     */\n    public endPoly(closePath = false): this\n    {\n        const shape = this._currentPoly;\n\n        if (shape && shape.points.length > 2)\n        {\n            shape.closePath = closePath;\n\n            this.shapePrimitives.push({ shape });\n        }\n\n        this._currentPoly = null;\n\n        return this;\n    }\n\n    private _ensurePoly(start = true): void\n    {\n        if (this._currentPoly) return;\n\n        this._currentPoly = new Polygon();\n\n        if (start)\n        {\n            // get last points..\n            const lastShape = this.shapePrimitives[this.shapePrimitives.length - 1];\n\n            if (lastShape)\n            {\n                // i KNOW its a rect..\n                let lx = lastShape.shape.x;\n                let ly = lastShape.shape.y;\n\n                if (!lastShape.transform.isIdentity())\n                {\n                    const t = lastShape.transform;\n\n                    const tempX = lx;\n\n                    lx = (t.a * lx) + (t.c * ly) + t.tx;\n                    ly = (t.b * tempX) + (t.d * ly) + t.ty;\n                }\n\n                this._currentPoly.points.push(lx, ly);\n            }\n            else\n            {\n                this._currentPoly.points.push(0, 0);\n            }\n        }\n    }\n\n    /** Builds the path. */\n    public buildPath()\n    {\n        const path = this._graphicsPath2D;\n\n        this.shapePrimitives.length = 0;\n        this._currentPoly = null;\n\n        for (let i = 0; i < path.instructions.length; i++)\n        {\n            const instruction = path.instructions[i];\n\n            // Sorry TS! this is the best we could do...\n            this[instruction.action](...(instruction.data as [never, never, never, never, never, never, never]));\n        }\n\n        this.finish();\n    }\n\n    /** Gets the bounds of the path. */\n    get bounds(): Bounds\n    {\n        const bounds = this._bounds;\n\n        bounds.clear();\n\n        const shapePrimitives = this.shapePrimitives;\n\n        for (let i = 0; i < shapePrimitives.length; i++)\n        {\n            const shapePrimitive = shapePrimitives[i];\n\n            const boundsRect = shapePrimitive.shape.getBounds(tempRectangle);\n\n            if (shapePrimitive.transform)\n            {\n                bounds.addRect(boundsRect, shapePrimitive.transform);\n            }\n            else\n            {\n                bounds.addRect(boundsRect);\n            }\n        }\n\n        return bounds;\n    }\n}\n"],"names":[],"mappings":"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"}