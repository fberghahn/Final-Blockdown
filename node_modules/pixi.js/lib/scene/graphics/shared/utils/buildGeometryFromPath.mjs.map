{"version":3,"file":"buildGeometryFromPath.mjs","sources":["../../../../../src/scene/graphics/shared/utils/buildGeometryFromPath.ts"],"sourcesContent":["import { buildSimpleUvs, buildUvs } from '../../../../rendering/renderers/shared/geometry/utils/buildUvs';\nimport { transformVertices } from '../../../../rendering/renderers/shared/geometry/utils/transformVertices';\nimport { MeshGeometry } from '../../../mesh/shared/MeshGeometry';\nimport { buildCircle } from '../buildCommands/buildCircle';\nimport { buildPolygon } from '../buildCommands/buildPolygon';\nimport { buildRectangle } from '../buildCommands/buildRectangle';\nimport { buildTriangle } from '../buildCommands/buildTriangle';\nimport { GraphicsPath } from '../path/GraphicsPath';\n\nimport type { Matrix } from '../../../../maths/matrix/Matrix';\nimport type { ShapeBuildCommand } from '../buildCommands/ShapeBuildCommand';\n\nconst buildMap: Record<string, ShapeBuildCommand> = {\n    rectangle: buildRectangle,\n    polygon: buildPolygon,\n    triangle: buildTriangle,\n    circle: buildCircle,\n    ellipse: buildCircle,\n    roundedRectangle: buildCircle,\n};\n\nexport interface GeometryPathOptions\n{\n    /** the path to build the geometry from */\n    path: GraphicsPath\n    /** a `Matrix` that can be used to modify the the texture UVs of the the path being built */\n    textureMatrix?: Matrix\n    /** an optional `MeshGeometry` to write too instead of creating a new one*/\n    out?: MeshGeometry\n}\n\n/**\n * When building a mesh, it helps to leverage the simple API we have in `GraphicsPath` as it can often be easier to\n * to define the geometry in a more human readable way. This function takes a `GraphicsPath` and returns a `MeshGeometry`.\n * @example\n * ```ts\n *\n * const path = new GraphicsPath()\n *    .drawRect(0, 0, 100, 100)\n *\n * const geometry:MeshGeometry = buildGeometryFromPath(path);\n *\n * const mesh = new Mesh({geometry});\n *\n * ```\n * You can also pass in a Matrix to transform the uvs as by defualt you may want to control how they are set up.\n * @param options - either a `GraphicsPath` or `GeometryPathOptions`\n * @returns a new `MeshGeometry` instance build from the path\n */\nexport function buildGeometryFromPath(options: GraphicsPath | GeometryPathOptions): MeshGeometry\n{\n    if (options instanceof GraphicsPath)\n    {\n        options = {\n            path: options,\n            textureMatrix: null,\n            out: null,\n        };\n    }\n\n    const vertices: number[] = [];\n    const uvs: number[] = [];\n    const indices: number[] = [];\n\n    // build path collection of polygons and shapes points..\n    const shapePath = options.path.shapePath;\n    const textureMatrix = options.textureMatrix;\n\n    shapePath.shapePrimitives.forEach(({ shape, transform: matrix }) =>\n    {\n        const indexOffset = indices.length;\n        const vertOffset = vertices.length / 2;\n\n        const points: number[] = [];\n\n        const build = buildMap[shape.type];\n\n        build.build(shape, points);\n\n        if (matrix)\n        {\n            transformVertices(points, matrix);\n        }\n\n        build.triangulate(points, vertices, 2, vertOffset, indices, indexOffset);\n\n        const uvsOffset = uvs.length / 2;\n\n        if (textureMatrix)\n        {\n            // todo can prolly do this before calculating uvs..\n            if (matrix)\n            {\n                textureMatrix.append(matrix.clone().invert());\n            }\n\n            buildUvs(vertices, 2, vertOffset, uvs, uvsOffset, 2, (vertices.length / 2) - vertOffset, textureMatrix);\n        }\n        else\n        {\n            buildSimpleUvs(uvs, uvsOffset, 2, (vertices.length / 2) - vertOffset);\n        }\n    });\n\n    const out = options.out;\n\n    if (out)\n    {\n        out.positions = new Float32Array(vertices);\n        out.uvs = new Float32Array(uvs);\n        out.indices = new Uint32Array(indices);\n\n        return out;\n    }\n\n    const geometry = new MeshGeometry({\n        positions: new Float32Array(vertices),\n        uvs: new Float32Array(uvs),\n        indices: new Uint32Array(indices),\n    });\n\n    return geometry;\n}\n"],"names":[],"mappings":"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"}