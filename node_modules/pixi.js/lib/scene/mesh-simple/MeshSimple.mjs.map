{"version":3,"file":"MeshSimple.mjs","sources":["../../../src/scene/mesh-simple/MeshSimple.ts"],"sourcesContent":["import { definedProps } from '../container/utils/definedProps';\nimport { Mesh } from '../mesh/shared/Mesh';\nimport { MeshGeometry } from '../mesh/shared/MeshGeometry';\n\nimport type { TypedArray } from '../../rendering/renderers/shared/buffer/Buffer';\nimport type { Topology } from '../../rendering/renderers/shared/geometry/const';\nimport type { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport type { MeshOptions } from '../mesh/shared/Mesh';\n\n/**\n * Options for the simple mesh.\n * @memberof scene\n */\nexport interface SimpleMeshOptions extends Omit<MeshOptions, 'geometry'>\n{\n    /** The texture to use */\n    texture: Texture,\n    /** if you want to specify the vertices */\n    vertices?: Float32Array,\n    /** if you want to specify the uvs */\n    uvs?: Float32Array,\n    /** if you want to specify the indices */\n    indices?: Uint32Array,\n    /** the topology, can be any of the Topology values */\n    topology?: Topology\n}\n\n/**\n * The Simple Mesh class mimics Mesh in PixiJS, providing easy-to-use constructor arguments.\n * For more robust customization, use {@link scene.Mesh}.\n * @memberof scene\n */\nexport class MeshSimple extends Mesh\n{\n    /** Upload vertices buffer each frame. */\n    public autoUpdate: boolean;\n\n    /**\n     * @param options - Options to be used for construction\n     */\n    constructor(options: SimpleMeshOptions)\n    {\n        const { texture, vertices, uvs, indices, topology, ...rest } = options;\n        const geometry = new MeshGeometry(definedProps({\n            positions: vertices,\n            uvs,\n            indices,\n            topology\n        }));\n\n        // geometry.getBuffer('aPosition').static = false;\n\n        super(definedProps({\n            ...rest,\n            texture,\n            geometry,\n        }));\n\n        this.autoUpdate = true;\n        this.onRender = this._render;\n    }\n\n    /**\n     * Collection of vertices data.\n     * @type {Float32Array}\n     */\n    get vertices(): TypedArray\n    {\n        return this.geometry.getBuffer('aPosition').data;\n    }\n    set vertices(value: TypedArray)\n    {\n        this.geometry.getBuffer('aPosition').data = value;\n    }\n\n    private _render(): void\n    {\n        if (this.autoUpdate)\n        {\n            this.geometry.getBuffer('aPosition').update();\n        }\n    }\n}\n"],"names":[],"mappings":";;;;;AAgCO,MAAM,mBAAmB,IAChC,CAAA;AAAA;AAAA;AAAA;AAAA,EAOI,YAAY,OACZ,EAAA;AACI,IAAM,MAAA,EAAE,SAAS,QAAU,EAAA,GAAA,EAAK,SAAS,QAAU,EAAA,GAAG,MAAS,GAAA,OAAA,CAAA;AAC/D,IAAM,MAAA,QAAA,GAAW,IAAI,YAAA,CAAa,YAAa,CAAA;AAAA,MAC3C,SAAW,EAAA,QAAA;AAAA,MACX,GAAA;AAAA,MACA,OAAA;AAAA,MACA,QAAA;AAAA,KACH,CAAC,CAAA,CAAA;AAIF,IAAA,KAAA,CAAM,YAAa,CAAA;AAAA,MACf,GAAG,IAAA;AAAA,MACH,OAAA;AAAA,MACA,QAAA;AAAA,KACH,CAAC,CAAA,CAAA;AAEF,IAAA,IAAA,CAAK,UAAa,GAAA,IAAA,CAAA;AAClB,IAAA,IAAA,CAAK,WAAW,IAAK,CAAA,OAAA,CAAA;AAAA,GACzB;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,IAAI,QACJ,GAAA;AACI,IAAA,OAAO,IAAK,CAAA,QAAA,CAAS,SAAU,CAAA,WAAW,CAAE,CAAA,IAAA,CAAA;AAAA,GAChD;AAAA,EACA,IAAI,SAAS,KACb,EAAA;AACI,IAAA,IAAA,CAAK,QAAS,CAAA,SAAA,CAAU,WAAW,CAAA,CAAE,IAAO,GAAA,KAAA,CAAA;AAAA,GAChD;AAAA,EAEQ,OACR,GAAA;AACI,IAAA,IAAI,KAAK,UACT,EAAA;AACI,MAAA,IAAA,CAAK,QAAS,CAAA,SAAA,CAAU,WAAW,CAAA,CAAE,MAAO,EAAA,CAAA;AAAA,KAChD;AAAA,GACJ;AACJ;;;;"}