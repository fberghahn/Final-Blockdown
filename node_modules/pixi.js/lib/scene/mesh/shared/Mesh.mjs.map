{"version":3,"file":"Mesh.mjs","sources":["../../../../src/scene/mesh/shared/Mesh.ts"],"sourcesContent":["import { Polygon } from '../../../maths/shapes/Polygon';\nimport { Geometry } from '../../../rendering/renderers/shared/geometry/Geometry';\nimport { State } from '../../../rendering/renderers/shared/state/State';\nimport { Texture } from '../../../rendering/renderers/shared/texture/Texture';\nimport { deprecation, v8_0_0 } from '../../../utils/logging/deprecation';\nimport { Container } from '../../container/Container';\nimport { MeshGeometry } from './MeshGeometry';\n\nimport type { PointData } from '../../../maths/point/PointData';\nimport type { Topology } from '../../../rendering/renderers/shared/geometry/const';\nimport type { Instruction } from '../../../rendering/renderers/shared/instructions/Instruction';\nimport type { Shader } from '../../../rendering/renderers/shared/shader/Shader';\nimport type { View } from '../../../rendering/renderers/shared/view/View';\nimport type { Bounds } from '../../container/bounds/Bounds';\nimport type { ContainerOptions } from '../../container/Container';\nimport type { DestroyOptions } from '../../container/destroyTypes';\n\nconst tempPolygon = new Polygon();\n\nexport interface TextureShader extends Shader\n{\n    texture: Texture;\n}\n\n/**\n * Constructor options used for `Mesh` instances. Extends {@link scene.MeshViewOptions}\n * ```js\n * const mesh = new Mesh({\n *    texture: Texture.from('assets/image.png'),\n *    geometry: new PlaneGeometry(),\n *    shader: Shader.from(VERTEX, FRAGMENT),\n * });\n * ```\n * @see {@link scene.Mesh}\n * @see {@link scene.MeshViewOptions}\n * @memberof scene\n */\n\n/**\n * @memberof scene\n */\nexport interface MeshOptions<\n    GEOMETRY extends Geometry = MeshGeometry,\n    SHADER extends Shader = TextureShader\n> extends ContainerOptions\n{\n    /**\n     * Includes vertex positions, face indices, colors, UVs, and\n     * custom attributes within buffers, reducing the cost of passing all\n     * this data to the GPU. Can be shared between multiple Mesh objects.\n     */\n    geometry: GEOMETRY;\n    /**\n     * Represents the vertex and fragment shaders that processes the geometry and runs on the GPU.\n     * Can be shared between multiple Mesh objects.\n     */\n    shader?: SHADER;\n    /** The state of WebGL required to render the mesh. */\n    state?: State;\n    /** The texture that the Mesh uses. Null for non-MeshMaterial shaders */\n    texture?: Texture;\n    /** Whether or not to round the x/y position. */\n    roundPixels?: boolean;\n}\n/**\n * Base mesh class.\n *\n * This class empowers you to have maximum flexibility to render any kind of WebGL/WebGPU visuals you can think of.\n * This class assumes a certain level of WebGL/WebGPU knowledge.\n * If you know a bit this should abstract enough away to make your life easier!\n *\n * Pretty much ALL WebGL/WebGPU can be broken down into the following:\n * - Geometry - The structure and data for the mesh. This can include anything from positions, uvs, normals, colors etc..\n * - Shader - This is the shader that PixiJS will render the geometry with (attributes in the shader must match the geometry)\n * - State - This is the state of WebGL required to render the mesh.\n *\n * Through a combination of the above elements you can render anything you want, 2D or 3D!\n * @memberof scene\n */\nexport class Mesh<\n    GEOMETRY extends Geometry = MeshGeometry,\n    SHADER extends Shader = TextureShader\n> extends Container implements View, Instruction\n{\n    public readonly renderPipeId = 'mesh';\n    public readonly canBundle = true;\n    public state: State;\n\n    /** @ignore */\n    public _texture: Texture;\n    /** @ignore */\n    public _geometry: GEOMETRY;\n    /** @ignore */\n    public _shader?: SHADER;\n\n    public _roundPixels: 0 | 1 = 0;\n\n    /**\n     * @param {scene.MeshOptions} options - options for the mesh instance\n     */\n    constructor(options: MeshOptions<GEOMETRY, SHADER>);\n    /** @deprecated since 8.0.0 */\n    constructor(geometry: GEOMETRY, shader: SHADER, state?: State, drawMode?: Topology);\n    constructor(...args: [MeshOptions<GEOMETRY, SHADER>] | [GEOMETRY, SHADER, State?, Topology?])\n    {\n        let options = args[0];\n\n        if (options instanceof Geometry)\n        {\n            // #if _DEBUG\n            deprecation(v8_0_0, 'Mesh: use new Mesh({ geometry, shader }) instead');\n            // #endif\n\n            options = {\n                geometry: options,\n                shader: args[1],\n            } as MeshOptions<GEOMETRY, SHADER>;\n\n            if (args[3])\n            {\n                // #if _DEBUG\n                deprecation(v8_0_0, 'Mesh: drawMode argument has been removed, use geometry.topology instead');\n                // #endif\n\n                options.geometry.topology = args[3];\n            }\n        }\n\n        const { geometry, shader, texture, roundPixels, state, ...rest } = options;\n\n        super({\n            label: 'Mesh',\n            ...rest\n        });\n\n        this.allowChildren = false;\n\n        this.shader = shader;\n        this.texture = texture ?? (shader as unknown as TextureShader)?.texture ?? Texture.WHITE;\n        this.state = state ?? State.for2d();\n\n        this._geometry = geometry;\n        this._geometry.on('update', this.onViewUpdate, this);\n\n        this.roundPixels = roundPixels ?? false;\n    }\n\n    /**\n     *  Whether or not to round the x/y position of the mesh.\n     * @type {boolean}\n     */\n    get roundPixels()\n    {\n        return !!this._roundPixels;\n    }\n\n    set roundPixels(value: boolean)\n    {\n        this._roundPixels = value ? 1 : 0;\n    }\n\n    /** Alias for {@link scene.Mesh#shader}. */\n    get material()\n    {\n        // #if _DEBUG\n        deprecation(v8_0_0, 'mesh.material property has been removed, use mesh.shader instead');\n        // #endif\n\n        return this._shader;\n    }\n\n    /**\n     * Represents the vertex and fragment shaders that processes the geometry and runs on the GPU.\n     * Can be shared between multiple Mesh objects.\n     */\n    set shader(value: SHADER)\n    {\n        if (this._shader === value) return;\n\n        this._shader = value;\n        this.onViewUpdate();\n    }\n\n    get shader()\n    {\n        return this._shader;\n    }\n\n    /**\n     * Includes vertex positions, face indices, colors, UVs, and\n     * custom attributes within buffers, reducing the cost of passing all\n     * this data to the GPU. Can be shared between multiple Mesh objects.\n     */\n    set geometry(value: GEOMETRY)\n    {\n        if (this._geometry === value) return;\n\n        this._geometry?.off('update', this.onViewUpdate, this);\n        value.on('update', this.onViewUpdate, this);\n\n        this._geometry = value;\n        this.onViewUpdate();\n    }\n\n    get geometry()\n    {\n        return this._geometry;\n    }\n\n    /** The texture that the Mesh uses. Null for non-MeshMaterial shaders */\n    set texture(value: Texture)\n    {\n        if (this._texture === value) return;\n\n        if (this.shader)\n        {\n            (this.shader as unknown as TextureShader).texture = value;\n        }\n\n        this._texture = value;\n        this.onViewUpdate();\n    }\n\n    get texture()\n    {\n        return this._texture;\n    }\n\n    get batched()\n    {\n        if (this._shader) return false;\n\n        if (this._geometry instanceof MeshGeometry)\n        {\n            if (this._geometry.batchMode === 'auto')\n            {\n                return this._geometry.positions.length / 2 <= 100;\n            }\n\n            return this._geometry.batchMode === 'batch';\n        }\n\n        return false;\n    }\n\n    /**\n     * The local bounds of the mesh.\n     * @type {rendering.Bounds}\n     */\n    get bounds()\n    {\n        return this._geometry.bounds;\n    }\n\n    /**\n     * Adds the bounds of this object to the bounds object.\n     * @param bounds - The output bounds object.\n     */\n    public addBounds(bounds: Bounds)\n    {\n        bounds.addBounds(this.geometry.bounds);\n    }\n\n    /**\n     * Checks if the object contains the given point.\n     * @param point - The point to check\n     */\n    public containsPoint(point: PointData)\n    {\n        const { x, y } = point;\n\n        if (!this.bounds.containsPoint(x, y)) return false;\n\n        const vertices = this.geometry.getBuffer('aPosition').data;\n\n        const points = tempPolygon.points;\n        const indices = this.geometry.getIndex().data;\n        const len = indices.length;\n        const step = this.geometry.topology === 'triangle-strip' ? 3 : 1;\n\n        for (let i = 0; i + 2 < len; i += step)\n        {\n            const ind0 = indices[i] * 2;\n            const ind1 = indices[i + 1] * 2;\n            const ind2 = indices[i + 2] * 2;\n\n            points[0] = vertices[ind0];\n            points[1] = vertices[ind0 + 1];\n            points[2] = vertices[ind1];\n            points[3] = vertices[ind1 + 1];\n            points[4] = vertices[ind2];\n            points[5] = vertices[ind2 + 1];\n\n            if (tempPolygon.contains(x, y))\n            {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /** @ignore */\n    public onViewUpdate()\n    {\n        // increment from the 12th bit!\n        this._didChangeId += 1 << 12;\n\n        if (this.didViewUpdate) return;\n        this.didViewUpdate = true;\n\n        if (this.renderGroup)\n        {\n            this.renderGroup.onChildViewUpdate(this);\n        }\n    }\n\n    /**\n     * Destroys this sprite renderable and optionally its texture.\n     * @param options - Options parameter. A boolean will act as if all options\n     *  have been set to that value\n     * @param {boolean} [options.texture=false] - Should it destroy the current texture of the renderable as well\n     * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the renderable as well\n     */\n    public destroy(options?: DestroyOptions): void\n    {\n        super.destroy(options);\n\n        const destroyTexture = typeof options === 'boolean' ? options : options?.texture;\n\n        if (destroyTexture)\n        {\n            const destroyTextureSource = typeof options === 'boolean' ? options : options?.textureSource;\n\n            this._texture.destroy(destroyTextureSource);\n        }\n\n        this._geometry?.off('update', this.onViewUpdate, this);\n\n        this._texture = null;\n        this._geometry = null;\n        this._shader = null;\n    }\n}\n"],"names":[],"mappings":"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"}