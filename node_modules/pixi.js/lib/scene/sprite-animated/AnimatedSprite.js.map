{"version":3,"file":"AnimatedSprite.js","sources":["../../../src/scene/sprite-animated/AnimatedSprite.ts"],"sourcesContent":["import { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport { UPDATE_PRIORITY } from '../../ticker/const';\nimport { Ticker } from '../../ticker/Ticker';\nimport { Sprite } from '../sprite/Sprite';\n\n/**\n * An AnimatedSprite is a simple way to display an animation depicted by a list of textures.\n *\n * ```js\n * import { AnimatedSprite, Texture } from 'pixi.js';\n *\n * const alienImages = [\n *     'image_sequence_01.png',\n *     'image_sequence_02.png',\n *     'image_sequence_03.png',\n *     'image_sequence_04.png',\n * ];\n * const textureArray = [];\n *\n * for (let i = 0; i < 4; i++)\n * {\n *     const texture = Texture.from(alienImages[i]);\n *     textureArray.push(texture);\n * }\n *\n * const animatedSprite = new AnimatedSprite(textureArray);\n * ```\n *\n * The more efficient and simpler way to create an animated sprite is using a {@link Spritesheet}\n * containing the animation definitions:\n * @example\n * import { AnimatedSprite, Assets } from 'pixi.js';\n *\n * const sheet = await Assets.load('assets/spritesheet.json');\n * animatedSprite = new AnimatedSprite(sheet.animations['image_sequence']);\n * @memberof scene\n */\nexport class AnimatedSprite extends Sprite\n{\n    /**\n     * The speed that the AnimatedSprite will play at. Higher is faster, lower is slower.\n     * @default 1\n     */\n    public animationSpeed: number;\n\n    /**\n     * Whether or not the animate sprite repeats after playing.\n     * @default true\n     */\n    public loop: boolean;\n\n    /**\n     * Update anchor to [Texture's defaultAnchor]{@link Texture#defaultAnchor} when frame changes.\n     *\n     * Useful with [sprite sheet animations]{@link Spritesheet#animations} created with tools.\n     * Changing anchor for each frame allows to pin sprite origin to certain moving feature\n     * of the frame (e.g. left foot).\n     *\n     * Note: Enabling this will override any previously set `anchor` on each frame change.\n     * @default false\n     */\n    public updateAnchor: boolean;\n\n    /**\n     * User-assigned function to call when an AnimatedSprite finishes playing.\n     * @example\n     * animation.onComplete = () => {\n     *     // Finished!\n     * };\n     */\n    public onComplete?: () => void;\n\n    /**\n     * User-assigned function to call when an AnimatedSprite changes which texture is being rendered.\n     * @example\n     * animation.onFrameChange = () => {\n     *     // Updated!\n     * };\n     */\n    public onFrameChange?: (currentFrame: number) => void;\n\n    /**\n     * User-assigned function to call when `loop` is true, and an AnimatedSprite is played and\n     * loops around to start again.\n     * @example\n     * animation.onLoop = () => {\n     *     // Looped!\n     * };\n     */\n    public onLoop?: () => void;\n\n    private _playing: boolean;\n    private _textures: Texture[];\n    private _durations: number[];\n\n    /**\n     * `true` uses Ticker.shared to auto update animation time.\n     * @default true\n     */\n    private _autoUpdate: boolean;\n\n    /**\n     * `true` if the instance is currently connected to Ticker.shared to auto update animation time.\n     * @default false\n     */\n    private _isConnectedToTicker: boolean;\n\n    /** Elapsed time since animation has been started, used internally to display current texture. */\n    private _currentTime: number;\n\n    /** The texture index that was displayed last time. */\n    private _previousFrame: number;\n\n    /**\n     * @param textures - An array of {@link Texture} or frame\n     *  objects that make up the animation.\n     * @param {boolean} [autoUpdate=true] - Whether to use Ticker.shared to auto update animation time.\n     */\n    constructor(textures: Texture[] | FrameObject[], autoUpdate = true)\n    {\n        super(textures[0] instanceof Texture ? textures[0] : textures[0].texture);\n\n        this._textures = null;\n        this._durations = null;\n        this._autoUpdate = autoUpdate;\n        this._isConnectedToTicker = false;\n\n        this.animationSpeed = 1;\n        this.loop = true;\n        this.updateAnchor = false;\n        this.onComplete = null;\n        this.onFrameChange = null;\n        this.onLoop = null;\n\n        this._currentTime = 0;\n\n        this._playing = false;\n        this._previousFrame = null;\n\n        this.textures = textures;\n    }\n\n    /** Stops the AnimatedSprite. */\n    public stop(): void\n    {\n        if (!this._playing)\n        {\n            return;\n        }\n\n        this._playing = false;\n        if (this._autoUpdate && this._isConnectedToTicker)\n        {\n            Ticker.shared.remove(this.update, this);\n            this._isConnectedToTicker = false;\n        }\n    }\n\n    /** Plays the AnimatedSprite. */\n    public play(): void\n    {\n        if (this._playing)\n        {\n            return;\n        }\n\n        this._playing = true;\n        if (this._autoUpdate && !this._isConnectedToTicker)\n        {\n            Ticker.shared.add(this.update, this, UPDATE_PRIORITY.HIGH);\n            this._isConnectedToTicker = true;\n        }\n    }\n\n    /**\n     * Stops the AnimatedSprite and goes to a specific frame.\n     * @param frameNumber - Frame index to stop at.\n     */\n    public gotoAndStop(frameNumber: number): void\n    {\n        this.stop();\n        this.currentFrame = frameNumber;\n    }\n\n    /**\n     * Goes to a specific frame and begins playing the AnimatedSprite.\n     * @param frameNumber - Frame index to start at.\n     */\n    public gotoAndPlay(frameNumber: number): void\n    {\n        this.currentFrame = frameNumber;\n        this.play();\n    }\n\n    /**\n     * Updates the object transform for rendering.\n     * @param ticker - the ticker to use to update the object.\n     */\n    public update(ticker: Ticker): void\n    {\n        // If the animation isn't playing, no update is needed.\n        if (!this._playing)\n        {\n            return;\n        }\n\n        // Calculate elapsed time based on ticker's deltaTime and animation speed.\n        const deltaTime = ticker.deltaTime;\n        const elapsed = this.animationSpeed * deltaTime;\n        const previousFrame = this.currentFrame;\n\n        // If there are specific durations set for each frame:\n        if (this._durations !== null)\n        {\n            // Calculate the lag for the current frame based on the current time.\n            let lag = this._currentTime % 1 * this._durations[this.currentFrame];\n\n            // Adjust the lag based on elapsed time.\n            lag += elapsed / 60 * 1000;\n\n            // If the lag is negative, adjust the current time and the lag.\n            while (lag < 0)\n            {\n                this._currentTime--;\n                lag += this._durations[this.currentFrame];\n            }\n\n            const sign = Math.sign(this.animationSpeed * deltaTime);\n\n            // Floor the current time to get a whole number frame.\n            this._currentTime = Math.floor(this._currentTime);\n\n            // Adjust the current time and the lag until the lag is less than the current frame's duration.\n            while (lag >= this._durations[this.currentFrame])\n            {\n                lag -= this._durations[this.currentFrame] * sign;\n                this._currentTime += sign;\n            }\n\n            // Adjust the current time based on the lag and current frame's duration.\n            this._currentTime += lag / this._durations[this.currentFrame];\n        }\n        else\n        {\n            // If no specific durations set, simply adjust the current time by elapsed time.\n            this._currentTime += elapsed;\n        }\n\n        // Handle scenarios when animation reaches the start or the end.\n        if (this._currentTime < 0 && !this.loop)\n        {\n            // If the animation shouldn't loop and it reaches the start, go to the first frame.\n            this.gotoAndStop(0);\n\n            // If there's an onComplete callback, call it.\n            if (this.onComplete)\n            {\n                this.onComplete();\n            }\n        }\n        else if (this._currentTime >= this._textures.length && !this.loop)\n        {\n            // If the animation shouldn't loop and it reaches the end, go to the last frame.\n            this.gotoAndStop(this._textures.length - 1);\n\n            // If there's an onComplete callback, call it.\n            if (this.onComplete)\n            {\n                this.onComplete();\n            }\n        }\n        else if (previousFrame !== this.currentFrame)\n        {\n            // If the current frame is different from the last update, handle loop scenarios.\n            if (this.loop && this.onLoop)\n            {\n                if ((this.animationSpeed > 0 && this.currentFrame < previousFrame)\n                    || (this.animationSpeed < 0 && this.currentFrame > previousFrame))\n                {\n                    // If the animation loops, and there's an onLoop callback, call it.\n                    this.onLoop();\n                }\n            }\n\n            // Update the texture for the current frame.\n            this._updateTexture();\n        }\n    }\n\n    /** Updates the displayed texture to match the current frame index. */\n    private _updateTexture(): void\n    {\n        const currentFrame = this.currentFrame;\n\n        if (this._previousFrame === currentFrame)\n        {\n            return;\n        }\n\n        this._previousFrame = currentFrame;\n\n        this.texture = this._textures[currentFrame];\n\n        if (this.updateAnchor)\n        {\n            this.anchor.copyFrom(this.texture.defaultAnchor);\n        }\n\n        if (this.onFrameChange)\n        {\n            this.onFrameChange(this.currentFrame);\n        }\n    }\n\n    /** Stops the AnimatedSprite and destroys it. */\n    public destroy(): void\n    {\n        this.stop();\n        super.destroy();\n\n        this.onComplete = null;\n        this.onFrameChange = null;\n        this.onLoop = null;\n    }\n\n    /**\n     * A short hand way of creating an AnimatedSprite from an array of frame ids.\n     * @param frames - The array of frames ids the AnimatedSprite will use as its texture frames.\n     * @returns - The new animated sprite with the specified frames.\n     */\n    public static fromFrames(frames: string[]): AnimatedSprite\n    {\n        const textures = [];\n\n        for (let i = 0; i < frames.length; ++i)\n        {\n            textures.push(Texture.from(frames[i]));\n        }\n\n        return new AnimatedSprite(textures);\n    }\n\n    /**\n     * A short hand way of creating an AnimatedSprite from an array of image ids.\n     * @param images - The array of image urls the AnimatedSprite will use as its texture frames.\n     * @returns The new animate sprite with the specified images as frames.\n     */\n    public static fromImages(images: string[]): AnimatedSprite\n    {\n        const textures = [];\n\n        for (let i = 0; i < images.length; ++i)\n        {\n            textures.push(Texture.from(images[i]));\n        }\n\n        return new AnimatedSprite(textures);\n    }\n\n    /**\n     * The total number of frames in the AnimatedSprite. This is the same as number of textures\n     * assigned to the AnimatedSprite.\n     * @readonly\n     * @default 0\n     */\n    get totalFrames(): number\n    {\n        return this._textures.length;\n    }\n\n    /** The array of textures used for this AnimatedSprite. */\n    get textures(): Texture[] | FrameObject[]\n    {\n        return this._textures;\n    }\n\n    set textures(value: Texture[] | FrameObject[])\n    {\n        if (value[0] instanceof Texture)\n        {\n            this._textures = value as Texture[];\n            this._durations = null;\n        }\n        else\n        {\n            this._textures = [];\n            this._durations = [];\n\n            for (let i = 0; i < value.length; i++)\n            {\n                this._textures.push((value[i] as FrameObject).texture);\n                this._durations.push((value[i] as FrameObject).time);\n            }\n        }\n        this._previousFrame = null;\n        this.gotoAndStop(0);\n        this._updateTexture();\n    }\n\n    /** The AnimatedSprite's current frame index. */\n    get currentFrame(): number\n    {\n        let currentFrame = Math.floor(this._currentTime) % this._textures.length;\n\n        if (currentFrame < 0)\n        {\n            currentFrame += this._textures.length;\n        }\n\n        return currentFrame;\n    }\n\n    set currentFrame(value: number)\n    {\n        if (value < 0 || value > this.totalFrames - 1)\n        {\n            throw new Error(`[AnimatedSprite]: Invalid frame index value ${value}, `\n                + `expected to be between 0 and totalFrames ${this.totalFrames}.`);\n        }\n\n        const previousFrame = this.currentFrame;\n\n        this._currentTime = value;\n\n        if (previousFrame !== this.currentFrame)\n        {\n            this._updateTexture();\n        }\n    }\n\n    /**\n     * Indicates if the AnimatedSprite is currently playing.\n     * @readonly\n     */\n    get playing(): boolean\n    {\n        return this._playing;\n    }\n\n    /** Whether to use Ticker.shared to auto update animation time. */\n    get autoUpdate(): boolean\n    {\n        return this._autoUpdate;\n    }\n\n    set autoUpdate(value: boolean)\n    {\n        if (value !== this._autoUpdate)\n        {\n            this._autoUpdate = value;\n\n            if (!this._autoUpdate && this._isConnectedToTicker)\n            {\n                Ticker.shared.remove(this.update, this);\n                this._isConnectedToTicker = false;\n            }\n            else if (this._autoUpdate && !this._isConnectedToTicker && this._playing)\n            {\n                Ticker.shared.add(this.update, this);\n                this._isConnectedToTicker = true;\n            }\n        }\n    }\n}\n\n/**\n * A reference to a frame in an {@link scene.AnimatedSprite}\n * @memberof scene\n */\nexport interface FrameObject\n{\n    /** The {@link Texture} of the frame. */\n    texture: Texture;\n\n    /** The duration of the frame, in milliseconds. */\n    time: number;\n}\n"],"names":["Sprite","Texture","Ticker","UPDATE_PRIORITY"],"mappings":"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"}