{"version":3,"file":"TilingSprite.mjs","sources":["../../../src/scene/sprite-tiling/TilingSprite.ts"],"sourcesContent":["import { Cache } from '../../assets/cache/Cache';\nimport { ObservablePoint } from '../../maths/point/ObservablePoint';\nimport { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport { deprecation, v8_0_0 } from '../../utils/logging/deprecation';\nimport { Transform } from '../../utils/misc/Transform';\nimport { Container } from '../container/Container';\n\nimport type { PointData } from '../../maths/point/PointData';\nimport type { Instruction } from '../../rendering/renderers/shared/instructions/Instruction';\nimport type { View } from '../../rendering/renderers/shared/view/View';\nimport type { Bounds, BoundsData } from '../container/bounds/Bounds';\nimport type { ContainerOptions } from '../container/Container';\nimport type { DestroyOptions } from '../container/destroyTypes';\n\n/**\n * Constructor options used for `TilingSprite` instances. Extends {@link scene.TilingSpriteViewOptions}\n * ```js\n * const tilingSprite = new TilingSprite({\n *    texture: Texture.from('assets/image.png'),\n *    width: 100,\n *    height: 100,\n *    tilePosition: { x: 100, y: 100 },\n *    tileScale: { x: 2, y: 2 },\n * });\n * ```\n * @see {@link scene.TilingSprite}\n * @see {@link scene.TilingSpriteViewOptions}\n * @memberof scene\n */\nexport interface TilingSpriteOptions extends ContainerOptions\n{\n    /**\n     * The anchor point of the sprite\n     * @default {x: 0, y: 0}\n     */\n    anchor?: PointData\n    /**\n     * The offset of the image that is being tiled.\n     * @default {x: 0, y: 0}\n     */\n    tilePosition?: PointData\n    /**\n     * Scaling of the image that is being tiled.\n     * @default {x: 1, y: 1}\n     */\n    tileScale?: PointData\n    /**\n     * The rotation of the image that is being tiled.\n     * @default 0\n     */\n    tileRotation?: number\n    /**\n     * The texture to use for the sprite.\n     * @default Texture.WHITE\n     */\n    texture?: Texture\n    /**\n     * The width of the tiling sprite. #\n     * @default 256\n     */\n    width?: number\n    /**\n     * The height of the tiling sprite.\n     * @default 256\n     */\n    height?: number\n    // TODO needs a better name..\n    /**\n     * @todo\n     * @default false\n     */\n    applyAnchorToTexture?: boolean\n    /** Whether or not to round the x/y position. */\n    roundPixels?: boolean;\n}\n\n/**\n * A tiling sprite is a fast way of rendering a tiling image.\n * @example\n * const tilingSprite = new TilingSprite({\n *    texture: Texture.from('assets/image.png'),\n *    width: 100,\n *    height: 100,\n * });\n *\n * tilingSprite.tilePosition.x = 100;\n * tilingSprite.tilePosition.y = 100;\n *\n * app.stage.addChild(tilingSprite);\n * @memberof scene\n * @extends scene.Container\n */\nexport class TilingSprite extends Container implements View, Instruction\n{\n    /**\n     * Creates a new tiling sprite.\n     * @param source - The source to create the texture from.\n     * @param options - The options for creating the tiling sprite.\n     * @returns A new tiling sprite.\n     */\n    public static from(source: Texture | string, options: TilingSpriteOptions = {})\n    {\n        if (typeof source === 'string')\n        {\n            return new TilingSprite({\n                texture: Cache.get(source),\n                ...options,\n            });\n        }\n\n        return new TilingSprite({\n            texture: source,\n            ...options,\n        });\n    }\n\n    /** default options for the TilingSprite */\n    public static defaultOptions: TilingSpriteOptions = {\n        /** The texture to use for the sprite. */\n        texture: Texture.EMPTY,\n        /** The anchor point of the sprite */\n        anchor: { x: 0, y: 0 },\n        /** The offset of the image that is being tiled. */\n        tilePosition: { x: 0, y: 0 },\n        /** Scaling of the image that is being tiled. */\n        tileScale: { x: 1, y: 1 },\n        /** The rotation of the image that is being tiled. */\n        tileRotation: 0,\n        /** TODO */\n        applyAnchorToTexture: false,\n    };\n\n    public readonly renderPipeId = 'tilingSprite';\n    public readonly canBundle = true;\n    public readonly batched = true;\n\n    public _anchor: ObservablePoint;\n\n    public _tileTransform: Transform;\n    public _texture: Texture;\n    public _applyAnchorToTexture: boolean;\n    public _didTilingSpriteUpdate: boolean;\n\n    public _roundPixels: 0 | 1 = 0;\n\n    private _bounds: BoundsData = { minX: 0, maxX: 1, minY: 0, maxY: 0 };\n    private _boundsDirty = true;\n    private _width: number;\n    private _height: number;\n\n    /**\n     * @param {rendering.Texture | scene.TilingSpriteOptions} options - The options for creating the tiling sprite.\n     */\n    constructor(options?: Texture | TilingSpriteOptions);\n    /** @deprecated since 8.0.0 */\n    constructor(texture: Texture, width: number, height: number);\n    constructor(...args: [(Texture | TilingSpriteOptions)?] | [Texture, number, number])\n    {\n        let options = args[0] || {};\n\n        if (options instanceof Texture)\n        {\n            options = { texture: options };\n        }\n\n        if (args.length > 1)\n        {\n            // #if _DEBUG\n            deprecation(v8_0_0, 'use new TilingSprite({ texture, width:100, height:100 }) instead');\n            // #endif\n\n            options.width = args[1];\n            options.height = args[2];\n        }\n\n        options = { ...TilingSprite.defaultOptions, ...options };\n\n        const {\n            texture,\n            anchor,\n            tilePosition,\n            tileScale,\n            tileRotation,\n            width,\n            height,\n            applyAnchorToTexture,\n            roundPixels,\n            ...rest\n        } = options ?? {};\n\n        super({\n\n            label: 'TilingSprite',\n            ...rest\n        });\n\n        this.allowChildren = false;\n\n        this._anchor = new ObservablePoint(this);\n\n        this._applyAnchorToTexture = applyAnchorToTexture;\n\n        this.texture = texture;\n        this._width = width ?? texture.width;\n        this._height = height ?? texture.height;\n\n        this._tileTransform = new Transform({\n            observer: {\n                _onUpdate: () => this._onTilingSpriteUpdate(),\n            }\n        });\n\n        if (anchor) this.anchor = anchor;\n        this.tilePosition = tilePosition;\n        this.tileScale = tileScale;\n        this.tileRotation = tileRotation;\n\n        this.roundPixels = roundPixels ?? false;\n    }\n\n    /**\n     * Changes frame clamping in corresponding textureMatrix\n     * Change to -0.5 to add a pixel to the edge, recommended for transparent trimmed textures in atlas\n     * @default 0.5\n     * @member {number}\n     */\n    get clampMargin()\n    {\n        return this._texture.textureMatrix.clampMargin;\n    }\n\n    set clampMargin(value: number)\n    {\n        this._texture.textureMatrix.clampMargin = value;\n    }\n\n    /**\n     * The anchor sets the origin point of the sprite. The default value is taken from the {@link Texture}\n     * and passed to the constructor.\n     *\n     * The default is `(0,0)`, this means the sprite's origin is the top left.\n     *\n     * Setting the anchor to `(0.5,0.5)` means the sprite's origin is centered.\n     *\n     * Setting the anchor to `(1,1)` would mean the sprite's origin point will be the bottom right corner.\n     *\n     * If you pass only single parameter, it will set both x and y to the same value as shown in the example below.\n     * @example\n     * import { TilingSprite } from 'pixi.js';\n     *\n     * const sprite = new TilingSprite({texture: Texture.WHITE});\n     * sprite.anchor.set(0.5); // This will set the origin to center. (0.5) is same as (0.5, 0.5).\n     */\n    get anchor(): ObservablePoint\n    {\n        return this._anchor;\n    }\n\n    set anchor(value: PointData | number)\n    {\n        typeof value === 'number' ? this._anchor.set(value) : this._anchor.copyFrom(value);\n    }\n\n    /** The offset of the image that is being tiled. */\n    get tilePosition(): ObservablePoint\n    {\n        return this._tileTransform.position;\n    }\n\n    set tilePosition(value: PointData)\n    {\n        this._tileTransform.position.copyFrom(value);\n    }\n\n    /** The scaling of the image that is being tiled. */\n    get tileScale(): ObservablePoint\n    {\n        return this._tileTransform.scale;\n    }\n\n    set tileScale(value: PointData | number)\n    {\n        typeof value === 'number' ? this._tileTransform.scale.set(value) : this._tileTransform.scale.copyFrom(value);\n    }\n\n    set tileRotation(value)\n    {\n        this._tileTransform.rotation = value;\n    }\n\n    /** The rotation of the image that is being tiled. */\n    get tileRotation()\n    {\n        return this._tileTransform.rotation;\n    }\n\n    /** The transform of the image that is being tiled. */\n    get tileTransform()\n    {\n        return this._tileTransform;\n    }\n\n    /**\n     *  Whether or not to round the x/y position of the sprite.\n     * @type {boolean}\n     */\n    get roundPixels()\n    {\n        return !!this._roundPixels;\n    }\n\n    set roundPixels(value: boolean)\n    {\n        this._roundPixels = value ? 1 : 0;\n    }\n\n    /**\n     * The local bounds of the sprite.\n     * @type {rendering.Bounds}\n     */\n    get bounds()\n    {\n        if (this._boundsDirty)\n        {\n            this._updateBounds();\n            this._boundsDirty = false;\n        }\n\n        return this._bounds;\n    }\n\n    set texture(value: Texture)\n    {\n        if (this._texture === value) return;\n\n        this._texture = value;\n\n        this._onTilingSpriteUpdate();\n    }\n\n    /** The texture that the sprite is using. */\n    get texture()\n    {\n        return this._texture;\n    }\n\n    /** The width of the tiling area. */\n    set width(value: number)\n    {\n        this._width = value;\n        this._onTilingSpriteUpdate();\n    }\n\n    get width()\n    {\n        return this._width;\n    }\n\n    set height(value: number)\n    {\n        this._height = value;\n        this._onTilingSpriteUpdate();\n    }\n\n    /** The height of the tiling area. */\n    get height()\n    {\n        return this._height;\n    }\n\n    private _updateBounds()\n    {\n        const bounds = this._bounds;\n\n        const anchor = this._anchor;\n\n        const width = this._width;\n        const height = this._height;\n\n        bounds.maxX = -anchor._x * width;\n        bounds.minX = bounds.maxX + width;\n\n        bounds.maxY = -anchor._y * height;\n        bounds.minY = bounds.maxY + height;\n    }\n\n    /**\n     * Adds the bounds of this object to the bounds object.\n     * @param bounds - The output bounds object.\n     */\n    public addBounds(bounds: Bounds)\n    {\n        const _bounds = this.bounds;\n\n        bounds.addFrame(\n            _bounds.minX,\n            _bounds.minY,\n            _bounds.maxX,\n            _bounds.maxY,\n        );\n    }\n\n    /**\n     * Checks if the object contains the given point.\n     * @param point - The point to check\n     */\n    public containsPoint(point: PointData)\n    {\n        const width = this.bounds.minX;\n        const height = this.bounds.minY;\n        const x1 = -width * this._anchor._x;\n        let y1 = 0;\n\n        if (point.x >= x1 && point.x <= x1 + width)\n        {\n            y1 = -height * this._anchor._y;\n\n            if (point.y >= y1 && point.y <= y1 + height) return true;\n        }\n\n        return false;\n    }\n\n    private _onTilingSpriteUpdate()\n    {\n        this._boundsDirty = true;\n        this._didTilingSpriteUpdate = true;\n\n        this._didChangeId += 1 << 12;\n\n        if (this.didViewUpdate) return;\n        this.didViewUpdate = true;\n\n        if (this.renderGroup)\n        {\n            this.renderGroup.onChildViewUpdate(this);\n        }\n    }\n\n    /**\n     * Destroys this sprite renderable and optionally its texture.\n     * @param options - Options parameter. A boolean will act as if all options\n     *  have been set to that value\n     * @param {boolean} [options.texture=false] - Should it destroy the current texture of the renderable as well\n     * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the renderable as well\n     */\n    public destroy(options: DestroyOptions = false)\n    {\n        super.destroy(options);\n\n        this._anchor = null;\n        this._tileTransform = null;\n        this._bounds = null;\n\n        const destroyTexture = typeof options === 'boolean' ? options : options?.texture;\n\n        if (destroyTexture)\n        {\n            const destroyTextureSource = typeof options === 'boolean' ? options : options?.textureSource;\n\n            this._texture.destroy(destroyTextureSource);\n        }\n\n        this._texture = null;\n    }\n}\n\n"],"names":[],"mappings":";;;;;;;;AA4FO,MAAM,aAAA,GAAN,MAAM,aAAA,SAAqB,SAClC,CAAA;AAAA,EA+DI,eAAe,IACf,EAAA;AACI,IAAA,IAAI,OAAU,GAAA,IAAA,CAAK,CAAC,CAAA,IAAK,EAAC,CAAA;AAE1B,IAAA,IAAI,mBAAmB,OACvB,EAAA;AACI,MAAU,OAAA,GAAA,EAAE,SAAS,OAAQ,EAAA,CAAA;AAAA,KACjC;AAEA,IAAI,IAAA,IAAA,CAAK,SAAS,CAClB,EAAA;AAEI,MAAA,WAAA,CAAY,QAAQ,kEAAkE,CAAA,CAAA;AAGtF,MAAQ,OAAA,CAAA,KAAA,GAAQ,KAAK,CAAC,CAAA,CAAA;AACtB,MAAQ,OAAA,CAAA,MAAA,GAAS,KAAK,CAAC,CAAA,CAAA;AAAA,KAC3B;AAEA,IAAA,OAAA,GAAU,EAAE,GAAG,aAAa,CAAA,cAAA,EAAgB,GAAG,OAAQ,EAAA,CAAA;AAEvD,IAAM,MAAA;AAAA,MACF,OAAA;AAAA,MACA,MAAA;AAAA,MACA,YAAA;AAAA,MACA,SAAA;AAAA,MACA,YAAA;AAAA,MACA,KAAA;AAAA,MACA,MAAA;AAAA,MACA,oBAAA;AAAA,MACA,WAAA;AAAA,MACA,GAAG,IAAA;AAAA,KACP,GAAI,WAAW,EAAC,CAAA;AAEhB,IAAM,KAAA,CAAA;AAAA,MAEF,KAAO,EAAA,cAAA;AAAA,MACP,GAAG,IAAA;AAAA,KACN,CAAA,CAAA;AA9DL,IAAA,IAAA,CAAgB,YAAe,GAAA,cAAA,CAAA;AAC/B,IAAA,IAAA,CAAgB,SAAY,GAAA,IAAA,CAAA;AAC5B,IAAA,IAAA,CAAgB,OAAU,GAAA,IAAA,CAAA;AAS1B,IAAA,IAAA,CAAO,YAAsB,GAAA,CAAA,CAAA;AAE7B,IAAQ,IAAA,CAAA,OAAA,GAAsB,EAAE,IAAM,EAAA,CAAA,EAAG,MAAM,CAAG,EAAA,IAAA,EAAM,CAAG,EAAA,IAAA,EAAM,CAAE,EAAA,CAAA;AACnE,IAAA,IAAA,CAAQ,YAAe,GAAA,IAAA,CAAA;AAkDnB,IAAA,IAAA,CAAK,aAAgB,GAAA,KAAA,CAAA;AAErB,IAAK,IAAA,CAAA,OAAA,GAAU,IAAI,eAAA,CAAgB,IAAI,CAAA,CAAA;AAEvC,IAAA,IAAA,CAAK,qBAAwB,GAAA,oBAAA,CAAA;AAE7B,IAAA,IAAA,CAAK,OAAU,GAAA,OAAA,CAAA;AACf,IAAK,IAAA,CAAA,MAAA,GAAS,SAAS,OAAQ,CAAA,KAAA,CAAA;AAC/B,IAAK,IAAA,CAAA,OAAA,GAAU,UAAU,OAAQ,CAAA,MAAA,CAAA;AAEjC,IAAK,IAAA,CAAA,cAAA,GAAiB,IAAI,SAAU,CAAA;AAAA,MAChC,QAAU,EAAA;AAAA,QACN,SAAA,EAAW,MAAM,IAAA,CAAK,qBAAsB,EAAA;AAAA,OAChD;AAAA,KACH,CAAA,CAAA;AAED,IAAI,IAAA,MAAA;AAAQ,MAAA,IAAA,CAAK,MAAS,GAAA,MAAA,CAAA;AAC1B,IAAA,IAAA,CAAK,YAAe,GAAA,YAAA,CAAA;AACpB,IAAA,IAAA,CAAK,SAAY,GAAA,SAAA,CAAA;AACjB,IAAA,IAAA,CAAK,YAAe,GAAA,YAAA,CAAA;AAEpB,IAAA,IAAA,CAAK,cAAc,WAAe,IAAA,KAAA,CAAA;AAAA,GACtC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAtHA,OAAc,IAAA,CAAK,MAA0B,EAAA,OAAA,GAA+B,EAC5E,EAAA;AACI,IAAI,IAAA,OAAO,WAAW,QACtB,EAAA;AACI,MAAA,OAAO,IAAI,aAAa,CAAA;AAAA,QACpB,OAAA,EAAS,KAAM,CAAA,GAAA,CAAI,MAAM,CAAA;AAAA,QACzB,GAAG,OAAA;AAAA,OACN,CAAA,CAAA;AAAA,KACL;AAEA,IAAA,OAAO,IAAI,aAAa,CAAA;AAAA,MACpB,OAAS,EAAA,MAAA;AAAA,MACT,GAAG,OAAA;AAAA,KACN,CAAA,CAAA;AAAA,GACL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAgHA,IAAI,WACJ,GAAA;AACI,IAAO,OAAA,IAAA,CAAK,SAAS,aAAc,CAAA,WAAA,CAAA;AAAA,GACvC;AAAA,EAEA,IAAI,YAAY,KAChB,EAAA;AACI,IAAK,IAAA,CAAA,QAAA,CAAS,cAAc,WAAc,GAAA,KAAA,CAAA;AAAA,GAC9C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAmBA,IAAI,MACJ,GAAA;AACI,IAAA,OAAO,IAAK,CAAA,OAAA,CAAA;AAAA,GAChB;AAAA,EAEA,IAAI,OAAO,KACX,EAAA;AACI,IAAO,OAAA,KAAA,KAAU,QAAW,GAAA,IAAA,CAAK,OAAQ,CAAA,GAAA,CAAI,KAAK,CAAI,GAAA,IAAA,CAAK,OAAQ,CAAA,QAAA,CAAS,KAAK,CAAA,CAAA;AAAA,GACrF;AAAA;AAAA,EAGA,IAAI,YACJ,GAAA;AACI,IAAA,OAAO,KAAK,cAAe,CAAA,QAAA,CAAA;AAAA,GAC/B;AAAA,EAEA,IAAI,aAAa,KACjB,EAAA;AACI,IAAK,IAAA,CAAA,cAAA,CAAe,QAAS,CAAA,QAAA,CAAS,KAAK,CAAA,CAAA;AAAA,GAC/C;AAAA;AAAA,EAGA,IAAI,SACJ,GAAA;AACI,IAAA,OAAO,KAAK,cAAe,CAAA,KAAA,CAAA;AAAA,GAC/B;AAAA,EAEA,IAAI,UAAU,KACd,EAAA;AACI,IAAA,OAAO,KAAU,KAAA,QAAA,GAAW,IAAK,CAAA,cAAA,CAAe,KAAM,CAAA,GAAA,CAAI,KAAK,CAAA,GAAI,IAAK,CAAA,cAAA,CAAe,KAAM,CAAA,QAAA,CAAS,KAAK,CAAA,CAAA;AAAA,GAC/G;AAAA,EAEA,IAAI,aAAa,KACjB,EAAA;AACI,IAAA,IAAA,CAAK,eAAe,QAAW,GAAA,KAAA,CAAA;AAAA,GACnC;AAAA;AAAA,EAGA,IAAI,YACJ,GAAA;AACI,IAAA,OAAO,KAAK,cAAe,CAAA,QAAA,CAAA;AAAA,GAC/B;AAAA;AAAA,EAGA,IAAI,aACJ,GAAA;AACI,IAAA,OAAO,IAAK,CAAA,cAAA,CAAA;AAAA,GAChB;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,IAAI,WACJ,GAAA;AACI,IAAO,OAAA,CAAC,CAAC,IAAK,CAAA,YAAA,CAAA;AAAA,GAClB;AAAA,EAEA,IAAI,YAAY,KAChB,EAAA;AACI,IAAK,IAAA,CAAA,YAAA,GAAe,QAAQ,CAAI,GAAA,CAAA,CAAA;AAAA,GACpC;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,IAAI,MACJ,GAAA;AACI,IAAA,IAAI,KAAK,YACT,EAAA;AACI,MAAA,IAAA,CAAK,aAAc,EAAA,CAAA;AACnB,MAAA,IAAA,CAAK,YAAe,GAAA,KAAA,CAAA;AAAA,KACxB;AAEA,IAAA,OAAO,IAAK,CAAA,OAAA,CAAA;AAAA,GAChB;AAAA,EAEA,IAAI,QAAQ,KACZ,EAAA;AACI,IAAA,IAAI,KAAK,QAAa,KAAA,KAAA;AAAO,MAAA,OAAA;AAE7B,IAAA,IAAA,CAAK,QAAW,GAAA,KAAA,CAAA;AAEhB,IAAA,IAAA,CAAK,qBAAsB,EAAA,CAAA;AAAA,GAC/B;AAAA;AAAA,EAGA,IAAI,OACJ,GAAA;AACI,IAAA,OAAO,IAAK,CAAA,QAAA,CAAA;AAAA,GAChB;AAAA;AAAA,EAGA,IAAI,MAAM,KACV,EAAA;AACI,IAAA,IAAA,CAAK,MAAS,GAAA,KAAA,CAAA;AACd,IAAA,IAAA,CAAK,qBAAsB,EAAA,CAAA;AAAA,GAC/B;AAAA,EAEA,IAAI,KACJ,GAAA;AACI,IAAA,OAAO,IAAK,CAAA,MAAA,CAAA;AAAA,GAChB;AAAA,EAEA,IAAI,OAAO,KACX,EAAA;AACI,IAAA,IAAA,CAAK,OAAU,GAAA,KAAA,CAAA;AACf,IAAA,IAAA,CAAK,qBAAsB,EAAA,CAAA;AAAA,GAC/B;AAAA;AAAA,EAGA,IAAI,MACJ,GAAA;AACI,IAAA,OAAO,IAAK,CAAA,OAAA,CAAA;AAAA,GAChB;AAAA,EAEQ,aACR,GAAA;AACI,IAAA,MAAM,SAAS,IAAK,CAAA,OAAA,CAAA;AAEpB,IAAA,MAAM,SAAS,IAAK,CAAA,OAAA,CAAA;AAEpB,IAAA,MAAM,QAAQ,IAAK,CAAA,MAAA,CAAA;AACnB,IAAA,MAAM,SAAS,IAAK,CAAA,OAAA,CAAA;AAEpB,IAAO,MAAA,CAAA,IAAA,GAAO,CAAC,MAAA,CAAO,EAAK,GAAA,KAAA,CAAA;AAC3B,IAAO,MAAA,CAAA,IAAA,GAAO,OAAO,IAAO,GAAA,KAAA,CAAA;AAE5B,IAAO,MAAA,CAAA,IAAA,GAAO,CAAC,MAAA,CAAO,EAAK,GAAA,MAAA,CAAA;AAC3B,IAAO,MAAA,CAAA,IAAA,GAAO,OAAO,IAAO,GAAA,MAAA,CAAA;AAAA,GAChC;AAAA;AAAA;AAAA;AAAA;AAAA,EAMO,UAAU,MACjB,EAAA;AACI,IAAA,MAAM,UAAU,IAAK,CAAA,MAAA,CAAA;AAErB,IAAO,MAAA,CAAA,QAAA;AAAA,MACH,OAAQ,CAAA,IAAA;AAAA,MACR,OAAQ,CAAA,IAAA;AAAA,MACR,OAAQ,CAAA,IAAA;AAAA,MACR,OAAQ,CAAA,IAAA;AAAA,KACZ,CAAA;AAAA,GACJ;AAAA;AAAA;AAAA;AAAA;AAAA,EAMO,cAAc,KACrB,EAAA;AACI,IAAM,MAAA,KAAA,GAAQ,KAAK,MAAO,CAAA,IAAA,CAAA;AAC1B,IAAM,MAAA,MAAA,GAAS,KAAK,MAAO,CAAA,IAAA,CAAA;AAC3B,IAAA,MAAM,EAAK,GAAA,CAAC,KAAQ,GAAA,IAAA,CAAK,OAAQ,CAAA,EAAA,CAAA;AACjC,IAAA,IAAI,EAAK,GAAA,CAAA,CAAA;AAET,IAAA,IAAI,MAAM,CAAK,IAAA,EAAA,IAAM,KAAM,CAAA,CAAA,IAAK,KAAK,KACrC,EAAA;AACI,MAAK,EAAA,GAAA,CAAC,MAAS,GAAA,IAAA,CAAK,OAAQ,CAAA,EAAA,CAAA;AAE5B,MAAA,IAAI,KAAM,CAAA,CAAA,IAAK,EAAM,IAAA,KAAA,CAAM,KAAK,EAAK,GAAA,MAAA;AAAQ,QAAO,OAAA,IAAA,CAAA;AAAA,KACxD;AAEA,IAAO,OAAA,KAAA,CAAA;AAAA,GACX;AAAA,EAEQ,qBACR,GAAA;AACI,IAAA,IAAA,CAAK,YAAe,GAAA,IAAA,CAAA;AACpB,IAAA,IAAA,CAAK,sBAAyB,GAAA,IAAA,CAAA;AAE9B,IAAA,IAAA,CAAK,gBAAgB,CAAK,IAAA,EAAA,CAAA;AAE1B,IAAA,IAAI,IAAK,CAAA,aAAA;AAAe,MAAA,OAAA;AACxB,IAAA,IAAA,CAAK,aAAgB,GAAA,IAAA,CAAA;AAErB,IAAA,IAAI,KAAK,WACT,EAAA;AACI,MAAK,IAAA,CAAA,WAAA,CAAY,kBAAkB,IAAI,CAAA,CAAA;AAAA,KAC3C;AAAA,GACJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASO,OAAA,CAAQ,UAA0B,KACzC,EAAA;AACI,IAAA,KAAA,CAAM,QAAQ,OAAO,CAAA,CAAA;AAErB,IAAA,IAAA,CAAK,OAAU,GAAA,IAAA,CAAA;AACf,IAAA,IAAA,CAAK,cAAiB,GAAA,IAAA,CAAA;AACtB,IAAA,IAAA,CAAK,OAAU,GAAA,IAAA,CAAA;AAEf,IAAA,MAAM,cAAiB,GAAA,OAAO,OAAY,KAAA,SAAA,GAAY,UAAU,OAAS,EAAA,OAAA,CAAA;AAEzE,IAAA,IAAI,cACJ,EAAA;AACI,MAAA,MAAM,oBAAuB,GAAA,OAAO,OAAY,KAAA,SAAA,GAAY,UAAU,OAAS,EAAA,aAAA,CAAA;AAE/E,MAAK,IAAA,CAAA,QAAA,CAAS,QAAQ,oBAAoB,CAAA,CAAA;AAAA,KAC9C;AAEA,IAAA,IAAA,CAAK,QAAW,GAAA,IAAA,CAAA;AAAA,GACpB;AACJ,CAAA,CAAA;AAAA;AArXa,aAAA,CAyBK,cAAsC,GAAA;AAAA;AAAA,EAEhD,SAAS,OAAQ,CAAA,KAAA;AAAA;AAAA,EAEjB,MAAQ,EAAA,EAAE,CAAG,EAAA,CAAA,EAAG,GAAG,CAAE,EAAA;AAAA;AAAA,EAErB,YAAc,EAAA,EAAE,CAAG,EAAA,CAAA,EAAG,GAAG,CAAE,EAAA;AAAA;AAAA,EAE3B,SAAW,EAAA,EAAE,CAAG,EAAA,CAAA,EAAG,GAAG,CAAE,EAAA;AAAA;AAAA,EAExB,YAAc,EAAA,CAAA;AAAA;AAAA,EAEd,oBAAsB,EAAA,KAAA;AAC1B,CAAA,CAAA;AAtCG,IAAM,YAAN,GAAA;;;;"}