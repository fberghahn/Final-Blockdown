{"version":3,"file":"Sprite.mjs","sources":["../../../src/scene/sprite/Sprite.ts"],"sourcesContent":["import { ObservablePoint } from '../../maths/point/ObservablePoint';\nimport { Texture } from '../../rendering/renderers/shared/texture/Texture';\nimport { updateQuadBounds } from '../../utils/data/updateQuadBounds';\nimport { Container } from '../container/Container';\n\nimport type { Size } from '../../maths/misc/Size';\nimport type { PointData } from '../../maths/point/PointData';\nimport type { TextureSourceLike } from '../../rendering/renderers/shared/texture/Texture';\nimport type { View } from '../../rendering/renderers/shared/view/View';\nimport type { Bounds, BoundsData } from '../container/bounds/Bounds';\nimport type { ContainerOptions } from '../container/Container';\nimport type { Optional } from '../container/container-mixins/measureMixin';\nimport type { DestroyOptions } from '../container/destroyTypes';\n\n/**\n * Options for the {@link scene.Sprite} constructor.\n * @memberof scene\n */\nexport interface SpriteOptions extends ContainerOptions\n{\n    /** The texture to use for the sprite. */\n    texture?: Texture;\n    /** The anchor point of the sprite. */\n    anchor?: PointData | number;\n    /** Whether or not to round the x/y position. */\n    roundPixels?: boolean;\n}\n\n/**\n * The Sprite object is one of the most important objects in PixiJS. It is a\n * drawing item that can be added to a scene and rendered to the screen.\n *\n * A sprite can be created directly from an image like this:\n *\n * ```js\n * import { Sprite } from 'pixi.js';\n *\n * const sprite = Sprite.from('assets/image.png');\n * ```\n *\n * The more efficient way to create sprites is using a {@link assets.Spritesheet},\n * as swapping base textures when rendering to the screen is inefficient.\n *\n * ```js\n * import { Assets, Sprite } from 'pixi.js';\n *\n * const sheet = await Assets.load('assets/spritesheet.json');\n * const sprite = new Sprite(sheet.textures['image.png']);\n * ```\n * @memberof scene\n * @extends scene.Container\n */\nexport class Sprite extends Container implements View\n{\n    /**\n     * Helper function that creates a new sprite based on the source you provide.\n     * The source can be - frame id, image, video, canvas element, video element, texture\n     * @param source - Source to create texture from\n     * @param [skipCache] - Whether to skip the cache or not\n     * @returns The newly created sprite\n     */\n    public static from(source: Texture | TextureSourceLike, skipCache = false): Sprite\n    {\n        if (source instanceof Texture)\n        {\n            return new Sprite(source);\n        }\n\n        return new Sprite(Texture.from(source, skipCache));\n    }\n\n    public readonly renderPipeId = 'sprite';\n\n    public batched = true;\n    public readonly _anchor: ObservablePoint;\n\n    // sprite specific..\n    public _texture: Texture;\n    public _didSpriteUpdate = false;\n\n    private readonly _bounds: BoundsData = { minX: 0, maxX: 1, minY: 0, maxY: 0 };\n    private readonly _sourceBounds: BoundsData = { minX: 0, maxX: 1, minY: 0, maxY: 0 };\n    private _boundsDirty = true;\n    private _sourceBoundsDirty = true;\n\n    public _roundPixels: 0 | 1 = 0;\n\n    /**\n     * @param options - The options for creating the sprite.\n     */\n    constructor(options: SpriteOptions | Texture = Texture.EMPTY)\n    {\n        if (options instanceof Texture)\n        {\n            options = { texture: options };\n        }\n\n        // split out\n        const { texture, anchor, roundPixels, width, height, ...rest } = options;\n\n        super({\n            label: 'Sprite',\n            ...rest\n        });\n\n        this._anchor = new ObservablePoint(\n            {\n                _onUpdate: () =>\n                {\n                    this.onViewUpdate();\n                }\n            },\n        );\n\n        if (anchor) this.anchor = anchor;\n        this.texture = texture;\n        this.allowChildren = false;\n        this.roundPixels = roundPixels ?? false;\n\n        // needs to be set after the container has initiated\n        if (width) this.width = width;\n        if (height) this.height = height;\n    }\n\n    set texture(value: Texture)\n    {\n        value ||= Texture.EMPTY;\n\n        if (this._texture === value) return;\n\n        this._texture = value;\n\n        this.onViewUpdate();\n    }\n\n    /** The texture that the sprite is using. */\n    get texture()\n    {\n        return this._texture;\n    }\n\n    /**\n     * The local bounds of the sprite.\n     * @type {rendering.Bounds}\n     */\n    get bounds()\n    {\n        if (this._boundsDirty)\n        {\n            this._updateBounds();\n            this._boundsDirty = false;\n        }\n\n        return this._bounds;\n    }\n\n    /**\n     * The bounds of the sprite, taking the texture's trim into account.\n     * @type {rendering.Bounds}\n     */\n    get sourceBounds()\n    {\n        if (this._sourceBoundsDirty)\n        {\n            this._updateSourceBounds();\n            this._sourceBoundsDirty = false;\n        }\n\n        return this._sourceBounds;\n    }\n\n    /**\n     * Checks if the object contains the given point.\n     * @param point - The point to check\n     */\n    public containsPoint(point: PointData)\n    {\n        const bounds = this.sourceBounds;\n\n        if (point.x >= bounds.maxX && point.x <= bounds.minX)\n        {\n            if (point.y >= bounds.maxY && point.y <= bounds.minY)\n            {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Adds the bounds of this object to the bounds object.\n     * @param bounds - The output bounds object.\n     */\n    public addBounds(bounds: Bounds)\n    {\n        const _bounds = this._texture.trim ? this.sourceBounds : this.bounds;\n\n        bounds.addFrame(_bounds.minX, _bounds.minY, _bounds.maxX, _bounds.maxY);\n    }\n\n    public onViewUpdate()\n    {\n        // increment from the 12th bit!\n        this._didChangeId += 1 << 12;\n        this._didSpriteUpdate = true;\n        this._sourceBoundsDirty = this._boundsDirty = true;\n\n        if (this.didViewUpdate) return;\n        this.didViewUpdate = true;\n\n        if (this.renderGroup)\n        {\n            this.renderGroup.onChildViewUpdate(this);\n        }\n    }\n\n    private _updateBounds()\n    {\n        updateQuadBounds(this._bounds, this._anchor, this._texture, 0);\n    }\n\n    private _updateSourceBounds()\n    {\n        const anchor = this._anchor;\n        const texture = this._texture;\n\n        const sourceBounds = this._sourceBounds;\n\n        const { width, height } = texture.orig;\n\n        sourceBounds.maxX = -anchor._x * width;\n        sourceBounds.minX = sourceBounds.maxX + width;\n\n        sourceBounds.maxY = -anchor._y * height;\n        sourceBounds.minY = sourceBounds.maxY + height;\n    }\n\n    /**\n     * Destroys this sprite renderable and optionally its texture.\n     * @param options - Options parameter. A boolean will act as if all options\n     *  have been set to that value\n     * @param {boolean} [options.texture=false] - Should it destroy the current texture of the renderable as well\n     * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the renderable as well\n     */\n    public destroy(options: DestroyOptions = false)\n    {\n        super.destroy(options);\n\n        const destroyTexture = typeof options === 'boolean' ? options : options?.texture;\n\n        if (destroyTexture)\n        {\n            const destroyTextureSource = typeof options === 'boolean' ? options : options?.textureSource;\n\n            this._texture.destroy(destroyTextureSource);\n        }\n\n        this._texture = null;\n        (this._bounds as null) = null;\n        (this._sourceBounds as null) = null;\n        (this._anchor as null) = null;\n    }\n\n    /**\n     * The anchor sets the origin point of the sprite. The default value is taken from the {@link Texture}\n     * and passed to the constructor.\n     *\n     * The default is `(0,0)`, this means the sprite's origin is the top left.\n     *\n     * Setting the anchor to `(0.5,0.5)` means the sprite's origin is centered.\n     *\n     * Setting the anchor to `(1,1)` would mean the sprite's origin point will be the bottom right corner.\n     *\n     * If you pass only single parameter, it will set both x and y to the same value as shown in the example below.\n     * @example\n     * import { Sprite } from 'pixi.js';\n     *\n     * const sprite = new Sprite({texture: Texture.WHITE});\n     * sprite.anchor.set(0.5); // This will set the origin to center. (0.5) is same as (0.5, 0.5).\n     */\n    get anchor(): ObservablePoint\n    {\n        return this._anchor;\n    }\n\n    set anchor(value: PointData | number)\n    {\n        typeof value === 'number' ? this._anchor.set(value) : this._anchor.copyFrom(value);\n    }\n\n    /**\n     *  Whether or not to round the x/y position of the sprite.\n     * @type {boolean}\n     */\n    get roundPixels()\n    {\n        return !!this._roundPixels;\n    }\n\n    set roundPixels(value: boolean)\n    {\n        this._roundPixels = value ? 1 : 0;\n    }\n\n    /** The width of the sprite, setting this will actually modify the scale to achieve the value set. */\n    override get width(): number\n    {\n        return Math.abs(this.scale.x) * this._texture.orig.width;\n    }\n\n    override set width(value: number)\n    {\n        this._setWidth(value, this._texture.orig.width);\n    }\n\n    /** The height of the sprite, setting this will actually modify the scale to achieve the value set. */\n    override get height(): number\n    {\n        return Math.abs(this.scale.y) * this._texture.orig.height;\n    }\n\n    override set height(value: number)\n    {\n        this._setHeight(value, this._texture.orig.height);\n    }\n\n    /**\n     * Retrieves the size of the Sprite as a [Size]{@link Size} object.\n     * This is faster than get the width and height separately.\n     * @param out - Optional object to store the size in.\n     * @returns - The size of the Sprite.\n     */\n    public override getSize(out?: Size): Size\n    {\n        if (!out)\n        {\n            out = {} as Size;\n        }\n\n        out.width = Math.abs(this.scale.x) * this._texture.orig.width;\n        out.height = Math.abs(this.scale.y) * this._texture.orig.height;\n\n        return out;\n    }\n\n    /**\n     * Sets the size of the Sprite to the specified width and height.\n     * This is faster than setting the width and height separately.\n     * @param value - This can be either a number or a [Size]{@link Size} object.\n     * @param height - The height to set. Defaults to the value of `width` if not provided.\n     */\n    public override setSize(value: number | Optional<Size, 'height'>, height?: number)\n    {\n        let convertedWidth: number;\n        let convertedHeight: number;\n\n        if (typeof value !== 'object')\n        {\n            convertedWidth = value;\n            convertedHeight = height ?? value;\n        }\n        else\n        {\n            convertedWidth = value.width;\n            convertedHeight = value.height ?? value.width;\n        }\n\n        if (convertedWidth !== undefined)\n        {\n            this._setWidth(convertedWidth, this._texture.orig.width);\n        }\n\n        if (convertedHeight !== undefined)\n        {\n            this._setHeight(convertedHeight, this._texture.orig.height);\n        }\n    }\n}\n"],"names":[],"mappings":"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"}