{"version":3,"file":"localUniformMSDFBit.mjs","sources":["../../../../../src/scene/text/sdfShader/shader-bits/localUniformMSDFBit.ts"],"sourcesContent":["// TODO eventually we should not use this bit, but instead use the localUniformBit\n// have the MSDF bit be merged in with the localUniformBit\n\nexport const localUniformMSDFBit = {\n    name: 'local-uniform-msdf-bit',\n    vertex: {\n        header: /* wgsl */`\n            struct LocalUniforms {\n                uColor:vec4<f32>,\n                uTransformMatrix:mat3x3<f32>,\n                uDistance: f32,\n                uRound:f32,\n            }\n\n            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;\n        `,\n        main: /* wgsl */`\n            vColor *= localUniforms.uColor;\n            modelMatrix *= localUniforms.uTransformMatrix;\n        `,\n        end: /* wgsl */`\n            if(localUniforms.uRound == 1)\n            {\n                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n            }\n        `\n    },\n    fragment: {\n        header: /* wgsl */`\n            struct LocalUniforms {\n                uColor:vec4<f32>,\n                uTransformMatrix:mat3x3<f32>,\n                uDistance: f32\n            }\n\n            @group(2) @binding(0) var<uniform> localUniforms : LocalUniforms;\n         `,\n        main: /* wgsl */` \n            outColor = vColor * calculateMSDFAlpha(outColor, localUniforms.uDistance);\n        `\n\n    }\n};\n\nexport const localUniformMSDFBitGl = {\n    name: 'local-uniform-msdf-bit',\n    vertex: {\n        header: /* glsl */`\n            uniform mat3 uTransformMatrix;\n            uniform vec4 uColor;\n            uniform float uRound;\n        `,\n        main: /* glsl */`\n            vColor *= uColor;\n            modelMatrix *= uTransformMatrix;\n        `,\n        end: /* glsl */`\n            if(uRound == 1.)\n            {\n                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n            }\n        `\n    },\n    fragment: {\n        header: /* glsl */`\n            uniform float uDistance;\n         `,\n        main: /* glsl */` \n            outColor = vColor * calculateMSDFAlpha(outColor, uDistance);\n        `\n\n    }\n};\n"],"names":[],"mappings":";AAGO,MAAM,mBAAsB,GAAA;AAAA,EAC/B,IAAM,EAAA,wBAAA;AAAA,EACN,MAAQ,EAAA;AAAA,IACJ,MAAA;AAAA;AAAA,MAAkB,CAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,QAAA,CAAA;AAAA,KAAA;AAAA,IAUlB,IAAA;AAAA;AAAA,MAAgB,CAAA;AAAA;AAAA;AAAA,QAAA,CAAA;AAAA,KAAA;AAAA,IAIhB,GAAA;AAAA;AAAA,MAAe,CAAA;AAAA;AAAA;AAAA;AAAA;AAAA,QAAA,CAAA;AAAA,KAAA;AAAA,GAMnB;AAAA,EACA,QAAU,EAAA;AAAA,IACN,MAAA;AAAA;AAAA,MAAkB,CAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,SAAA,CAAA;AAAA,KAAA;AAAA,IASlB,IAAA;AAAA;AAAA,MAAgB,CAAA;AAAA;AAAA,QAAA,CAAA;AAAA,KAAA;AAAA,GAIpB;AACJ,EAAA;AAEO,MAAM,qBAAwB,GAAA;AAAA,EACjC,IAAM,EAAA,wBAAA;AAAA,EACN,MAAQ,EAAA;AAAA,IACJ,MAAA;AAAA;AAAA,MAAkB,CAAA;AAAA;AAAA;AAAA;AAAA,QAAA,CAAA;AAAA,KAAA;AAAA,IAKlB,IAAA;AAAA;AAAA,MAAgB,CAAA;AAAA;AAAA;AAAA,QAAA,CAAA;AAAA,KAAA;AAAA,IAIhB,GAAA;AAAA;AAAA,MAAe,CAAA;AAAA;AAAA;AAAA;AAAA;AAAA,QAAA,CAAA;AAAA,KAAA;AAAA,GAMnB;AAAA,EACA,QAAU,EAAA;AAAA,IACN,MAAA;AAAA;AAAA,MAAkB,CAAA;AAAA;AAAA,SAAA,CAAA;AAAA,KAAA;AAAA,IAGlB,IAAA;AAAA;AAAA,MAAgB,CAAA;AAAA;AAAA,QAAA,CAAA;AAAA,KAAA;AAAA,GAIpB;AACJ;;;;"}